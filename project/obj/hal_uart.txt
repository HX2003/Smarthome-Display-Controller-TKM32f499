; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\hal_uart.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\hal_uart.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CMSIS_and_startup -I..\CMSIS_and_startup\CMSIS -I.\bsp -I..\Hal_lib\inc -I.\bsp\LCD -I.\bsp\LED -I.\bsp\SPI -I.\bsp\sys -I.\bsp\UART -I.\bsp\Timer -I.\bsp\exit -I.\bsp\touchpad -I.\RTE\_TK499_LTDC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.5.1\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=527 -DARMCM4_FP --omf_browse=.\obj\hal_uart.crf ..\Hal_lib\src\HAL_uart.c]
                          THUMB

                          AREA ||i.UART_ClearFlag||, CODE, READONLY, ALIGN=1

                  UART_ClearFlag PROC
;;;361    */
;;;362    void UART_ClearFlag(UART_TypeDef* UARTx, uint16_t UART_FLAG)
000000  4770              BX       lr
;;;363    {
;;;364      
;;;365    }
;;;366    
                          ENDP


                          AREA ||i.UART_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  UART_ClearITPendingBit PROC
;;;415    */
;;;416    void UART_ClearITPendingBit(UART_TypeDef* UARTx, uint16_t UART_IT)
000000  6141              STR      r1,[r0,#0x14]
;;;417    {
;;;418      
;;;419      /* Check the parameters */
;;;420      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;421      assert_param(IS_UART_CLEAR_IT(UART_IT));
;;;422      assert_param(IS_UART_PERIPH_IT(UARTx, UART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */
;;;423      /*clear UART_IT pendings bit*/
;;;424      UARTx->ICR = UART_IT;
;;;425    }
000002  4770              BX       lr
;;;426    /**
                          ENDP


                          AREA ||i.UART_Cmd||, CODE, READONLY, ALIGN=1

                  UART_Cmd PROC
;;;192    */
;;;193    void UART_Cmd(UART_TypeDef* UARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L3.12|
;;;194    {
;;;195      /* Check the parameters */
;;;196      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;197      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;198      
;;;199      if (NewState != DISABLE)
;;;200      {
;;;201        /* Enable the selected UART by setting the uarten bit in the GCR register */
;;;202        UARTx->GCR |= GCR_UE_Set;
000002  6982              LDR      r2,[r0,#0x18]
000004  f0420201          ORR      r2,r2,#1
000008  6182              STR      r2,[r0,#0x18]
00000a  e004              B        |L3.22|
                  |L3.12|
;;;203      }
;;;204      else
;;;205      {
;;;206        /* Disable the selected UART by clearing the uarten bit in the GCR register */
;;;207        UARTx->GCR &= GCR_UE_Reset;
00000c  6982              LDR      r2,[r0,#0x18]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  6182              STR      r2,[r0,#0x18]
                  |L3.22|
;;;208      }
;;;209    }
000016  4770              BX       lr
;;;210    
                          ENDP


                          AREA ||i.UART_DMACmd||, CODE, READONLY, ALIGN=1

                  UART_DMACmd PROC
;;;262    */
;;;263    void UART_DMACmd(UART_TypeDef* UARTx, uint16_t UART_DMAReq, FunctionalState NewState)
000000  b11a              CBZ      r2,|L4.10|
;;;264    {
;;;265      /* Check the parameters */
;;;266      assert_param(IS_UART_1234_PERIPH(UARTx));
;;;267      assert_param(IS_UART_DMAREQ(UART_DMAReq));  
;;;268      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;269      if (NewState != DISABLE)
;;;270      {
;;;271        /* Enable the DMA transfer */
;;;272        UARTx->GCR |= UART_DMAReq;
000002  6983              LDR      r3,[r0,#0x18]
000004  430b              ORRS     r3,r3,r1
000006  6183              STR      r3,[r0,#0x18]
000008  e002              B        |L4.16|
                  |L4.10|
;;;273      }
;;;274      else
;;;275      {
;;;276        /* Disable the DMA transfer */
;;;277        UARTx->GCR &= ~UART_DMAReq;
00000a  6983              LDR      r3,[r0,#0x18]
00000c  438b              BICS     r3,r3,r1
00000e  6183              STR      r3,[r0,#0x18]
                  |L4.16|
;;;278      }
;;;279    }
000010  4770              BX       lr
;;;280    
                          ENDP


                          AREA ||i.UART_DeInit||, CODE, READONLY, ALIGN=2

                  UART_DeInit PROC
;;;93     */
;;;94     void UART_DeInit(UART_TypeDef* UARTx)
000000  b510              PUSH     {r4,lr}
;;;95     {
000002  4604              MOV      r4,r0
;;;96       /* Check the parameters */
;;;97       assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;98       switch (*(uint32_t*)&UARTx)
000004  4807              LDR      r0,|L5.36|
000006  4420              ADD      r0,r0,r4
000008  b940              CBNZ     r0,|L5.28|
;;;99       {
;;;100      case UART1_BASE:
;;;101        RCC_APB2PeriphResetCmd(RCC_APB2Periph_UART1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  2004              MOVS     r0,#4
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;102        RCC_APB2PeriphResetCmd(RCC_APB2Periph_UART1, DISABLE);
000012  2100              MOVS     r1,#0
000014  2004              MOVS     r0,#4
000016  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;103        break;
00001a  e000              B        |L5.30|
                  |L5.28|
;;;104      default:
;;;105        break;
00001c  bf00              NOP      
                  |L5.30|
00001e  bf00              NOP                            ;103
;;;106      }
;;;107    }
000020  bd10              POP      {r4,pc}
;;;108    
                          ENDP

000022  0000              DCW      0x0000
                  |L5.36|
                          DCD      0xbffef800

                          AREA ||i.UART_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  UART_GetFlagStatus PROC
;;;330    */
;;;331    FlagStatus UART_GetFlagStatus(UART_TypeDef* UARTx, uint16_t UART_FLAG)
000000  4602              MOV      r2,r0
;;;332    {
;;;333      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;334      /* Check the parameters */
;;;335      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;336      assert_param(IS_UART_FLAG(UART_FLAG));
;;;337      if ((UARTx->CSR & UART_FLAG) != (uint16_t)RESET)
000004  6893              LDR      r3,[r2,#8]
000006  400b              ANDS     r3,r3,r1
000008  b10b              CBZ      r3,|L6.14|
;;;338      {
;;;339        bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L6.16|
                  |L6.14|
;;;340      }
;;;341      else
;;;342      {
;;;343        bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L6.16|
;;;344      }
;;;345      return bitstatus;
;;;346    }
000010  4770              BX       lr
;;;347    
                          ENDP


                          AREA ||i.UART_GetITStatus||, CODE, READONLY, ALIGN=1

                  UART_GetITStatus PROC
;;;381    */
;;;382    ITStatus UART_GetITStatus(UART_TypeDef* UARTx, uint16_t UART_IT)
000000  4602              MOV      r2,r0
;;;383    {
;;;384      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;385      /* Check the parameters */
;;;386      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;387      assert_param(IS_UART_FLAG(UART_FLAG));
;;;388      assert_param(IS_UART_PERIPH_FLAG(UARTx, UART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
;;;389      if ((UARTx->ISR & UART_IT) != (uint16_t)RESET)
000004  68d3              LDR      r3,[r2,#0xc]
000006  400b              ANDS     r3,r3,r1
000008  b10b              CBZ      r3,|L7.14|
;;;390      {
;;;391        bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L7.16|
                  |L7.14|
;;;392      }
;;;393      else
;;;394      {
;;;395        bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L7.16|
;;;396      }
;;;397      return bitstatus;
;;;398    }
000010  4770              BX       lr
;;;399    
                          ENDP


                          AREA ||i.UART_ITConfig||, CODE, READONLY, ALIGN=1

                  UART_ITConfig PROC
;;;229    */
;;;230    void UART_ITConfig(UART_TypeDef* UARTx, uint16_t UART_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L8.10|
;;;231    {
;;;232      /* Check the parameters */
;;;233      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;234      assert_param(IS_UART_CONFIG_IT(UART_IT));
;;;235      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;236      
;;;237      if (NewState != DISABLE)
;;;238      {
;;;239        /* Enable the UART_IT interrupt */
;;;240        UARTx->IER  |= UART_IT;
000002  6903              LDR      r3,[r0,#0x10]
000004  430b              ORRS     r3,r3,r1
000006  6103              STR      r3,[r0,#0x10]
000008  e002              B        |L8.16|
                  |L8.10|
;;;241      }
;;;242      else
;;;243      {
;;;244        /* Disable the UART_IT interrupt */
;;;245        UARTx->IER  &= ~ UART_IT;
00000a  6903              LDR      r3,[r0,#0x10]
00000c  438b              BICS     r3,r3,r1
00000e  6103              STR      r3,[r0,#0x10]
                  |L8.16|
;;;246      }
;;;247    }
000010  4770              BX       lr
;;;248    
                          ENDP


                          AREA ||i.UART_Init||, CODE, READONLY, ALIGN=1

                  UART_Init PROC
;;;119    */
;;;120    void UART_Init(UART_TypeDef* UARTx, UART_InitTypeDef* UART_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;121    {
000002  b086              SUB      sp,sp,#0x18
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;122      uint32_t tmpreg = 0x00;
000008  2500              MOVS     r5,#0
;;;123      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;124      /* Check the parameters */
;;;125      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;126      assert_param(IS_UART_BAUDRATE(UART_InitStruct->UART_BaudRate));  
;;;127      assert_param(IS_UART_WORD_LENGTH(UART_InitStruct->UART_WordLength));
;;;128      assert_param(IS_UART_STOPBITS(UART_InitStruct->UART_StopBits));
;;;129      assert_param(IS_UART_PARITY(UART_InitStruct->UART_Parity));
;;;130      assert_param(IS_UART_MODE(UART_InitStruct->UART_Mode));
;;;131      assert_param(IS_UART_HARDWARE_FLOW_CONTROL(UART_InitStruct->UART_HardwareFlowControl));
;;;132      /*---------------------------- UART CCR Configuration -----------------------*/
;;;133      /* get UART CCR values */
;;;134      tmpreg = UARTx->CCR;
00000a  69f5              LDR      r5,[r6,#0x1c]
;;;135      /* Clear spb,psel,pen bits */
;;;136      tmpreg &= CCR_CLEAR_Mask;
00000c  f02505cf          BIC      r5,r5,#0xcf
;;;137      /* Configure the UART Word Length,the UART Stop Bits,Parity ------------*/
;;;138      /* Set the char bits according to UART_WordLength value */
;;;139      /* Set spb bit according to UART_StopBits value */
;;;140      /* Set PEN bit according to UART_Parity value */
;;;141      tmpreg |= (uint32_t)UART_InitStruct->UART_WordLength |(uint32_t)UART_InitStruct->UART_StopBits |UART_InitStruct->UART_Parity;
000010  88a0              LDRH     r0,[r4,#4]
000012  88e1              LDRH     r1,[r4,#6]
000014  4308              ORRS     r0,r0,r1
000016  8921              LDRH     r1,[r4,#8]
000018  4308              ORRS     r0,r0,r1
00001a  4305              ORRS     r5,r5,r0
;;;142      
;;;143      /* Write to UART CCR */
;;;144      UARTx->CCR = tmpreg;
00001c  61f5              STR      r5,[r6,#0x1c]
;;;145      
;;;146      /*---------------------------- UART GCR Configuration -----------------------*/
;;;147      /* get UART GCR values */  
;;;148      tmpreg = UARTx->GCR;
00001e  69b5              LDR      r5,[r6,#0x18]
;;;149      /* Clear TXEN and RXEN ,autoflowen, mode ,uarten bits */
;;;150      tmpreg &= GCR_CLEAR_Mask;
000020  f025051f          BIC      r5,r5,#0x1f
;;;151      /* Set autorlowen bit according to UART_HardwareFlowControl value */
;;;152      /* Set rxen,txen bits according to UART_Mode value */
;;;153      tmpreg |= UART_InitStruct->UART_HardwareFlowControl | UART_InitStruct->UART_Mode ;
000024  89a0              LDRH     r0,[r4,#0xc]
000026  8961              LDRH     r1,[r4,#0xa]
000028  4308              ORRS     r0,r0,r1
00002a  4305              ORRS     r5,r5,r0
;;;154      /* Write to UART GCR */
;;;155      UARTx->GCR = tmpreg;
00002c  61b5              STR      r5,[r6,#0x18]
;;;156      /*---------------------------- UART BRR Configuration -----------------------*/
;;;157      /* Configure the UART Baud Rate -------------------------------------------RCC_ClocksStatus.PCLK1_Frequency;*/
;;;158      RCC_GetClocksFreq(&RCC_ClocksStatus);
00002e  a801              ADD      r0,sp,#4
000030  f7fffffe          BL       RCC_GetClocksFreq
;;;159    
;;;160      /* Determine the UART_baud*/
;;;161        tmpreg = ((RCC_ClocksStatus.PCLK1_Frequency)/(UART_InitStruct->UART_BaudRate)/16) ;
000034  9803              LDR      r0,[sp,#0xc]
000036  6821              LDR      r1,[r4,#0]
000038  fbb0f0f1          UDIV     r0,r0,r1
00003c  0905              LSRS     r5,r0,#4
;;;162    	 /* Write to UART BRR */
;;;163    	  UARTx->BRR = tmpreg; 
00003e  6235              STR      r5,[r6,#0x20]
;;;164    }
000040  b006              ADD      sp,sp,#0x18
000042  bd70              POP      {r4-r6,pc}
;;;165    
                          ENDP


                          AREA ||i.UART_ReceiveData||, CODE, READONLY, ALIGN=1

                  UART_ReceiveData PROC
;;;306    */
;;;307    uint16_t UART_ReceiveData(UART_TypeDef* UARTx)
000000  4601              MOV      r1,r0
;;;308    {
;;;309      /* Check the parameters */
;;;310      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;311      
;;;312      /* Receive Data */
;;;313      return (uint16_t)(UARTx->RDR & (uint16_t)0x00FF);
000002  6848              LDR      r0,[r1,#4]
000004  b2c0              UXTB     r0,r0
;;;314    }
000006  4770              BX       lr
;;;315    
                          ENDP


                          AREA ||i.UART_SendData||, CODE, READONLY, ALIGN=1

                  UART_SendData PROC
;;;289    */
;;;290    void UART_SendData(UART_TypeDef* UARTx, uint16_t Data)
000000  b2ca              UXTB     r2,r1
;;;291    {
;;;292      /* Check the parameters */
;;;293      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;294      assert_param(IS_UART_DATA(Data)); 
;;;295      
;;;296      /* Transmit Data */
;;;297      UARTx->TDR = (Data & (uint16_t)0x00FF);
000002  6002              STR      r2,[r0,#0]
;;;298    }
000004  4770              BX       lr
;;;299    
                          ENDP


                          AREA ||i.UART_StructInit||, CODE, READONLY, ALIGN=1

                  UART_StructInit PROC
;;;171    */
;;;172    void UART_StructInit(UART_InitTypeDef* UART_InitStruct)
000000  f44f5116          MOV      r1,#0x2580
;;;173    {
;;;174      /* UART_InitStruct members default value */
;;;175      UART_InitStruct->UART_BaudRate = 9600;
000004  6001              STR      r1,[r0,#0]
;;;176      UART_InitStruct->UART_WordLength = UART_WordLength_8b;
000006  2130              MOVS     r1,#0x30
000008  8081              STRH     r1,[r0,#4]
;;;177      UART_InitStruct->UART_StopBits = UART_StopBits_1;
00000a  2100              MOVS     r1,#0
00000c  80c1              STRH     r1,[r0,#6]
;;;178      UART_InitStruct->UART_Parity = UART_Parity_No ;
00000e  8101              STRH     r1,[r0,#8]
;;;179      UART_InitStruct->UART_Mode = UART_Mode_Rx | UART_Mode_Tx;
000010  2118              MOVS     r1,#0x18
000012  8141              STRH     r1,[r0,#0xa]
;;;180      UART_InitStruct->UART_HardwareFlowControl = UART_HardwareFlowControl_None; 	
000014  2100              MOVS     r1,#0
000016  8181              STRH     r1,[r0,#0xc]
;;;181    }
000018  4770              BX       lr
;;;182    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Hal_lib\\src\\HAL_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_HAL_uart_c_c95a8597____REV16|
#line 388 "..\\CMSIS_and_startup\\CMSIS\\cmsis_armcc.h"
|__asm___10_HAL_uart_c_c95a8597____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_HAL_uart_c_c95a8597____REVSH|
#line 402
|__asm___10_HAL_uart_c_c95a8597____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_HAL_uart_c_c95a8597____RRX|
#line 587
|__asm___10_HAL_uart_c_c95a8597____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
