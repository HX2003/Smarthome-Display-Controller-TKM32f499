; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\hal_rcc.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\hal_rcc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CMSIS_and_startup -I..\CMSIS_and_startup\CMSIS -I.\bsp -I..\Hal_lib\inc -I.\bsp\LCD -I.\bsp\LED -I.\bsp\SPI -I.\bsp\sys -I.\bsp\UART -I.\bsp\Timer -I.\bsp\exit -I.\bsp\touchpad -I.\RTE\_TK499_LTDC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.5.1\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=527 -DARMCM4_FP --omf_browse=.\obj\hal_rcc.crf ..\Hal_lib\src\HAL_rcc.c]
                          THUMB

                          AREA ||i.RCC_ADCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_ADCCLKConfig PROC
;;;760    */
;;;761    void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
000000  4601              MOV      r1,r0
;;;762    {
;;;763      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;764      /* Check the parameters */
;;;765      assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
;;;766      tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L1.20|
000006  6810              LDR      r0,[r2,#0]
;;;767      /* Clear ADCPRE[1:0] bits */
;;;768      tmpreg &= CFGR_ADCPRE_Reset_Mask;
000008  f4204040          BIC      r0,r0,#0xc000
;;;769      /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
;;;770      tmpreg |= RCC_PCLK2;
00000c  4308              ORRS     r0,r0,r1
;;;771      /* Store the new value */
;;;772      RCC->CFGR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;773    }
000010  4770              BX       lr
;;;774    
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      0x40023808

                          AREA ||i.RCC_AHBPeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphClockCmd PROC
;;;990    */
;;;991    void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
000000  b129              CBZ      r1,|L2.14|
;;;992    {
;;;993      /* Check the parameters */
;;;994      assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
;;;995      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;996      if (NewState != DISABLE)
;;;997      {
;;;998        RCC->AHB1ENR |= RCC_AHBPeriph;
000002  4a06              LDR      r2,|L2.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L2.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L2.24|
                  |L2.14|
;;;999      }
;;;1000     else
;;;1001     {
;;;1002       RCC->AHB1ENR &= ~RCC_AHBPeriph;
00000e  4a03              LDR      r2,|L2.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L2.28|
000016  601a              STR      r2,[r3,#0]
                  |L2.24|
;;;1003     }
;;;1004   }
000018  4770              BX       lr
;;;1005   
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      0x40023820

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;1058   */
;;;1059   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L3.14|
;;;1060   {
;;;1061     /* Check the parameters */
;;;1062     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1063     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1064     if (NewState != DISABLE)
;;;1065     {
;;;1066       RCC->APB1ENR |= RCC_APB1Periph;
000002  4a06              LDR      r2,|L3.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L3.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L3.24|
                  |L3.14|
;;;1067     }
;;;1068     else
;;;1069     {
;;;1070       RCC->APB1ENR &= ~RCC_APB1Periph;
00000e  4a03              LDR      r2,|L3.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L3.28|
000016  601a              STR      r2,[r3,#0]
                  |L3.24|
;;;1071     }
;;;1072   }
000018  4770              BX       lr
;;;1073   
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      0x40023828

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;1116   */
;;;1117   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L4.14|
;;;1118   {
;;;1119     /* Check the parameters */
;;;1120     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1121     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1122     if (NewState != DISABLE)
;;;1123     {
;;;1124       RCC->APB1RSTR |= RCC_APB1Periph;
000002  4a06              LDR      r2,|L4.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L4.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L4.24|
                  |L4.14|
;;;1125     }
;;;1126     else
;;;1127     {
;;;1128       RCC->APB1RSTR &= ~RCC_APB1Periph;
00000e  4a03              LDR      r2,|L4.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L4.28|
000016  601a              STR      r2,[r3,#0]
                  |L4.24|
;;;1129     }
;;;1130   }
000018  4770              BX       lr
;;;1131   
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      0x40023818

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;1019   */
;;;1020   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L5.14|
;;;1021   {
;;;1022     /* Check the parameters */
;;;1023     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1024     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1025     if (NewState != DISABLE)
;;;1026     {
;;;1027       RCC->APB2ENR |= RCC_APB2Periph;
000002  4a06              LDR      r2,|L5.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L5.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L5.24|
                  |L5.14|
;;;1028     }
;;;1029     else
;;;1030     {
;;;1031       RCC->APB2ENR &= ~RCC_APB2Periph;
00000e  4a03              LDR      r2,|L5.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L5.28|
000016  601a              STR      r2,[r3,#0]
                  |L5.24|
;;;1032     }
;;;1033   }
000018  4770              BX       lr
;;;1034   
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      0x4002382c

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;1086   */
;;;1087   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L6.14|
;;;1088   {
;;;1089     /* Check the parameters */
;;;1090     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1091     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1092     if (NewState != DISABLE)
;;;1093     {
;;;1094       RCC->APB2RSTR |= RCC_APB2Periph;
000002  4a06              LDR      r2,|L6.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L6.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L6.24|
                  |L6.14|
;;;1095     }
;;;1096     else
;;;1097     {
;;;1098       RCC->APB2RSTR &= ~RCC_APB2Periph;
00000e  4a03              LDR      r2,|L6.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L6.28|
000016  601a              STR      r2,[r3,#0]
                  |L6.24|
;;;1099     }
;;;1100   }
000018  4770              BX       lr
;;;1101   
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      0x4002381c

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;291    */
;;;292    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000000  4601              MOV      r1,r0
;;;293    {
;;;294      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;295      /* Check the parameters */
;;;296      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;297      tmpreg = RCC->CR;
000004  4a03              LDR      r2,|L7.20|
000006  6810              LDR      r0,[r2,#0]
;;;298      /* Clear HSITRIM[4:0] bits */
;;;299      tmpreg &= CR_HSITRIM_Mask;
000008  f02000f8          BIC      r0,r0,#0xf8
;;;300      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;301      tmpreg |= (uint32_t)HSICalibrationValue << 3;
00000c  ea4000c1          ORR      r0,r0,r1,LSL #3
;;;302      /* Store the new value */
;;;303      RCC->CR = tmpreg;
000010  6010              STR      r0,[r2,#0]
;;;304    }
000012  4770              BX       lr
;;;305    
                          ENDP

                  |L7.20|
                          DCD      0x40023800

                          AREA ||i.RCC_BackupResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_BackupResetCmd PROC
;;;1035   
;;;1036   void RCC_BackupResetCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L8.8|
;;;1037   {
;;;1038     /* Check the parameters */
;;;1039     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1040     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1041   }
000004  4770              BX       lr
;;;1042   
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      0x42470440

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;1234   */
;;;1235   void RCC_ClearFlag(void)
000000  4803              LDR      r0,|L9.16|
;;;1236   {
;;;1237     /* Set RMVF bit to clear the reset flags */
;;;1238     RCC->CSR |= CSR_RMVF_Set;
000002  6800              LDR      r0,[r0,#0]
000004  f0407080          ORR      r0,r0,#0x1000000
000008  4901              LDR      r1,|L9.16|
00000a  6008              STR      r0,[r1,#0]
;;;1239   }
00000c  4770              BX       lr
;;;1240   
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      0x40023834

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;1282   */
;;;1283   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000000  4903              LDR      r1,|L10.16|
;;;1284   {
;;;1285     /* Check the parameters */
;;;1286     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1287     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1288     pending bits */
;;;1289     
;;;1290     RCC->CIR |= (uint32_t)RCC_IT<<16;
000002  6809              LDR      r1,[r1,#0]
000004  ea414100          ORR      r1,r1,r0,LSL #16
000008  4a01              LDR      r2,|L10.16|
00000a  6011              STR      r1,[r2,#0]
;;;1291   }
00000c  4770              BX       lr
;;;1292   
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      0x4002380c

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;1139   */
;;;1140   void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  2801              CMP      r0,#1
;;;1141   {
;;;1142     /* Check the parameters */
;;;1143     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1144     //  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
;;;1145     if(NewState==ENABLE)
000002  d106              BNE      |L11.18|
;;;1146     {
;;;1147       RCC->CR |= (uint32_t)0x00080000;
000004  4906              LDR      r1,|L11.32|
000006  6809              LDR      r1,[r1,#0]
000008  f4412100          ORR      r1,r1,#0x80000
00000c  4a04              LDR      r2,|L11.32|
00000e  6011              STR      r1,[r2,#0]
000010  e005              B        |L11.30|
                  |L11.18|
;;;1148     }
;;;1149     else
;;;1150     {
;;;1151       RCC->CR &= (uint32_t)0xfff7ffff;
000012  4903              LDR      r1,|L11.32|
000014  6809              LDR      r1,[r1,#0]
000016  f4212100          BIC      r1,r1,#0x80000
00001a  4a01              LDR      r2,|L11.32|
00001c  6011              STR      r1,[r2,#0]
                  |L11.30|
;;;1152     }
;;;1153   }
00001e  4770              BX       lr
;;;1154   
                          ENDP

                  |L11.32|
                          DCD      0x40023800

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;198    */
;;;199    void RCC_DeInit(void)
000000  4812              LDR      r0,|L12.76|
;;;200    {
;;;201      /* Set HSION bit */
;;;202      RCC->CR |= (uint32_t)0x00000001;
000002  6800              LDR      r0,[r0,#0]
000004  f0400001          ORR      r0,r0,#1
000008  4910              LDR      r1,|L12.76|
00000a  6008              STR      r0,[r1,#0]
;;;203      /* Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], ADCPRE[1:0] and MCO[2:0] bits */
;;;204      RCC->CFGR &= (uint32_t)0xF8FF0000;
00000c  480f              LDR      r0,|L12.76|
00000e  3008              ADDS     r0,r0,#8
000010  6800              LDR      r0,[r0,#0]
000012  490f              LDR      r1,|L12.80|
000014  4008              ANDS     r0,r0,r1
000016  490d              LDR      r1,|L12.76|
000018  3108              ADDS     r1,r1,#8
00001a  6008              STR      r0,[r1,#0]
;;;205      
;;;206      /* Reset HSEON, CSSON and PLLON bits */
;;;207      RCC->CR &= (uint32_t)0xFEF6FFFF;
00001c  480b              LDR      r0,|L12.76|
00001e  6800              LDR      r0,[r0,#0]
000020  490c              LDR      r1,|L12.84|
000022  4008              ANDS     r0,r0,r1
000024  4909              LDR      r1,|L12.76|
000026  6008              STR      r0,[r1,#0]
;;;208      /* Reset HSEBYP bit */
;;;209      RCC->CR &= (uint32_t)0xFFFBFFFF;
000028  4608              MOV      r0,r1
00002a  6800              LDR      r0,[r0,#0]
00002c  f4202080          BIC      r0,r0,#0x40000
000030  6008              STR      r0,[r1,#0]
;;;210      /* Reset PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE bits */
;;;211      RCC->CFGR &= (uint32_t)0xFF80FFFF;
000032  4806              LDR      r0,|L12.76|
000034  3008              ADDS     r0,r0,#8
000036  6800              LDR      r0,[r0,#0]
000038  f42000fe          BIC      r0,r0,#0x7f0000
00003c  4903              LDR      r1,|L12.76|
00003e  3108              ADDS     r1,r1,#8
000040  6008              STR      r0,[r1,#0]
;;;212      /* Disable all interrupts */
;;;213      RCC->CIR = 0x00000000;
000042  2000              MOVS     r0,#0
000044  1d09              ADDS     r1,r1,#4
000046  6008              STR      r0,[r1,#0]
;;;214    }
000048  4770              BX       lr
;;;215    
                          ENDP

00004a  0000              DCW      0x0000
                  |L12.76|
                          DCD      0x40023800
                  |L12.80|
                          DCD      0xf8ff0000
                  |L12.84|
                          DCD      0xfef6ffff

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;924    */
;;;925    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  b570              PUSH     {r4-r6,lr}
;;;926    {
000002  4604              MOV      r4,r0
;;;927      uint32_t tmp = 0,  presc = 0;
000004  2500              MOVS     r5,#0
000006  2600              MOVS     r6,#0
;;;928      /* Get SYSCLK source -------------------------------------------------------*/
;;;929      tmp = RCC->CFGR & CFGR_SWS_Mask;
000008  4822              LDR      r0,|L13.148|
00000a  6800              LDR      r0,[r0,#0]
00000c  f000050c          AND      r5,r0,#0xc
;;;930      switch (tmp)
000010  b125              CBZ      r5,|L13.28|
000012  2d04              CMP      r5,#4
000014  d005              BEQ      |L13.34|
000016  2d08              CMP      r5,#8
000018  d10d              BNE      |L13.54|
00001a  e005              B        |L13.40|
                  |L13.28|
;;;931      {
;;;932      case 0x00:  /* HSI used as system clock */
;;;933        RCC_Clocks->SYSCLK_Frequency = HSI_Value_Pll_OFF;
00001c  481e              LDR      r0,|L13.152|
00001e  6020              STR      r0,[r4,#0]
;;;934        break;
000020  e00c              B        |L13.60|
                  |L13.34|
;;;935      case 0x04:  /* HSE used as system clock */
;;;936        RCC_Clocks->SYSCLK_Frequency = HSE_Value;
000022  481d              LDR      r0,|L13.152|
000024  6020              STR      r0,[r4,#0]
;;;937        break;
000026  e009              B        |L13.60|
                  |L13.40|
;;;938      case 0x08:  /* PLL used as system clock */
;;;939        /* Get PLL clock source and multiplication factor ----------------------*/
;;;940    
;;;941        RCC_Clocks->SYSCLK_Frequency = TK499_SYS_CLK;
000028  481c              LDR      r0,|L13.156|
00002a  6800              LDR      r0,[r0,#0]  ; TK499_SYS_CLK
00002c  6020              STR      r0,[r4,#0]
;;;942        getSystemClock( & (RCC_Clocks->SYSCLK_Frequency ));
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       getSystemClock
;;;943        break;
000034  e002              B        |L13.60|
                  |L13.54|
;;;944      default:
;;;945        RCC_Clocks->SYSCLK_Frequency = HSI_Value_Pll_OFF;
000036  4818              LDR      r0,|L13.152|
000038  6020              STR      r0,[r4,#0]
;;;946        break;
00003a  bf00              NOP      
                  |L13.60|
00003c  bf00              NOP                            ;934
;;;947      }
;;;948      /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
;;;949      /* Get HCLK prescaler */
;;;950      tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
00003e  4815              LDR      r0,|L13.148|
000040  6800              LDR      r0,[r0,#0]
000042  f00005f0          AND      r5,r0,#0xf0
;;;951      tmp = tmp >> 4;
000046  092d              LSRS     r5,r5,#4
;;;952      presc = APBAHBPrescTable[tmp];
000048  4815              LDR      r0,|L13.160|
00004a  5d46              LDRB     r6,[r0,r5]
;;;953      /* HCLK clock frequency */
;;;954      RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
00004c  6820              LDR      r0,[r4,#0]
00004e  40f0              LSRS     r0,r0,r6
000050  6060              STR      r0,[r4,#4]
;;;955      /* Get PCLK1 prescaler */
;;;956      tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
000052  4810              LDR      r0,|L13.148|
000054  6800              LDR      r0,[r0,#0]
000056  f40065e0          AND      r5,r0,#0x700
;;;957      tmp = tmp >> 8;
00005a  0a2d              LSRS     r5,r5,#8
;;;958      presc = APBAHBPrescTable[tmp];
00005c  4810              LDR      r0,|L13.160|
00005e  5d46              LDRB     r6,[r0,r5]
;;;959      /* PCLK1 clock frequency */
;;;960      RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
000060  6860              LDR      r0,[r4,#4]
000062  40f0              LSRS     r0,r0,r6
000064  60a0              STR      r0,[r4,#8]
;;;961      /* Get PCLK2 prescaler */
;;;962      tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
000066  480b              LDR      r0,|L13.148|
000068  6800              LDR      r0,[r0,#0]
00006a  f4005560          AND      r5,r0,#0x3800
;;;963      tmp = tmp >> 11;
00006e  0aed              LSRS     r5,r5,#11
;;;964      presc = APBAHBPrescTable[tmp];
000070  480b              LDR      r0,|L13.160|
000072  5d46              LDRB     r6,[r0,r5]
;;;965      /* PCLK2 clock frequency */
;;;966      RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
000074  6860              LDR      r0,[r4,#4]
000076  40f0              LSRS     r0,r0,r6
000078  60e0              STR      r0,[r4,#0xc]
;;;967      /* Get ADCCLK prescaler */
;;;968      tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
00007a  4806              LDR      r0,|L13.148|
00007c  6800              LDR      r0,[r0,#0]
00007e  f4004540          AND      r5,r0,#0xc000
;;;969      tmp = tmp >> 14;
000082  0bad              LSRS     r5,r5,#14
;;;970      presc = ADCPrescTable[tmp];
000084  4807              LDR      r0,|L13.164|
000086  5d46              LDRB     r6,[r0,r5]
;;;971      /* ADCCLK clock frequency */
;;;972      RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
000088  68e0              LDR      r0,[r4,#0xc]
00008a  fbb0f0f6          UDIV     r0,r0,r6
00008e  6120              STR      r0,[r4,#0x10]
;;;973    }
000090  bd70              POP      {r4-r6,pc}
;;;974    
                          ENDP

000092  0000              DCW      0x0000
                  |L13.148|
                          DCD      0x40023808
                  |L13.152|
                          DCD      0x007a1200
                  |L13.156|
                          DCD      TK499_SYS_CLK
                  |L13.160|
                          DCD      APBAHBPrescTable
                  |L13.164|
                          DCD      ADCPrescTable

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;1191   */
;;;1192   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000000  b510              PUSH     {r4,lr}
;;;1193   {
000002  4601              MOV      r1,r0
;;;1194     uint32_t tmp = 0;
000004  2200              MOVS     r2,#0
;;;1195     uint32_t statusreg = 0;
000006  2300              MOVS     r3,#0
;;;1196     FlagStatus bitstatus = RESET;
000008  2000              MOVS     r0,#0
;;;1197     /* Check the parameters */
;;;1198     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;1199     /* Get the RCC register index */
;;;1200     tmp = RCC_FLAG >> 5;
00000a  114a              ASRS     r2,r1,#5
;;;1201     if (tmp == 1)               /* The flag to check is in CR register */
00000c  2a01              CMP      r2,#1
00000e  d102              BNE      |L14.22|
;;;1202     {
;;;1203       statusreg = RCC->CR;
000010  4c0a              LDR      r4,|L14.60|
000012  6823              LDR      r3,[r4,#0]
000014  e008              B        |L14.40|
                  |L14.22|
;;;1204     }
;;;1205     else if (tmp == 2)          /* The flag to check is in BDCR register */
000016  2a02              CMP      r2,#2
000018  d103              BNE      |L14.34|
;;;1206     {
;;;1207       statusreg = RCC->BDCR;
00001a  4c08              LDR      r4,|L14.60|
00001c  3430              ADDS     r4,r4,#0x30
00001e  6823              LDR      r3,[r4,#0]
000020  e002              B        |L14.40|
                  |L14.34|
;;;1208     }
;;;1209     else                       /* The flag to check is in CSR register */
;;;1210     {
;;;1211       statusreg = RCC->CSR;
000022  4c06              LDR      r4,|L14.60|
000024  3434              ADDS     r4,r4,#0x34
000026  6823              LDR      r3,[r4,#0]
                  |L14.40|
;;;1212     }
;;;1213     /* Get the flag position */
;;;1214     tmp = RCC_FLAG & FLAG_Mask;
000028  f001021f          AND      r2,r1,#0x1f
;;;1215     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
00002c  2401              MOVS     r4,#1
00002e  4094              LSLS     r4,r4,r2
000030  401c              ANDS     r4,r4,r3
000032  b10c              CBZ      r4,|L14.56|
;;;1216     {
;;;1217       bitstatus = SET;
000034  2001              MOVS     r0,#1
000036  e000              B        |L14.58|
                  |L14.56|
;;;1218     }
;;;1219     else
;;;1220     {
;;;1221       bitstatus = RESET;
000038  2000              MOVS     r0,#0
                  |L14.58|
;;;1222     }
;;;1223     /* Return the flag status */
;;;1224     return bitstatus;
;;;1225   }
00003a  bd10              POP      {r4,pc}
;;;1226   
                          ENDP

                  |L14.60|
                          DCD      0x40023800

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;1252   */
;;;1253   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000000  4601              MOV      r1,r0
;;;1254   {
;;;1255     ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1256     /* Check the parameters */
;;;1257     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1258     /* Check the status of the specified RCC interrupt */
;;;1259     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000004  4a03              LDR      r2,|L15.20|
000006  6812              LDR      r2,[r2,#0]
000008  400a              ANDS     r2,r2,r1
00000a  b10a              CBZ      r2,|L15.16|
;;;1260     {
;;;1261       bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L15.18|
                  |L15.16|
;;;1262     }
;;;1263     else
;;;1264     {
;;;1265       bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L15.18|
;;;1266     }
;;;1267     /* Return the RCC_IT status */
;;;1268     return  bitstatus;
;;;1269   }
000012  4770              BX       lr
;;;1270   
                          ENDP

                  |L15.20|
                          DCD      0x4002380c

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;613    */
;;;614    uint8_t RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L16.12|
;;;615    {
;;;616      return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
000002  6800              LDR      r0,[r0,#0]
000004  f000000c          AND      r0,r0,#0xc
;;;617    }
000008  4770              BX       lr
;;;618    
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      0x40023808

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;634    */
;;;635    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
000000  4601              MOV      r1,r0
;;;636    {
;;;637      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;638      /* Check the parameters */
;;;639      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;640      tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L17.20|
000006  6810              LDR      r0,[r2,#0]
;;;641      /* Clear HPRE[3:0] bits */
;;;642      tmpreg &= CFGR_HPRE_Reset_Mask;
000008  f02000f0          BIC      r0,r0,#0xf0
;;;643      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;644      tmpreg |= RCC_SYSCLK;
00000c  4308              ORRS     r0,r0,r1
;;;645      /* Store the new value */
;;;646      RCC->CFGR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;647    }
000010  4770              BX       lr
;;;648    
                          ENDP

000012  0000              DCW      0x0000
                  |L17.20|
                          DCD      0x40023808

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;227    */
;;;228    void RCC_HSEConfig(uint32_t RCC_HSE)
000000  4911              LDR      r1,|L18.72|
;;;229    {
;;;230      /* Check the parameters */
;;;231      assert_param(IS_RCC_HSE(RCC_HSE));
;;;232      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;233      /* Reset HSEON bit */
;;;234      RCC->CR &= CR_HSEON_Reset;
000002  6809              LDR      r1,[r1,#0]
000004  f4213180          BIC      r1,r1,#0x10000
000008  4a0f              LDR      r2,|L18.72|
00000a  6011              STR      r1,[r2,#0]
;;;235      /* Reset HSEBYP bit */
;;;236      RCC->CR &= CR_HSEBYP_Reset;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  f4212180          BIC      r1,r1,#0x40000
000014  6011              STR      r1,[r2,#0]
;;;237      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;238      switch(RCC_HSE)
000016  f5b03f80          CMP      r0,#0x10000
00001a  d003              BEQ      |L18.36|
00001c  f5b02f80          CMP      r0,#0x40000
000020  d10e              BNE      |L18.64|
000022  e006              B        |L18.50|
                  |L18.36|
;;;239      {
;;;240      case RCC_HSE_ON:
;;;241        /* Set HSEON bit */
;;;242        RCC->CR |= CR_HSEON_Set;
000024  4908              LDR      r1,|L18.72|
000026  6809              LDR      r1,[r1,#0]
000028  f4413180          ORR      r1,r1,#0x10000
00002c  4a06              LDR      r2,|L18.72|
00002e  6011              STR      r1,[r2,#0]
;;;243        break;
000030  e007              B        |L18.66|
                  |L18.50|
;;;244        
;;;245      case RCC_HSE_Bypass:
;;;246        /* Set HSEBYP and HSEON bits */
;;;247        RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
000032  4905              LDR      r1,|L18.72|
000034  6809              LDR      r1,[r1,#0]
000036  f44121a0          ORR      r1,r1,#0x50000
00003a  4a03              LDR      r2,|L18.72|
00003c  6011              STR      r1,[r2,#0]
;;;248        break;
00003e  e000              B        |L18.66|
                  |L18.64|
;;;249        
;;;250      default:
;;;251        break;
000040  bf00              NOP      
                  |L18.66|
000042  bf00              NOP                            ;243
;;;252      }
;;;253    }
000044  4770              BX       lr
;;;254    
                          ENDP

000046  0000              DCW      0x0000
                  |L18.72|
                          DCD      0x40023800

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;313    */
;;;314    void RCC_HSICmd(FunctionalState NewState)
000000  2801              CMP      r0,#1
;;;315    {
;;;316      /* Check the parameters */
;;;317      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;318      
;;;319      if(NewState==ENABLE)
000002  d106              BNE      |L19.18|
;;;320      {
;;;321        RCC->CR |= 0x01;
000004  4906              LDR      r1,|L19.32|
000006  6809              LDR      r1,[r1,#0]
000008  f0410101          ORR      r1,r1,#1
00000c  4a04              LDR      r2,|L19.32|
00000e  6011              STR      r1,[r2,#0]
000010  e005              B        |L19.30|
                  |L19.18|
;;;322      }
;;;323      else
;;;324      {
;;;325        RCC->CR &= 0xfffffffe;
000012  4903              LDR      r1,|L19.32|
000014  6809              LDR      r1,[r1,#0]
000016  f0210101          BIC      r1,r1,#1
00001a  4a01              LDR      r2,|L19.32|
00001c  6011              STR      r1,[r2,#0]
                  |L19.30|
;;;326      }
;;;327    }
00001e  4770              BX       lr
;;;328    /**
                          ENDP

                  |L19.32|
                          DCD      0x40023800

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;713    */
;;;714    void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000000  b131              CBZ      r1,|L20.16|
;;;715    {
;;;716      /* Check the parameters */
;;;717      assert_param(IS_RCC_IT(RCC_IT));
;;;718      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;719      if (NewState != DISABLE)
;;;720      {
;;;721        /* Perform Byte access to RCC_CIR[12:8] bits to enable the selected interrupts */
;;;722        
;;;723        RCC->CIR |= ((uint32_t)RCC_IT)<<8;
000002  4a07              LDR      r2,|L20.32|
000004  6812              LDR      r2,[r2,#0]
000006  ea422200          ORR      r2,r2,r0,LSL #8
00000a  4b05              LDR      r3,|L20.32|
00000c  601a              STR      r2,[r3,#0]
00000e  e005              B        |L20.28|
                  |L20.16|
;;;724      }
;;;725      else
;;;726      {
;;;727        /* Perform Byte access to RCC_CIR[12:8] bits to disable the selected interrupts */
;;;728        
;;;729        RCC->CIR &= ~((uint32_t)RCC_IT<<8);
000010  4a03              LDR      r2,|L20.32|
000012  6812              LDR      r2,[r2,#0]
000014  ea222200          BIC      r2,r2,r0,LSL #8
000018  4b01              LDR      r3,|L20.32|
00001a  601a              STR      r2,[r3,#0]
                  |L20.28|
;;;730      }
;;;731    }
00001c  4770              BX       lr
;;;732    
                          ENDP

00001e  0000              DCW      0x0000
                  |L20.32|
                          DCD      0x4002380c

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;784    */
;;;785    void RCC_LSEConfig(uint8_t RCC_LSE)
000000  4910              LDR      r1,|L21.68|
;;;786    {
;;;787      /* Check the parameters */
;;;788      assert_param(IS_RCC_LSE(RCC_LSE));
;;;789      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;790      /* Reset LSEON bit */
;;;791      RCC->BDCR &= ~((uint32_t)RCC_LSE_ON);
000002  6809              LDR      r1,[r1,#0]
000004  f0210101          BIC      r1,r1,#1
000008  4a0e              LDR      r2,|L21.68|
00000a  6011              STR      r1,[r2,#0]
;;;792      /* Reset LSEBYP bit */
;;;793      RCC->BDCR &= ~((uint32_t)RCC_LSE_ON);
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  f0210101          BIC      r1,r1,#1
000014  6011              STR      r1,[r2,#0]
;;;794      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;795      switch(RCC_LSE)
000016  2801              CMP      r0,#1
000018  d002              BEQ      |L21.32|
00001a  2804              CMP      r0,#4
00001c  d10e              BNE      |L21.60|
00001e  e006              B        |L21.46|
                  |L21.32|
;;;796      {
;;;797      case RCC_LSE_ON:
;;;798        /* Set LSEON bit */
;;;799        RCC->BDCR |= RCC_LSE_ON;
000020  4908              LDR      r1,|L21.68|
000022  6809              LDR      r1,[r1,#0]
000024  f0410101          ORR      r1,r1,#1
000028  4a06              LDR      r2,|L21.68|
00002a  6011              STR      r1,[r2,#0]
;;;800        break;
00002c  e007              B        |L21.62|
                  |L21.46|
;;;801        
;;;802      case RCC_LSE_Bypass:
;;;803        /* Set LSEBYP and LSEON bits */
;;;804        RCC->BDCR |= RCC_LSE_Bypass | RCC_LSE_ON;
00002e  4905              LDR      r1,|L21.68|
000030  6809              LDR      r1,[r1,#0]
000032  f0410105          ORR      r1,r1,#5
000036  4a03              LDR      r2,|L21.68|
000038  6011              STR      r1,[r2,#0]
;;;805        break;            
00003a  e000              B        |L21.62|
                  |L21.60|
;;;806        
;;;807      default:
;;;808        break;      
00003c  bf00              NOP      
                  |L21.62|
00003e  bf00              NOP                            ;800
;;;809      }
;;;810    }
000040  4770              BX       lr
;;;811    
                          ENDP

000042  0000              DCW      0x0000
                  |L21.68|
                          DCD      0x40023830

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;818    */
;;;819    void RCC_LSICmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L22.16|
;;;820    {
;;;821      /* Check the parameters */
;;;822      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;823      
;;;824      if (NewState != DISABLE)
;;;825      {
;;;826        RCC->CSR |= 0x00000001;
000002  4907              LDR      r1,|L22.32|
000004  6809              LDR      r1,[r1,#0]
000006  f0410101          ORR      r1,r1,#1
00000a  4a05              LDR      r2,|L22.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L22.28|
                  |L22.16|
;;;827      }
;;;828      else
;;;829      {
;;;830        RCC->CSR &= 0xfffffffe;
000010  4903              LDR      r1,|L22.32|
000012  6809              LDR      r1,[r1,#0]
000014  f0210101          BIC      r1,r1,#1
000018  4a01              LDR      r2,|L22.32|
00001a  6011              STR      r1,[r2,#0]
                  |L22.28|
;;;831      }
;;;832    }
00001c  4770              BX       lr
;;;833    
                          ENDP

00001e  0000              DCW      0x0000
                  |L22.32|
                          DCD      0x40023834

                          AREA ||i.RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  RCC_MCOConfig PROC
;;;1165   */
;;;1166   void RCC_MCOConfig(uint8_t RCC_MCO)
000000  4903              LDR      r1,|L23.16|
;;;1167   {
;;;1168     /* Check the parameters */
;;;1169     assert_param(IS_RCC_MCO(RCC_MCO));
;;;1170     /* Perform Byte access to MCO[2:0] bits to select the MCO source */
;;;1171     
;;;1172     RCC->CFGR |= (RCC_MCO<<24);
000002  6809              LDR      r1,[r1,#0]
000004  ea416100          ORR      r1,r1,r0,LSL #24
000008  4a01              LDR      r2,|L23.16|
00000a  6011              STR      r1,[r2,#0]
;;;1173   }
00000c  4770              BX       lr
;;;1174   
                          ENDP

00000e  0000              DCW      0x0000
                  |L23.16|
                          DCD      0x40023808

                          AREA ||i.RCC_PCLK1Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK1Config PROC
;;;660    */
;;;661    void RCC_PCLK1Config(uint32_t RCC_HCLK)
000000  4601              MOV      r1,r0
;;;662    {
;;;663      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;664      /* Check the parameters */
;;;665      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;666      tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L24.20|
000006  6810              LDR      r0,[r2,#0]
;;;667      /* Clear PPRE1[2:0] bits */
;;;668      tmpreg &= CFGR_PPRE1_Reset_Mask;
000008  f42060e0          BIC      r0,r0,#0x700
;;;669      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;670      tmpreg |= RCC_HCLK;
00000c  4308              ORRS     r0,r0,r1
;;;671      /* Store the new value */
;;;672      RCC->CFGR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;673    }
000010  4770              BX       lr
;;;674    
                          ENDP

000012  0000              DCW      0x0000
                  |L24.20|
                          DCD      0x40023808

                          AREA ||i.RCC_PCLK2Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK2Config PROC
;;;686    */
;;;687    void RCC_PCLK2Config(uint32_t RCC_HCLK)
000000  4601              MOV      r1,r0
;;;688    {
;;;689      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;690      /* Check the parameters */
;;;691      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;692      tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L25.20|
000006  6810              LDR      r0,[r2,#0]
;;;693      /* Clear PPRE2[2:0] bits */
;;;694      tmpreg &= CFGR_PPRE2_Reset_Mask;
000008  f4205060          BIC      r0,r0,#0x3800
;;;695      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;696      tmpreg |= RCC_HCLK << 3;
00000c  ea4000c1          ORR      r0,r0,r1,LSL #3
;;;697      /* Store the new value */
;;;698      RCC->CFGR = tmpreg;
000010  6010              STR      r0,[r2,#0]
;;;699    }
000012  4770              BX       lr
;;;700    
                          ENDP

                  |L25.20|
                          DCD      0x40023808

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;547    */
;;;548    void RCC_PLLCmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L26.16|
;;;549    {
;;;550      /* Check the parameters */
;;;551      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;552      
;;;553      if (NewState != DISABLE)
;;;554      {
;;;555        RCC->CR |= 0x01000000;
000002  4907              LDR      r1,|L26.32|
000004  6809              LDR      r1,[r1,#0]
000006  f0417180          ORR      r1,r1,#0x1000000
00000a  4a05              LDR      r2,|L26.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L26.28|
                  |L26.16|
;;;556      }
;;;557      else
;;;558      {
;;;559        RCC->CR &= 0xfeffffff;
000010  4903              LDR      r1,|L26.32|
000012  6809              LDR      r1,[r1,#0]
000014  f0217180          BIC      r1,r1,#0x1000000
000018  4a01              LDR      r2,|L26.32|
00001a  6011              STR      r1,[r2,#0]
                  |L26.28|
;;;560      }
;;;561    }
00001c  4770              BX       lr
;;;562    
                          ENDP

00001e  0000              DCW      0x0000
                  |L26.32|
                          DCD      0x40023800

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;388    */
;;;389    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
000000  b570              PUSH     {r4-r6,lr}
;;;390    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;391      uint32_t tmpreg = 0;
000006  2500              MOVS     r5,#0
;;;392      /* Check the parameters */
;;;393      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;394      assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
;;;395      tmpreg = RCC->CFGR;
000008  48a4              LDR      r0,|L27.668|
00000a  6805              LDR      r5,[r0,#0]
;;;396      /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
;;;397      tmpreg &= CFGR_PLL_Mask;
00000c  f425157c          BIC      r5,r5,#0x3f0000
;;;398      /* Set the PLL configuration bits */
;;;399      tmpreg |= RCC_PLLSource;
000010  4335              ORRS     r5,r5,r6
;;;400      /* Store the new value */
;;;401      RCC->CFGR = tmpreg;
000012  6005              STR      r5,[r0,#0]
;;;402      
;;;403     if(RCC_PLLMul==RCC_PLLMul_2)
000014  b944              CBNZ     r4,|L27.40|
;;;404      {
;;;405    		TK499_PLL_FACTOR = 2;
000016  2002              MOVS     r0,#2
000018  49a1              LDR      r1,|L27.672|
00001a  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;406        RCC_PLLDMDNConfig(RCC_PLLSource, 0x00000001, 0x00000000,0x00000000); //Frclk*8/4
00001c  2300              MOVS     r3,#0
00001e  461a              MOV      r2,r3
000020  2101              MOVS     r1,#1
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.40|
;;;407      }
;;;408      if(RCC_PLLMul==RCC_PLLMul_3)
000028  f5b42f80          CMP      r4,#0x40000
00002c  d108              BNE      |L27.64|
;;;409      {
;;;410    		TK499_PLL_FACTOR = 3;
00002e  2003              MOVS     r0,#3
000030  499b              LDR      r1,|L27.672|
000032  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;411        RCC_PLLDMDNConfig(RCC_PLLSource, 0x00000002, 0x00000000,0x00000000);//Frclk*6/2
000034  2300              MOVS     r3,#0
000036  461a              MOV      r2,r3
000038  2102              MOVS     r1,#2
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.64|
;;;412      }
;;;413      if(RCC_PLLMul==RCC_PLLMul_4)
000040  f5b42f00          CMP      r4,#0x80000
000044  d108              BNE      |L27.88|
;;;414      {
;;;415    		TK499_PLL_FACTOR = 4;
000046  2004              MOVS     r0,#4
000048  4995              LDR      r1,|L27.672|
00004a  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;416        RCC_PLLDMDNConfig(RCC_PLLSource, 0x00000003, 0x00000000,0x00000000);//Frclk*8/2
00004c  2300              MOVS     r3,#0
00004e  461a              MOV      r2,r3
000050  2103              MOVS     r1,#3
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.88|
;;;417      }
;;;418      if(RCC_PLLMul==RCC_PLLMul_5)
000058  f5b42f40          CMP      r4,#0xc0000
00005c  d108              BNE      |L27.112|
;;;419      {
;;;420    		TK499_PLL_FACTOR = 5;
00005e  2005              MOVS     r0,#5
000060  498f              LDR      r1,|L27.672|
000062  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;421        RCC_PLLDMDNConfig(RCC_PLLSource, 0x00000013, 0x00000001,0x00000001);//Frclk*10/2
000064  2301              MOVS     r3,#1
000066  461a              MOV      r2,r3
000068  2113              MOVS     r1,#0x13
00006a  4630              MOV      r0,r6
00006c  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.112|
;;;422      }
;;;423      if(RCC_PLLMul==RCC_PLLMul_6)
000070  f5b41f80          CMP      r4,#0x100000
000074  d108              BNE      |L27.136|
;;;424      {
;;;425    		TK499_PLL_FACTOR = 6;
000076  2006              MOVS     r0,#6
000078  4989              LDR      r1,|L27.672|
00007a  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;426        RCC_PLLDMDNConfig(RCC_PLLSource, 0x00000005, 0x00000000,0x00000000);//Frclk*12/2
00007c  2300              MOVS     r3,#0
00007e  461a              MOV      r2,r3
000080  2105              MOVS     r1,#5
000082  4630              MOV      r0,r6
000084  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.136|
;;;427      }
;;;428      if(RCC_PLLMul==RCC_PLLMul_7)
000088  f5b41fa0          CMP      r4,#0x140000
00008c  d108              BNE      |L27.160|
;;;429      {
;;;430    		TK499_PLL_FACTOR = 7;
00008e  2007              MOVS     r0,#7
000090  4983              LDR      r1,|L27.672|
000092  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;431        RCC_PLLDMDNConfig(RCC_PLLSource, 0x00000006, 0x00000000,0x00000000);//Frclk*14/2
000094  2300              MOVS     r3,#0
000096  461a              MOV      r2,r3
000098  2106              MOVS     r1,#6
00009a  4630              MOV      r0,r6
00009c  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.160|
;;;432      }
;;;433      if(RCC_PLLMul==RCC_PLLMul_8)
0000a0  f5b41fc0          CMP      r4,#0x180000
0000a4  d108              BNE      |L27.184|
;;;434      {
;;;435    		TK499_PLL_FACTOR = 8;
0000a6  2008              MOVS     r0,#8
0000a8  497d              LDR      r1,|L27.672|
0000aa  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;436        RCC_PLLDMDNConfig(RCC_PLLSource, 0x00000007, 0x00000000,0x00000000);//Frclk*16/2
0000ac  2300              MOVS     r3,#0
0000ae  461a              MOV      r2,r3
0000b0  2107              MOVS     r1,#7
0000b2  4630              MOV      r0,r6
0000b4  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.184|
;;;437      }
;;;438      if(RCC_PLLMul==RCC_PLLMul_9)
0000b8  f5b41fe0          CMP      r4,#0x1c0000
0000bc  d108              BNE      |L27.208|
;;;439      {
;;;440    		TK499_PLL_FACTOR = 9;
0000be  2009              MOVS     r0,#9
0000c0  4977              LDR      r1,|L27.672|
0000c2  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;441        RCC_PLLDMDNConfig(RCC_PLLSource, 0x00000008, 0x00000000,0x00000000);//Frclk*18/2
0000c4  2300              MOVS     r3,#0
0000c6  461a              MOV      r2,r3
0000c8  2108              MOVS     r1,#8
0000ca  4630              MOV      r0,r6
0000cc  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.208|
;;;442      }
;;;443      if(RCC_PLLMul==RCC_PLLMul_10)
0000d0  f5b41f00          CMP      r4,#0x200000
0000d4  d108              BNE      |L27.232|
;;;444      {
;;;445    		TK499_PLL_FACTOR = 10;
0000d6  200a              MOVS     r0,#0xa
0000d8  4971              LDR      r1,|L27.672|
0000da  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;446        RCC_PLLDMDNConfig(RCC_PLLSource, 0x00000009, 0x00000000,0x00000000);//Frclk*20/2
0000dc  2300              MOVS     r3,#0
0000de  461a              MOV      r2,r3
0000e0  2109              MOVS     r1,#9
0000e2  4630              MOV      r0,r6
0000e4  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.232|
;;;447      }
;;;448      if(RCC_PLLMul==RCC_PLLMul_11)
0000e8  f5b41f10          CMP      r4,#0x240000
0000ec  d108              BNE      |L27.256|
;;;449      {
;;;450    		TK499_PLL_FACTOR = 11;
0000ee  200b              MOVS     r0,#0xb
0000f0  496b              LDR      r1,|L27.672|
0000f2  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;451        RCC_PLLDMDNConfig(RCC_PLLSource, 0x0000000a, 0x00000000,0x00000000);//Frclk*22/2
0000f4  2300              MOVS     r3,#0
0000f6  461a              MOV      r2,r3
0000f8  210a              MOVS     r1,#0xa
0000fa  4630              MOV      r0,r6
0000fc  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.256|
;;;452      }
;;;453      if(RCC_PLLMul==RCC_PLLMul_12)
000100  f5b41f20          CMP      r4,#0x280000
000104  d108              BNE      |L27.280|
;;;454      {
;;;455    		TK499_PLL_FACTOR = 12;
000106  200c              MOVS     r0,#0xc
000108  4965              LDR      r1,|L27.672|
00010a  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;456        RCC_PLLDMDNConfig(RCC_PLLSource, 0x0000000b, 0x00000000,0x00000000);//Frclk*24/2
00010c  2300              MOVS     r3,#0
00010e  461a              MOV      r2,r3
000110  210b              MOVS     r1,#0xb
000112  4630              MOV      r0,r6
000114  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.280|
;;;457      }
;;;458      if(RCC_PLLMul==RCC_PLLMul_13)
000118  f5b41f30          CMP      r4,#0x2c0000
00011c  d108              BNE      |L27.304|
;;;459      {
;;;460    		TK499_PLL_FACTOR = 13;
00011e  200d              MOVS     r0,#0xd
000120  495f              LDR      r1,|L27.672|
000122  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;461        RCC_PLLDMDNConfig(RCC_PLLSource, 0x0000000c, 0x00000000,0x00000000);//Frclk*26/2
000124  2300              MOVS     r3,#0
000126  461a              MOV      r2,r3
000128  210c              MOVS     r1,#0xc
00012a  4630              MOV      r0,r6
00012c  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.304|
;;;462      }
;;;463      if(RCC_PLLMul==RCC_PLLMul_14)
000130  f5b41f40          CMP      r4,#0x300000
000134  d108              BNE      |L27.328|
;;;464      {
;;;465    		TK499_PLL_FACTOR = 14;
000136  200e              MOVS     r0,#0xe
000138  4959              LDR      r1,|L27.672|
00013a  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;466        RCC_PLLDMDNConfig(RCC_PLLSource, 0x0000000d, 0x00000000,0x00000000);//Frclk*28/2
00013c  2300              MOVS     r3,#0
00013e  461a              MOV      r2,r3
000140  210d              MOVS     r1,#0xd
000142  4630              MOV      r0,r6
000144  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.328|
;;;467      }
;;;468      if(RCC_PLLMul==RCC_PLLMul_15)
000148  f5b41f50          CMP      r4,#0x340000
00014c  d108              BNE      |L27.352|
;;;469      {
;;;470    		TK499_PLL_FACTOR = 15;
00014e  200f              MOVS     r0,#0xf
000150  4953              LDR      r1,|L27.672|
000152  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;471        RCC_PLLDMDNConfig(RCC_PLLSource, 0x0000000e, 0x00000000,0x00000000);//Frclk*30/2
000154  2300              MOVS     r3,#0
000156  461a              MOV      r2,r3
000158  210e              MOVS     r1,#0xe
00015a  4630              MOV      r0,r6
00015c  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.352|
;;;472      }
;;;473      if(RCC_PLLMul==RCC_PLLMul_16)
000160  f5b41f60          CMP      r4,#0x380000
000164  d108              BNE      |L27.376|
;;;474      {
;;;475    		TK499_PLL_FACTOR = 16;
000166  2010              MOVS     r0,#0x10
000168  494d              LDR      r1,|L27.672|
00016a  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;476        RCC_PLLDMDNConfig(RCC_PLLSource, 0x0000000f, 0x00000000,0x00000000);//Frclk*32/2
00016c  2300              MOVS     r3,#0
00016e  461a              MOV      r2,r3
000170  210f              MOVS     r1,#0xf
000172  4630              MOV      r0,r6
000174  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.376|
;;;477      }
;;;478    	if(RCC_PLLMul==RCC_PLLMul_17)
000178  f5b41f70          CMP      r4,#0x3c0000
00017c  d108              BNE      |L27.400|
;;;479      {
;;;480    		TK499_PLL_FACTOR = 17;
00017e  2011              MOVS     r0,#0x11
000180  4947              LDR      r1,|L27.672|
000182  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;481        RCC_PLLDMDNConfig(RCC_PLLSource, 0x00000010, 0x00000000,0x00000000);//Frclk*32/2
000184  2300              MOVS     r3,#0
000186  461a              MOV      r2,r3
000188  2110              MOVS     r1,#0x10
00018a  4630              MOV      r0,r6
00018c  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.400|
;;;482      }
;;;483    	if(RCC_PLLMul==RCC_PLLMul_18)
000190  f5b40f80          CMP      r4,#0x400000
000194  d108              BNE      |L27.424|
;;;484      {
;;;485    		TK499_PLL_FACTOR = 18;
000196  2012              MOVS     r0,#0x12
000198  4941              LDR      r1,|L27.672|
00019a  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;486        RCC_PLLDMDNConfig(RCC_PLLSource, 0x00000011, 0x00000000,0x00000000);//Frclk*32/2
00019c  2300              MOVS     r3,#0
00019e  461a              MOV      r2,r3
0001a0  2111              MOVS     r1,#0x11
0001a2  4630              MOV      r0,r6
0001a4  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.424|
;;;487      }
;;;488    	if(RCC_PLLMul==RCC_PLLMul_19)
0001a8  f5b40f98          CMP      r4,#0x4c0000
0001ac  d108              BNE      |L27.448|
;;;489      {
;;;490    		TK499_PLL_FACTOR = 19;
0001ae  2013              MOVS     r0,#0x13
0001b0  493b              LDR      r1,|L27.672|
0001b2  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;491        RCC_PLLDMDNConfig(RCC_PLLSource, 0x00000012, 0x00000000,0x00000000);//Frclk*32/2
0001b4  2300              MOVS     r3,#0
0001b6  461a              MOV      r2,r3
0001b8  2112              MOVS     r1,#0x12
0001ba  4630              MOV      r0,r6
0001bc  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.448|
;;;492      }
;;;493    	if(RCC_PLLMul==RCC_PLLMul_20)
0001c0  f5b40fa0          CMP      r4,#0x500000
0001c4  d108              BNE      |L27.472|
;;;494      {
;;;495    		TK499_PLL_FACTOR = 20;
0001c6  2014              MOVS     r0,#0x14
0001c8  4935              LDR      r1,|L27.672|
0001ca  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;496        RCC_PLLDMDNConfig(RCC_PLLSource, 0x00000013, 0x00000000,0x00000000);//Frclk*32/2
0001cc  2300              MOVS     r3,#0
0001ce  461a              MOV      r2,r3
0001d0  2113              MOVS     r1,#0x13
0001d2  4630              MOV      r0,r6
0001d4  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.472|
;;;497      }
;;;498    	if(RCC_PLLMul==RCC_PLLMul_21)
0001d8  f5b40fa8          CMP      r4,#0x540000
0001dc  d108              BNE      |L27.496|
;;;499      {
;;;500    		TK499_PLL_FACTOR = 21;
0001de  2015              MOVS     r0,#0x15
0001e0  492f              LDR      r1,|L27.672|
0001e2  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;501        RCC_PLLDMDNConfig(RCC_PLLSource, 0x00000014, 0x00000000,0x00000000);//Frclk*32/2
0001e4  2300              MOVS     r3,#0
0001e6  461a              MOV      r2,r3
0001e8  2114              MOVS     r1,#0x14
0001ea  4630              MOV      r0,r6
0001ec  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.496|
;;;502      }
;;;503    	if(RCC_PLLMul==RCC_PLLMul_22)
0001f0  f5b40fb0          CMP      r4,#0x580000
0001f4  d108              BNE      |L27.520|
;;;504      {
;;;505    		TK499_PLL_FACTOR = 22;
0001f6  2016              MOVS     r0,#0x16
0001f8  4929              LDR      r1,|L27.672|
0001fa  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;506        RCC_PLLDMDNConfig(RCC_PLLSource, 0x00000015, 0x00000000,0x00000000);//Frclk*32/2
0001fc  2300              MOVS     r3,#0
0001fe  461a              MOV      r2,r3
000200  2115              MOVS     r1,#0x15
000202  4630              MOV      r0,r6
000204  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.520|
;;;507      }	
;;;508    	if(RCC_PLLMul==RCC_PLLMul_23)
000208  4826              LDR      r0,|L27.676|
00020a  4284              CMP      r4,r0
00020c  d108              BNE      |L27.544|
;;;509      {
;;;510    		TK499_PLL_FACTOR = 23;
00020e  2017              MOVS     r0,#0x17
000210  4923              LDR      r1,|L27.672|
000212  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;511        RCC_PLLDMDNConfig(RCC_PLLSource, 0x00000016, 0x00000000,0x00000000);//Frclk*32/2
000214  2300              MOVS     r3,#0
000216  461a              MOV      r2,r3
000218  2116              MOVS     r1,#0x16
00021a  4630              MOV      r0,r6
00021c  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.544|
;;;512      }
;;;513    		if(RCC_PLLMul==RCC_PLLMul_24)
000220  4821              LDR      r0,|L27.680|
000222  4284              CMP      r4,r0
000224  d108              BNE      |L27.568|
;;;514      {
;;;515    		TK499_PLL_FACTOR = 24;
000226  2018              MOVS     r0,#0x18
000228  491d              LDR      r1,|L27.672|
00022a  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;516        RCC_PLLDMDNConfig(RCC_PLLSource, 0x00000017, 0x00000000,0x00000000);//Frclk*32/2
00022c  2300              MOVS     r3,#0
00022e  461a              MOV      r2,r3
000230  2117              MOVS     r1,#0x17
000232  4630              MOV      r0,r6
000234  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.568|
;;;517      }
;;;518    		if(RCC_PLLMul==RCC_PLLMul_25)
000238  481c              LDR      r0,|L27.684|
00023a  4284              CMP      r4,r0
00023c  d108              BNE      |L27.592|
;;;519      {
;;;520    		TK499_PLL_FACTOR = 25;
00023e  2019              MOVS     r0,#0x19
000240  4917              LDR      r1,|L27.672|
000242  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;521        RCC_PLLDMDNConfig(RCC_PLLSource, 0x00000018, 0x00000000,0x00000000);//Frclk*32/2
000244  2300              MOVS     r3,#0
000246  461a              MOV      r2,r3
000248  2118              MOVS     r1,#0x18
00024a  4630              MOV      r0,r6
00024c  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.592|
;;;522      }
;;;523    		if(RCC_PLLMul==RCC_PLLMul_26)
000250  4817              LDR      r0,|L27.688|
000252  4284              CMP      r4,r0
000254  d108              BNE      |L27.616|
;;;524      {
;;;525    		TK499_PLL_FACTOR = 26;
000256  201a              MOVS     r0,#0x1a
000258  4911              LDR      r1,|L27.672|
00025a  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;526        RCC_PLLDMDNConfig(RCC_PLLSource, 0x00000019, 0x00000000,0x00000000);//Frclk*32/2
00025c  2300              MOVS     r3,#0
00025e  461a              MOV      r2,r3
000260  2119              MOVS     r1,#0x19
000262  4630              MOV      r0,r6
000264  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.616|
;;;527      }
;;;528    		if(RCC_PLLMul==RCC_PLLMul_27)
000268  4812              LDR      r0,|L27.692|
00026a  4284              CMP      r4,r0
00026c  d108              BNE      |L27.640|
;;;529      {
;;;530    		TK499_PLL_FACTOR = 27;
00026e  201b              MOVS     r0,#0x1b
000270  490b              LDR      r1,|L27.672|
000272  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;531        RCC_PLLDMDNConfig(RCC_PLLSource, 0x00000020, 0x00000000,0x00000000);//Frclk*32/2
000274  2300              MOVS     r3,#0
000276  461a              MOV      r2,r3
000278  2120              MOVS     r1,#0x20
00027a  4630              MOV      r0,r6
00027c  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.640|
;;;532      }
;;;533    		if(RCC_PLLMul==RCC_PLLMul_28)
000280  480d              LDR      r0,|L27.696|
000282  4284              CMP      r4,r0
000284  d108              BNE      |L27.664|
;;;534      {
;;;535    		TK499_PLL_FACTOR = 28;
000286  201c              MOVS     r0,#0x1c
000288  4905              LDR      r1,|L27.672|
00028a  6008              STR      r0,[r1,#0]  ; TK499_PLL_FACTOR
;;;536        RCC_PLLDMDNConfig(RCC_PLLSource, 0x00000021, 0x00000000,0x00000000);//Frclk*32/2
00028c  2300              MOVS     r3,#0
00028e  461a              MOV      r2,r3
000290  2121              MOVS     r1,#0x21
000292  4630              MOV      r0,r6
000294  f7fffffe          BL       RCC_PLLDMDNConfig
                  |L27.664|
;;;537      }
;;;538    }
000298  bd70              POP      {r4-r6,pc}
;;;539    
                          ENDP

00029a  0000              DCW      0x0000
                  |L27.668|
                          DCD      0x40023808
                  |L27.672|
                          DCD      TK499_PLL_FACTOR
                  |L27.676|
                          DCD      0x005c0001
                  |L27.680|
                          DCD      0x00600002
                  |L27.684|
                          DCD      0x00680003
                  |L27.688|
                          DCD      0x006c0004
                  |L27.692|
                          DCD      0x00700005
                  |L27.696|
                          DCD      0x00780006

                          AREA ||i.RCC_PLLDMDNConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLDMDNConfig PROC
;;;344    */
;;;345    void RCC_PLLDMDNConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLDN,uint32_t RCC_PLLDP, uint32_t RCC_PLLDM)
000000  b570              PUSH     {r4-r6,lr}
;;;346    {
000002  4604              MOV      r4,r0
;;;347      uint32_t tmpreg0 = 0;
000004  2000              MOVS     r0,#0
;;;348      
;;;349      /* Check the parameters */
;;;350      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;351      assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
;;;352    	
;;;353    	if(RCC_PLLSource == 0)
000006  b914              CBNZ     r4,|L28.14|
;;;354    	{
;;;355    			tmpreg0 &= ~(1<<22);
000008  f4200080          BIC      r0,r0,#0x400000
00000c  e007              B        |L28.30|
                  |L28.14|
;;;356    	}
;;;357    	else
;;;358    	{
;;;359    			TK499_PLL_FACTOR |= 0x10000;
00000e  4d0b              LDR      r5,|L28.60|
000010  682d              LDR      r5,[r5,#0]  ; TK499_PLL_FACTOR
000012  f4453580          ORR      r5,r5,#0x10000
000016  4e09              LDR      r6,|L28.60|
000018  6035              STR      r5,[r6,#0]  ; TK499_PLL_FACTOR
;;;360    			tmpreg0 |= (1<<22);
00001a  f4400080          ORR      r0,r0,#0x400000
                  |L28.30|
;;;361    	}
;;;362    	
;;;363      RCC_PLLDN &= 0x7f;
00001e  f001017f          AND      r1,r1,#0x7f
;;;364    	RCC_PLLDP &= 0x3;
000022  f0020203          AND      r2,r2,#3
;;;365    	RCC_PLLDM &= 0xf;
000026  f003030f          AND      r3,r3,#0xf
;;;366      /* Set the PLL configuration bits */
;;;367      tmpreg0 |= (u32)((u32)(RCC_PLLDN<<6))|((u32)(RCC_PLLDP<<4))|((u32)RCC_PLLDM);
00002a  018d              LSLS     r5,r1,#6
00002c  ea451502          ORR      r5,r5,r2,LSL #4
000030  431d              ORRS     r5,r5,r3
000032  4328              ORRS     r0,r0,r5
;;;368      
;;;369      RCC->PLLCFGR = tmpreg0;
000034  4d02              LDR      r5,|L28.64|
000036  6028              STR      r0,[r5,#0]
;;;370    //	RCC->PLLCFGR = 0x4004d1;
;;;371    }
000038  bd70              POP      {r4-r6,pc}
;;;372    
                          ENDP

00003a  0000              DCW      0x0000
                  |L28.60|
                          DCD      TK499_PLL_FACTOR
                  |L28.64|
                          DCD      0x40023804

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;861    */
;;;862    void RCC_RTCCLKCmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L29.16|
;;;863    {
;;;864      /* Check the parameters */
;;;865      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;866      
;;;867      if (NewState != DISABLE)
;;;868      {
;;;869        RCC->BDCR |= 0x00008000;
000002  4907              LDR      r1,|L29.32|
000004  6809              LDR      r1,[r1,#0]
000006  f4414100          ORR      r1,r1,#0x8000
00000a  4a05              LDR      r2,|L29.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L29.28|
                  |L29.16|
;;;870      }
;;;871      else
;;;872      {
;;;873        RCC->BDCR &= 0xffff7fff;
000010  4903              LDR      r1,|L29.32|
000012  6809              LDR      r1,[r1,#0]
000014  f4214100          BIC      r1,r1,#0x8000
000018  4a01              LDR      r2,|L29.32|
00001a  6011              STR      r1,[r2,#0]
                  |L29.28|
;;;874      }
;;;875    }
00001c  4770              BX       lr
;;;876    void getSystemClock(u32 *sysclk)
                          ENDP

00001e  0000              DCW      0x0000
                  |L29.32|
                          DCD      0x40023830

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;845    */
;;;846    void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000000  4902              LDR      r1,|L30.12|
;;;847    {
;;;848      /* Check the parameters */
;;;849      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;850      /* Select the RTC clock source */
;;;851      RCC->BDCR |= RCC_RTCCLKSource;
000002  6809              LDR      r1,[r1,#0]
000004  4301              ORRS     r1,r1,r0
000006  4a01              LDR      r2,|L30.12|
000008  6011              STR      r1,[r2,#0]
;;;852    }
00000a  4770              BX       lr
;;;853    
                          ENDP

                  |L30.12|
                          DCD      0x40023830

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;571    */
;;;572    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000000  2100              MOVS     r1,#0
;;;573    {
;;;574      uint32_t tmpreg = 0;
;;;575      /* Check the parameters */
;;;576      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;577      tmpreg = RCC->CFGR;
000002  4a12              LDR      r2,|L31.76|
000004  6811              LDR      r1,[r2,#0]
;;;578      /* Clear SW[1:0] bits */
;;;579      tmpreg &= CFGR_SW_Mask;
000006  f0210103          BIC      r1,r1,#3
;;;580      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;581      tmpreg |= RCC_SYSCLKSource;
00000a  4301              ORRS     r1,r1,r0
;;;582      /* Store the new value */
;;;583      RCC->CFGR = tmpreg;
00000c  6011              STR      r1,[r2,#0]
;;;584    	if(RCC_SYSCLKSource == RCC_SYSCLKSource_PLLCLK)
00000e  2802              CMP      r0,#2
000010  d112              BNE      |L31.56|
;;;585    	{
;;;586    		if(TK499_PLL_FACTOR&0x10000)//hse as pll src
000012  4a0f              LDR      r2,|L31.80|
000014  6812              LDR      r2,[r2,#0]  ; TK499_PLL_FACTOR
000016  f4023280          AND      r2,r2,#0x10000
00001a  b132              CBZ      r2,|L31.42|
;;;587    		{
;;;588    				TK499_SYS_CLK = (TK499_PLL_FACTOR&0xff)*HSE_VALUE;
00001c  4a0c              LDR      r2,|L31.80|
00001e  7812              LDRB     r2,[r2,#0]  ; TK499_PLL_FACTOR
000020  4b0c              LDR      r3,|L31.84|
000022  435a              MULS     r2,r3,r2
000024  4b0c              LDR      r3,|L31.88|
000026  601a              STR      r2,[r3,#0]  ; TK499_SYS_CLK
000028  e00f              B        |L31.74|
                  |L31.42|
;;;589    		}
;;;590    		else
;;;591    		{
;;;592    				TK499_SYS_CLK = (TK499_PLL_FACTOR&0xff)*HSI_Value_Pll_ON;
00002a  4a09              LDR      r2,|L31.80|
00002c  7812              LDRB     r2,[r2,#0]  ; TK499_PLL_FACTOR
00002e  4b0b              LDR      r3,|L31.92|
000030  435a              MULS     r2,r3,r2
000032  4b09              LDR      r3,|L31.88|
000034  601a              STR      r2,[r3,#0]  ; TK499_SYS_CLK
000036  e008              B        |L31.74|
                  |L31.56|
;;;593    		}
;;;594    	}
;;;595    	else if(RCC_SYSCLKSource == RCC_SYSCLKSource_HSE)
000038  2801              CMP      r0,#1
00003a  d103              BNE      |L31.68|
;;;596    	{
;;;597    		TK499_SYS_CLK = HSE_VALUE;
00003c  4a05              LDR      r2,|L31.84|
00003e  4b06              LDR      r3,|L31.88|
000040  601a              STR      r2,[r3,#0]  ; TK499_SYS_CLK
000042  e002              B        |L31.74|
                  |L31.68|
;;;598    	}
;;;599    	else
;;;600    	{
;;;601    		TK499_SYS_CLK = HSI_Value_Pll_OFF;
000044  4a03              LDR      r2,|L31.84|
000046  4b04              LDR      r3,|L31.88|
000048  601a              STR      r2,[r3,#0]  ; TK499_SYS_CLK
                  |L31.74|
;;;602    	}
;;;603    }
00004a  4770              BX       lr
;;;604    
                          ENDP

                  |L31.76|
                          DCD      0x40023808
                  |L31.80|
                          DCD      TK499_PLL_FACTOR
                  |L31.84|
                          DCD      0x007a1200
                  |L31.88|
                          DCD      TK499_SYS_CLK
                  |L31.92|
                          DCD      0x00b71b00

                          AREA ||i.RCC_USBCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_USBCLKConfig PROC
;;;742    */
;;;743    void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
000000  4902              LDR      r1,|L32.12|
;;;744    {
;;;745      /* Check the parameters */
;;;746      assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
;;;747      RCC->CFGR |= RCC_USBCLKSource;
000002  6809              LDR      r1,[r1,#0]
000004  4301              ORRS     r1,r1,r0
000006  4a01              LDR      r2,|L32.12|
000008  6011              STR      r1,[r2,#0]
;;;748    }
00000a  4770              BX       lr
;;;749    
                          ENDP

                  |L32.12|
                          DCD      0x40023808

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=1

                  RCC_WaitForHSEStartUp PROC
;;;261    */
;;;262    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b538              PUSH     {r3-r5,lr}
;;;263    {
;;;264      __IO uint32_t StartUpCounter = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;265      ErrorStatus status = ERROR;
000006  2400              MOVS     r4,#0
;;;266      FlagStatus HSEStatus = RESET;
000008  2500              MOVS     r5,#0
;;;267      
;;;268      /* Wait till HSE is ready and if Time out is reached exit */
;;;269      do
00000a  bf00              NOP      
                  |L33.12|
;;;270      {
;;;271        HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
00000c  2031              MOVS     r0,#0x31
00000e  f7fffffe          BL       RCC_GetFlagStatus
000012  4605              MOV      r5,r0
;;;272        StartUpCounter++;  
000014  9800              LDR      r0,[sp,#0]
000016  1c40              ADDS     r0,r0,#1
000018  9000              STR      r0,[sp,#0]
;;;273      } while((HSEStatus == RESET) && (StartUpCounter != HSEStartUp_TimeOut));
00001a  b91d              CBNZ     r5,|L33.36|
00001c  9800              LDR      r0,[sp,#0]
00001e  f5b06fa0          CMP      r0,#0x500
000022  d1f3              BNE      |L33.12|
                  |L33.36|
;;;274      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
000024  2031              MOVS     r0,#0x31
000026  f7fffffe          BL       RCC_GetFlagStatus
00002a  b108              CBZ      r0,|L33.48|
;;;275      {
;;;276        status = SUCCESS;
00002c  2401              MOVS     r4,#1
00002e  e000              B        |L33.50|
                  |L33.48|
;;;277      }
;;;278      else
;;;279      {
;;;280        status = ERROR;
000030  2400              MOVS     r4,#0
                  |L33.50|
;;;281      }  
;;;282      return (status);
000032  4620              MOV      r0,r4
;;;283    }
000034  bd38              POP      {r3-r5,pc}
;;;284    
                          ENDP


                          AREA ||i.SystemClk_HSEInit||, CODE, READONLY, ALIGN=1

                  SystemClk_HSEInit PROC
;;;174    */
;;;175    void SystemClk_HSEInit(uint32_t PLL_DN)
000000  b510              PUSH     {r4,lr}
;;;176    {	
000002  4604              MOV      r4,r0
;;;177    	RCC_DeInit();
000004  f7fffffe          BL       RCC_DeInit
;;;178    	//HSE on
;;;179    	//CRBIT16HSEON1HSE
;;;180    	RCC_HSEConfig(RCC_HSE_ON);
000008  f44f3080          MOV      r0,#0x10000
00000c  f7fffffe          BL       RCC_HSEConfig
;;;181    	
;;;182    	while(1)
000010  e003              B        |L34.26|
                  |L34.18|
;;;183    	{
;;;184    		if(RCC_WaitForHSEStartUp()!=0)
000012  f7fffffe          BL       RCC_WaitForHSEStartUp
000016  b100              CBZ      r0,|L34.26|
;;;185    		{
;;;186    			break;
000018  e000              B        |L34.28|
                  |L34.26|
00001a  e7fa              B        |L34.18|
                  |L34.28|
00001c  bf00              NOP      
;;;187    		}
;;;188    	}
;;;189    	RCC_PLLCmd(DISABLE);
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       RCC_PLLCmd
;;;190    	RCC_PLLConfig(RCC_PLLSource_HSE_Div1,PLL_DN);
000024  4621              MOV      r1,r4
000026  f44f0080          MOV      r0,#0x400000
00002a  f7fffffe          BL       RCC_PLLConfig
;;;191    	RCC_PLLCmd(ENABLE);
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       RCC_PLLCmd
;;;192    	RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);//
000034  2002              MOVS     r0,#2
000036  f7fffffe          BL       RCC_SYSCLKConfig
;;;193    }
00003a  bd10              POP      {r4,pc}
;;;194    /**
                          ENDP


                          AREA ||i.getSystemClock||, CODE, READONLY, ALIGN=2

                  getSystemClock PROC
;;;875    }
;;;876    void getSystemClock(u32 *sysclk)
000000  b5f0              PUSH     {r4-r7,lr}
;;;877    {
000002  4601              MOV      r1,r0
;;;878      u32 tempreg0 = RCC->CFGR; 
000004  4e22              LDR      r6,|L35.144|
000006  6835              LDR      r5,[r6,#0]
;;;879      u32 tempreg1;
;;;880      u8  dn,dp,dm;
;;;881      if((tempreg0 & 0xC) == 0x00)
000008  f005060c          AND      r6,r5,#0xc
00000c  b916              CBNZ     r6,|L35.20|
;;;882      {
;;;883        *sysclk = 8000000;
00000e  4e21              LDR      r6,|L35.148|
000010  600e              STR      r6,[r1,#0]
000012  e03c              B        |L35.142|
                  |L35.20|
;;;884      }
;;;885      else if((tempreg0 & 0xC) ==0x04)
000014  f005060c          AND      r6,r5,#0xc
000018  2e04              CMP      r6,#4
00001a  d102              BNE      |L35.34|
;;;886      {
;;;887        *sysclk = 12000000;
00001c  4e1e              LDR      r6,|L35.152|
00001e  600e              STR      r6,[r1,#0]
000020  e035              B        |L35.142|
                  |L35.34|
;;;888      }
;;;889      else
;;;890      {
;;;891        tempreg1 = RCC->PLLCFGR;
000022  4e1b              LDR      r6,|L35.144|
000024  1f36              SUBS     r6,r6,#4
000026  6832              LDR      r2,[r6,#0]
;;;892        dn = (tempreg1 >> 6) & 0x7F;
000028  f3c21386          UBFX     r3,r2,#6,#7
;;;893        dn ++;
00002c  1c5b              ADDS     r3,r3,#1
;;;894        dp = (tempreg1 >> 4) & 0x3;
00002e  f3c21001          UBFX     r0,r2,#4,#2
;;;895        if(dp == 0)
000032  b908              CBNZ     r0,|L35.56|
;;;896          dp = 1;
000034  2001              MOVS     r0,#1
000036  e00a              B        |L35.78|
                  |L35.56|
;;;897        else if(dp == 1)
000038  2801              CMP      r0,#1
00003a  d101              BNE      |L35.64|
;;;898          dp = 2;
00003c  2002              MOVS     r0,#2
00003e  e006              B        |L35.78|
                  |L35.64|
;;;899        else if(dp == 2)
000040  2802              CMP      r0,#2
000042  d101              BNE      |L35.72|
;;;900          dp = 4;
000044  2004              MOVS     r0,#4
000046  e002              B        |L35.78|
                  |L35.72|
;;;901        else if(dp == 3)
000048  2803              CMP      r0,#3
00004a  d100              BNE      |L35.78|
;;;902          dp = 8;
00004c  2008              MOVS     r0,#8
                  |L35.78|
;;;903        dm = (tempreg1 >> 0) & 0xF;
00004e  f002040f          AND      r4,r2,#0xf
;;;904        dm++;
000052  1c64              ADDS     r4,r4,#1
;;;905        if(tempreg1 & (1 << 22))
000054  f4020680          AND      r6,r2,#0x400000
000058  b196              CBZ      r6,|L35.128|
;;;906        {
;;;907          if(tempreg0 & (1 << 16))
00005a  f4053680          AND      r6,r5,#0x10000
00005e  b13e              CBZ      r6,|L35.112|
;;;908            *sysclk = 6000000* dn/( dm * dp);
000060  4e0e              LDR      r6,|L35.156|
000062  435e              MULS     r6,r3,r6
000064  fb04f700          MUL      r7,r4,r0
000068  fb96f6f7          SDIV     r6,r6,r7
00006c  600e              STR      r6,[r1,#0]
00006e  e00e              B        |L35.142|
                  |L35.112|
;;;909          else
;;;910            *sysclk = 12000000* dn/( dm * dp);
000070  4e09              LDR      r6,|L35.152|
000072  435e              MULS     r6,r3,r6
000074  fb04f700          MUL      r7,r4,r0
000078  fb96f6f7          SDIV     r6,r6,r7
00007c  600e              STR      r6,[r1,#0]
00007e  e006              B        |L35.142|
                  |L35.128|
;;;911        }
;;;912        else
;;;913        {
;;;914          *sysclk = 12000000* dn/( dm * dp);
000080  4e05              LDR      r6,|L35.152|
000082  435e              MULS     r6,r3,r6
000084  fb04f700          MUL      r7,r4,r0
000088  fb96f6f7          SDIV     r6,r6,r7
00008c  600e              STR      r6,[r1,#0]
                  |L35.142|
;;;915        }
;;;916      }
;;;917    }
00008e  bdf0              POP      {r4-r7,pc}
;;;918    
                          ENDP

                  |L35.144|
                          DCD      0x40023808
                  |L35.148|
                          DCD      0x007a1200
                  |L35.152|
                          DCD      0x00b71b00
                  |L35.156|
                          DCD      0x005b8d80

                          AREA ||.data||, DATA, ALIGN=2

                  TK499_SYS_CLK
                          DCD      0x02dc6c00
                  TK499_PLL_FACTOR
                          DCD      0x00000004
                  APBAHBPrescTable
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  01020304          DCB      0x01,0x02,0x03,0x04
000010  01020304          DCB      0x01,0x02,0x03,0x04
000014  06070809          DCB      0x06,0x07,0x08,0x09
                  ADCPrescTable
000018  02040608          DCB      0x02,0x04,0x06,0x08

;*** Start embedded assembler ***

#line 1 "..\\Hal_lib\\src\\HAL_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_HAL_rcc_c_9f08a566____REV16|
#line 388 "..\\CMSIS_and_startup\\CMSIS\\cmsis_armcc.h"
|__asm___9_HAL_rcc_c_9f08a566____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_HAL_rcc_c_9f08a566____REVSH|
#line 402
|__asm___9_HAL_rcc_c_9f08a566____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_HAL_rcc_c_9f08a566____RRX|
#line 587
|__asm___9_HAL_rcc_c_9f08a566____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
