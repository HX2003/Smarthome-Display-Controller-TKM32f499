; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\sys.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\sys.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CMSIS_and_startup -I..\CMSIS_and_startup\CMSIS -I.\bsp -I..\Hal_lib\inc -I.\bsp\LCD -I.\bsp\LED -I.\bsp\SPI -I.\bsp\sys -I.\bsp\UART -I.\bsp\Timer -I.\bsp\exit -I.\bsp\touchpad -I.\RTE\_TK499_LTDC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.5.1\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=527 -DARMCM4_FP --omf_browse=.\obj\sys.crf ..\CMSIS_and_startup\sys.c]
                          THUMB

                          AREA ||i.AI_Responder_disable||, CODE, READONLY, ALIGN=2

                  AI_Responder_disable PROC
;;;28     }
;;;29     void  AI_Responder_disable(void)
000000  4803              LDR      r0,|L1.16|
;;;30     {
;;;31         AI_Responder->CCR &= ~1;
000002  6800              LDR      r0,[r0,#0]
000004  f0200001          BIC      r0,r0,#1
000008  4901              LDR      r1,|L1.16|
00000a  6008              STR      r0,[r1,#0]
;;;32     }
00000c  4770              BX       lr
;;;33     
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0x40017400

                          AREA ||i.AI_Responder_enable||, CODE, READONLY, ALIGN=2

                  AI_Responder_enable PROC
;;;19     
;;;20     void  AI_Responder_enable(void)
000000  480d              LDR      r0,|L2.56|
;;;21     {
;;;22       AI_Responder->ADDR1= 0x70807040;
000002  490e              LDR      r1,|L2.60|
000004  6008              STR      r0,[r1,#0]
;;;23     //	AI_Responder->ADDR0 = 0x70027080;
;;;24       AI_Responder->ADDR1 = 0;
000006  2000              MOVS     r0,#0
000008  6008              STR      r0,[r1,#0]
;;;25       AI_Responder->CCR &= ~(0x3<<3);
00000a  480c              LDR      r0,|L2.60|
00000c  3824              SUBS     r0,r0,#0x24
00000e  6800              LDR      r0,[r0,#0]
000010  f0200018          BIC      r0,r0,#0x18
000014  4909              LDR      r1,|L2.60|
000016  3924              SUBS     r1,r1,#0x24
000018  6008              STR      r0,[r1,#0]
;;;26       AI_Responder->CCR |= 1;
00001a  4608              MOV      r0,r1
00001c  6800              LDR      r0,[r0,#0]
00001e  f0400001          ORR      r0,r0,#1
000022  6008              STR      r0,[r1,#0]
;;;27       while((AI_Responder->SR & 0x3) != 2);
000024  bf00              NOP      
                  |L2.38|
000026  4805              LDR      r0,|L2.60|
000028  3820              SUBS     r0,r0,#0x20
00002a  6800              LDR      r0,[r0,#0]
00002c  f0000003          AND      r0,r0,#3
000030  2802              CMP      r0,#2
000032  d1f8              BNE      |L2.38|
;;;28     }
000034  4770              BX       lr
;;;29     void  AI_Responder_disable(void)
                          ENDP

000036  0000              DCW      0x0000
                  |L2.56|
                          DCD      0x70807040
                  |L2.60|
                          DCD      0x40017424

                          AREA ||i.Ex_NVIC_Config||, CODE, READONLY, ALIGN=2

                  Ex_NVIC_Config PROC
;;;42     //该函数会自动开启对应中断,以及屏蔽线   	    
;;;43     void Ex_NVIC_Config(u8 GPIOx,u8 BITx,u8 TRIM) 
000000  b5f0              PUSH     {r4-r7,lr}
;;;44     { 
000002  4603              MOV      r3,r0
;;;45     	u8 EXTOFFSET=(BITx%4)*4;  
000004  4608              MOV      r0,r1
000006  17cd              ASRS     r5,r1,#31
000008  eb017595          ADD      r5,r1,r5,LSR #30
00000c  10ad              ASRS     r5,r5,#2
00000e  eba10585          SUB      r5,r1,r5,LSL #2
000012  06ad              LSLS     r5,r5,#26
000014  0e2c              LSRS     r4,r5,#24
;;;46     	RCC->APB2ENR|=1<<14;  						//使能SYSCFG时钟  
000016  4824              LDR      r0,|L3.168|
000018  6800              LDR      r0,[r0,#0]
00001a  f4404080          ORR      r0,r0,#0x4000
00001e  4d22              LDR      r5,|L3.168|
000020  6028              STR      r0,[r5,#0]
;;;47     	SYSCFG->EXTICR[BITx/4]&=~(0x000F<<EXTOFFSET);//清除原来设置！！！
000022  17cd              ASRS     r5,r1,#31
000024  eb017595          ADD      r5,r1,r5,LSR #30
000028  10ae              ASRS     r6,r5,#2
00002a  4d20              LDR      r5,|L3.172|
00002c  f8555026          LDR      r5,[r5,r6,LSL #2]
000030  260f              MOVS     r6,#0xf
000032  40a6              LSLS     r6,r6,r4
000034  43b5              BICS     r5,r5,r6
000036  4608              MOV      r0,r1
000038  17ce              ASRS     r6,r1,#31
00003a  eb017696          ADD      r6,r1,r6,LSR #30
00003e  10b7              ASRS     r7,r6,#2
000040  4e1a              LDR      r6,|L3.172|
000042  f8465027          STR      r5,[r6,r7,LSL #2]
;;;48     	SYSCFG->EXTICR[BITx/4]|=GPIOx<<EXTOFFSET;	//EXTI.BITx映射到GPIOx.BITx 
000046  17cd              ASRS     r5,r1,#31
000048  eb017595          ADD      r5,r1,r5,LSR #30
00004c  10ae              ASRS     r6,r5,#2
00004e  4d17              LDR      r5,|L3.172|
000050  f8555026          LDR      r5,[r5,r6,LSL #2]
000054  fa03f604          LSL      r6,r3,r4
000058  4335              ORRS     r5,r5,r6
00005a  17ce              ASRS     r6,r1,#31
00005c  eb017696          ADD      r6,r1,r6,LSR #30
000060  10b7              ASRS     r7,r6,#2
000062  4e12              LDR      r6,|L3.172|
000064  f8465027          STR      r5,[r6,r7,LSL #2]
;;;49     	//自动设置
;;;50     	EXTI->IMR|=1<<BITx;					//开启line BITx上的中断(如果要禁止中断，则反操作即可)
000068  4811              LDR      r0,|L3.176|
00006a  6800              LDR      r0,[r0,#0]
00006c  2501              MOVS     r5,#1
00006e  408d              LSLS     r5,r5,r1
000070  4328              ORRS     r0,r0,r5
000072  4d0f              LDR      r5,|L3.176|
000074  6028              STR      r0,[r5,#0]
;;;51     	if(TRIM&0x01)EXTI->FTSR|=1<<BITx;	//line BITx上事件下降沿触发
000076  f0020001          AND      r0,r2,#1
00007a  b140              CBZ      r0,|L3.142|
00007c  480c              LDR      r0,|L3.176|
00007e  300c              ADDS     r0,r0,#0xc
000080  6800              LDR      r0,[r0,#0]
000082  2501              MOVS     r5,#1
000084  408d              LSLS     r5,r5,r1
000086  4328              ORRS     r0,r0,r5
000088  4d09              LDR      r5,|L3.176|
00008a  350c              ADDS     r5,r5,#0xc
00008c  6028              STR      r0,[r5,#0]
                  |L3.142|
;;;52     	if(TRIM&0x02)EXTI->RTSR|=1<<BITx;	//line BITx上事件上升降沿触发
00008e  f0020002          AND      r0,r2,#2
000092  b140              CBZ      r0,|L3.166|
000094  4806              LDR      r0,|L3.176|
000096  3008              ADDS     r0,r0,#8
000098  6800              LDR      r0,[r0,#0]
00009a  2501              MOVS     r5,#1
00009c  408d              LSLS     r5,r5,r1
00009e  4328              ORRS     r0,r0,r5
0000a0  4d03              LDR      r5,|L3.176|
0000a2  3508              ADDS     r5,r5,#8
0000a4  6028              STR      r0,[r5,#0]
                  |L3.166|
;;;53     } 	
0000a6  bdf0              POP      {r4-r7,pc}
;;;54     
                          ENDP

                  |L3.168|
                          DCD      0x4002382c
                  |L3.172|
                          DCD      0x40013804
                  |L3.176|
                          DCD      0x40013c00

                          AREA ||i.INTX_DISABLE||, CODE, READONLY, ALIGN=1

                  INTX_DISABLE PROC
;;;62     //关闭所有中断(但是不包括fault和NMI中断)
;;;63     void INTX_DISABLE(void)
000000  b672              CPSID    i
;;;64     {
;;;65     	__ASM volatile("cpsid i");
;;;66     }
000002  4770              BX       lr
;;;67     //开启所有中断
                          ENDP


                          AREA ||i.INTX_ENABLE||, CODE, READONLY, ALIGN=1

                  INTX_ENABLE PROC
;;;67     //开启所有中断
;;;68     void INTX_ENABLE(void)
000000  b662              CPSIE    i
;;;69     {
;;;70     	__ASM volatile("cpsie i");		  
;;;71     }
000002  4770              BX       lr
;;;72     //设置栈顶地址  __set_MSP(0x70002000);
                          ENDP


                          AREA ||i.RemapVtorTable||, CODE, READONLY, ALIGN=2

                  RemapVtorTable PROC
;;;3      
;;;4      void  RemapVtorTable(void)
000000  b510              PUSH     {r4,lr}
;;;5      { 
;;;6      	int i;
;;;7          RCC->AHB1ENR |= 1<<13;//bkp clk,enable sram
000002  4914              LDR      r1,|L6.84|
000004  6809              LDR      r1,[r1,#0]
000006  f4415100          ORR      r1,r1,#0x2000
00000a  4a12              LDR      r2,|L6.84|
00000c  6011              STR      r1,[r2,#0]
;;;8      	//关ROM区中断
;;;9          for(i = 0;i<90;i++)
00000e  2000              MOVS     r0,#0
000010  e00a              B        |L6.40|
                  |L6.18|
;;;10         { 
;;;11             NVIC_DisableIRQ((IRQn_Type)i); 
000012  b241              SXTB     r1,r0
000014  f001031f          AND      r3,r1,#0x1f
000018  2201              MOVS     r2,#1
00001a  409a              LSLS     r2,r2,r3
00001c  4b0e              LDR      r3,|L6.88|
00001e  094c              LSRS     r4,r1,#5
000020  f8432024          STR      r2,[r3,r4,LSL #2]
000024  bf00              NOP      
000026  1c40              ADDS     r0,r0,#1              ;9
                  |L6.40|
000028  285a              CMP      r0,#0x5a              ;9
00002a  dbf2              BLT      |L6.18|
;;;12         }
;;;13     	SCB->VTOR = 0;
00002c  2100              MOVS     r1,#0
00002e  4a0b              LDR      r2,|L6.92|
000030  6011              STR      r1,[r2,#0]
;;;14     	SCB->VTOR |= 0x1<<29;
000032  4611              MOV      r1,r2
000034  6809              LDR      r1,[r1,#0]
000036  f0415100          ORR      r1,r1,#0x20000000
00003a  6011              STR      r1,[r2,#0]
;;;15     	for(i = 0;i < 512;i+=4)
00003c  2000              MOVS     r0,#0
00003e  e004              B        |L6.74|
                  |L6.64|
;;;16     	*(u32*)(T_SRAM_BASE + i) = *(u32*)(T_SDRAM_BASE+i);
000040  4907              LDR      r1,|L6.96|
000042  5842              LDR      r2,[r0,r1]
000044  0309              LSLS     r1,r1,#12
000046  500a              STR      r2,[r1,r0]
000048  1d00              ADDS     r0,r0,#4              ;15
                  |L6.74|
00004a  f5b07f00          CMP      r0,#0x200             ;15
00004e  dbf7              BLT      |L6.64|
;;;17     
;;;18     }
000050  bd10              POP      {r4,pc}
;;;19     
                          ENDP

000052  0000              DCW      0x0000
                  |L6.84|
                          DCD      0x40023820
                  |L6.88|
                          DCD      0xe000e180
                  |L6.92|
                          DCD      0xe000ed08
                  |L6.96|
                          DCD      0x70020000

                          AREA ||i.Sys_Soft_Reset||, CODE, READONLY, ALIGN=2

                  Sys_Soft_Reset PROC
;;;84     //系统软复位   
;;;85     void Sys_Soft_Reset(void)
000000  4801              LDR      r0,|L7.8|
;;;86     {   
;;;87     	SCB->AIRCR =0X05FA0000|(u32)0x04;	  
000002  4902              LDR      r1,|L7.12|
000004  6008              STR      r0,[r1,#0]
;;;88     } 		 
000006  4770              BX       lr
;;;89        
                          ENDP

                  |L7.8|
                          DCD      0x05fa0004
                  |L7.12|
                          DCD      0xe000ed0c

                          AREA ||i.Sys_Standby||, CODE, READONLY, ALIGN=2

                  Sys_Standby PROC
;;;74     //进入待机模式	  
;;;75     void Sys_Standby(void)
000000  b500              PUSH     {lr}
;;;76     { 
;;;77     	SCB->SCR|=1<<2;		//使能SLEEPDEEP位 (SYS->CTRL)	   
000002  480f              LDR      r0,|L8.64|
000004  6800              LDR      r0,[r0,#0]
000006  f0400004          ORR      r0,r0,#4
00000a  490d              LDR      r1,|L8.64|
00000c  6008              STR      r0,[r1,#0]
;;;78     	RCC->APB1ENR|=1<<28;//使能电源时钟 
00000e  480d              LDR      r0,|L8.68|
000010  6800              LDR      r0,[r0,#0]
000012  f0405080          ORR      r0,r0,#0x10000000
000016  490b              LDR      r1,|L8.68|
000018  6008              STR      r0,[r1,#0]
;;;79     	PWR->CSR|=1<<8;     //设置WKUP用于唤醒
00001a  480b              LDR      r0,|L8.72|
00001c  6840              LDR      r0,[r0,#4]
00001e  f4407080          ORR      r0,r0,#0x100
000022  4909              LDR      r1,|L8.72|
000024  6048              STR      r0,[r1,#4]
;;;80     	PWR->CR|=1<<2;      //清除Wake-up 标志
000026  4608              MOV      r0,r1
000028  6800              LDR      r0,[r0,#0]
00002a  f0400004          ORR      r0,r0,#4
00002e  6008              STR      r0,[r1,#0]
;;;81     	PWR->CR|=1<<1;      //PDDS置位   	
000030  4608              MOV      r0,r1
000032  6800              LDR      r0,[r0,#0]
000034  f0400002          ORR      r0,r0,#2
000038  6008              STR      r0,[r1,#0]
;;;82     	WFI_SET();			//执行WFI指令,进入待机模式		 
00003a  f7fffffe          BL       WFI_SET
;;;83     }	     
00003e  bd00              POP      {pc}
;;;84     //系统软复位   
                          ENDP

                  |L8.64|
                          DCD      0xe000ed10
                  |L8.68|
                          DCD      0x40023828
                  |L8.72|
                          DCD      0x40007000

                          AREA ||i.TK499_NVIC_Init||, CODE, READONLY, ALIGN=2

                  TK499_NVIC_Init PROC
;;;103    //NVIC_SubPriority和NVIC_PreemptionPriority的原则是,数值越小,越优先	   
;;;104    void TK499_NVIC_Init(u8 NVIC_PreemptionPriority,u8 NVIC_SubPriority,u8 NVIC_Channel,u8 NVIC_Group)	 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;105    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;106    	u32 temp;	  
;;;107    	NVIC_SetPriorityGrouping(NVIC_Group);//设置分组
000008  bf00              NOP      
00000a  f0030107          AND      r1,r3,#7
00000e  4f21              LDR      r7,|L9.148|
000010  6838              LDR      r0,[r7,#0]
000012  f64f07ff          MOV      r7,#0xf8ff
000016  4038              ANDS     r0,r0,r7
000018  4f1f              LDR      r7,|L9.152|
00001a  4307              ORRS     r7,r7,r0
00001c  ea472001          ORR      r0,r7,r1,LSL #8
000020  4f1c              LDR      r7,|L9.148|
000022  6038              STR      r0,[r7,#0]
000024  bf00              NOP      
;;;108    	temp=NVIC_PreemptionPriority<<(4-NVIC_Group);	  
000026  f1c30004          RSB      r0,r3,#4
00002a  fa05f400          LSL      r4,r5,r0
;;;109    	temp|=NVIC_SubPriority&(0x0f>>NVIC_Group);
00002e  200f              MOVS     r0,#0xf
000030  4118              ASRS     r0,r0,r3
000032  4030              ANDS     r0,r0,r6
000034  4304              ORRS     r4,r4,r0
;;;110    	temp&=0xf;								//取低四位
000036  f004040f          AND      r4,r4,#0xf
;;;111    	NVIC->ISER[NVIC_Channel/32]|=1<<NVIC_Channel%32;//使能中断位(要清除的话,设置ICER对应位为1即可)
00003a  17d7              ASRS     r7,r2,#31
00003c  eb0267d7          ADD      r7,r2,r7,LSR #27
000040  117f              ASRS     r7,r7,#5
000042  00bf              LSLS     r7,r7,#2
000044  f10727e0          ADD      r7,r7,#0xe000e000
000048  f8d77100          LDR      r7,[r7,#0x100]
00004c  4611              MOV      r1,r2
00004e  ea4f7ce2          ASR      r12,r2,#31
000052  eb026cdc          ADD      r12,r2,r12,LSR #27
000056  ea4f1c6c          ASR      r12,r12,#5
00005a  eba2184c          SUB      r8,r2,r12,LSL #5
00005e  f04f0c01          MOV      r12,#1
000062  fa0cfc08          LSL      r12,r12,r8
000066  ea47070c          ORR      r7,r7,r12
00006a  4610              MOV      r0,r2
00006c  ea4f7ce2          ASR      r12,r2,#31
000070  eb026cdc          ADD      r12,r2,r12,LSR #27
000074  ea4f1c6c          ASR      r12,r12,#5
000078  ea4f0c8c          LSL      r12,r12,#2
00007c  f10c2ce0          ADD      r12,r12,#0xe000e000
000080  f8cc7100          STR      r7,[r12,#0x100]
;;;112    	NVIC->IP[NVIC_Channel]|=temp<<4;				//设置响应优先级和抢断优先级   	    	  				   
000084  4805              LDR      r0,|L9.156|
000086  5c80              LDRB     r0,[r0,r2]
000088  ea401004          ORR      r0,r0,r4,LSL #4
00008c  4903              LDR      r1,|L9.156|
00008e  5488              STRB     r0,[r1,r2]
;;;113    }
000090  e8bd81f0          POP      {r4-r8,pc}
;;;114    
                          ENDP

                  |L9.148|
                          DCD      0xe000ed0c
                  |L9.152|
                          DCD      0x05fa0000
                  |L9.156|
                          DCD      0xe000e400

                          AREA ||i.TK80_IRQHandler||, CODE, READONLY, ALIGN=1

                  TK80_IRQHandler PROC
;;;114    
;;;115    void TK80_IRQHandler(void)
000000  f04f40c0          MOV      r0,#0x60000000
;;;116    {
;;;117        if(TK80->SR & 0x1)
000004  68c0              LDR      r0,[r0,#0xc]
;;;118        {
;;;119        
;;;120        }
;;;121        if(TK80->SR & 0x2)
000006  f04f40c0          MOV      r0,#0x60000000
00000a  68c0              LDR      r0,[r0,#0xc]
;;;122        {
;;;123        
;;;124        }
;;;125        if(TK80->SR & 0x4)
00000c  f04f40c0          MOV      r0,#0x60000000
000010  68c0              LDR      r0,[r0,#0xc]
;;;126        {
;;;127        
;;;128        }
;;;129        if(TK80->SR & 0x8)
000012  f04f40c0          MOV      r0,#0x60000000
000016  68c0              LDR      r0,[r0,#0xc]
;;;130        {
;;;131        
;;;132        }
;;;133        TK80->SR |= 0;
000018  f04f40c0          MOV      r0,#0x60000000
00001c  68c0              LDR      r0,[r0,#0xc]
00001e  f04f41c0          MOV      r1,#0x60000000
000022  60c8              STR      r0,[r1,#0xc]
;;;134    }
000024  4770              BX       lr
;;;135    
                          ENDP


                          AREA ||i.WFI_SET||, CODE, READONLY, ALIGN=1

                  WFI_SET PROC
;;;57     //采用如下方法实现执行汇编指令WFI  
;;;58     void WFI_SET(void)
000000  bf30              WFI      
;;;59     {
;;;60     	__ASM volatile("wfi");		  
;;;61     }
000002  4770              BX       lr
;;;62     //关闭所有中断(但是不包括fault和NMI中断)
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\CMSIS_and_startup\\sys.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_sys_c_3660de33____REV16|
#line 388 "..\\CMSIS_and_startup\\CMSIS\\cmsis_armcc.h"
|__asm___5_sys_c_3660de33____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_sys_c_3660de33____REVSH|
#line 402
|__asm___5_sys_c_3660de33____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_sys_c_3660de33____RRX|
#line 587
|__asm___5_sys_c_3660de33____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
