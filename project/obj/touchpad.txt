; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\touchpad.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\touchpad.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CMSIS_and_startup -I..\CMSIS_and_startup\CMSIS -I.\bsp -I..\Hal_lib\inc -I.\bsp\LCD -I.\bsp\LED -I.\bsp\SPI -I.\bsp\sys -I.\bsp\UART -I.\bsp\Timer -I.\bsp\exit -I.\bsp\touchpad -I.\RTE\_TK499_LTDC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.5.1\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=527 -DARMCM4_FP --omf_browse=.\obj\touchpad.crf bsp\touchpad\touchpad.c]
                          THUMB

                          AREA ||i.ADC_Config||, CODE, READONLY, ALIGN=2

                  ADC_Config PROC
;;;137    
;;;138    void ADC_Config(void)//tgdiy 编写
000000  b510              PUSH     {r4,lr}
;;;139    {
;;;140    	volatile int i;
;;;141    		//RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);////
;;;142    	TK499_NVIC_Init(3,3,TOUCHPAD_IRQn,3);///抢占 1，子优先级 3，组 2	
000002  2303              MOVS     r3,#3
000004  2256              MOVS     r2,#0x56
000006  4619              MOV      r1,r3
000008  4618              MOV      r0,r3
00000a  f7fffffe          BL       TK499_NVIC_Init
;;;143    		RCC->APB2ENR |= 0x1<<25;  //打开ADC时钟，与touchpad共用时钟
00000e  4816              LDR      r0,|L1.104|
000010  6800              LDR      r0,[r0,#0]
000012  f0407000          ORR      r0,r0,#0x2000000
000016  4914              LDR      r1,|L1.104|
000018  6008              STR      r0,[r1,#0]
;;;144    	TOUCHPAD->TPCR |= 0x03; ///使能A/D触摸屏中断,使能A/D触摸3
00001a  4814              LDR      r0,|L1.108|
00001c  6800              LDR      r0,[r0,#0]
00001e  f0400003          ORR      r0,r0,#3
000022  4912              LDR      r1,|L1.108|
000024  6008              STR      r0,[r1,#0]
;;;145    	//TOUCHPAD->TPFR = 0x2FFFFFF;      //滤波27:24次数，23:13Y阀值，12:0X阀值
;;;146    
;;;147    	TOUCHPAD->ADCHS = 0x03;      //通道使能 //03= 0011,设置管脚
000026  2003              MOVS     r0,#3
000028  4910              LDR      r1,|L1.108|
00002a  3944              SUBS     r1,r1,#0x44
00002c  6008              STR      r0,[r1,#0]
;;;148    	TOUCHPAD->TPCSR = 0x01;      //A/D触摸通道使能7:4Y通道,3:0X通道,(0000//AIN1置TPYDR，0001//AIN0置TPXDR,只能这样)想换别的管脚，却只能设置0100//AIN3置TPXDR。)怎么是03，01？
00002e  2001              MOVS     r0,#1
000030  490e              LDR      r1,|L1.108|
000032  3108              ADDS     r1,r1,#8
000034  6008              STR      r0,[r1,#0]
;;;149    	                             //最后测试出官方默认的设置，使用rY轴高对应屏幕0点，X轴低对应屏幕0点。
;;;150    								 //ewin列程是c=1100，23是10=3脚和11=2脚，难道只能c，23或者03，01？
;;;151    
;;;152    
;;;153    	TOUCHPAD->ADCFG =0x3E1E70;      //16分频   AD比较器禁用
000036  480e              LDR      r0,|L1.112|
000038  490c              LDR      r1,|L1.108|
00003a  394c              SUBS     r1,r1,#0x4c
00003c  6008              STR      r0,[r1,#0]
;;;154    	TOUCHPAD->ADCR = 0x400;      //0x200单周期模式;0x400连续扫描模式
00003e  1508              ASRS     r0,r1,#20
000040  1d09              ADDS     r1,r1,#4
000042  6008              STR      r0,[r1,#0]
;;;155    	TOUCHPAD->ADCHS = 0x33;      //通道使能 4，5//03= 0011,设置管脚
000044  2033              MOVS     r0,#0x33
000046  1d09              ADDS     r1,r1,#4
000048  6008              STR      r0,[r1,#0]
;;;156    	TOUCHPAD->ADCFG |= 0x1;      //ADC使能
00004a  4808              LDR      r0,|L1.108|
00004c  384c              SUBS     r0,r0,#0x4c
00004e  6800              LDR      r0,[r0,#0]
000050  f0400001          ORR      r0,r0,#1
000054  4905              LDR      r1,|L1.108|
000056  394c              SUBS     r1,r1,#0x4c
000058  6008              STR      r0,[r1,#0]
;;;157    	TOUCHPAD->ADCR |= 0x1<<8;  //A/D转换开始 (ADC start)
00005a  1d08              ADDS     r0,r1,#4
00005c  6800              LDR      r0,[r0,#0]
00005e  f4407080          ORR      r0,r0,#0x100
000062  1d09              ADDS     r1,r1,#4
000064  6008              STR      r0,[r1,#0]
;;;158    	
;;;159      // TOUCHPAD->TPCR |= 0x03; ///使能A/D触摸屏中断,使能A/D触摸3
;;;160    	//TOUCHPAD->ADCR |=0x1;        //使能ADC中断
;;;161    }
000066  bd10              POP      {r4,pc}
;;;162    
                          ENDP

                  |L1.104|
                          DCD      0x4002382c
                  |L1.108|
                          DCD      0x40016450
                  |L1.112|
                          DCD      0x003e1e70

                          AREA ||i.GUI_TOUCH_X||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  GUI_TOUCH_X PROC
;;;204    }
;;;205     u16 GUI_TOUCH_X(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;206    {
;;;207    volatile u16 i,a;
;;;208    		SetGpio(0);//X+输出高,X-输出低,Y+测量,Y-悬空//03,01,ok
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       SetGpio
;;;209    		i=10000;while(--i);//延时32f429约50us,delay_ms(1);
000008  f2427010          MOV      r0,#0x2710
00000c  9001              STR      r0,[sp,#4]
00000e  bf00              NOP      
                  |L2.16|
000010  f8bd0004          LDRH     r0,[sp,#4]
000014  1e40              SUBS     r0,r0,#1
000016  b280              UXTH     r0,r0
000018  9001              STR      r0,[sp,#4]
00001a  2800              CMP      r0,#0
00001c  d1f8              BNE      |L2.16|
;;;210    		a = Get_Adc_Average(0,2);//a = ADC_Value_Y;//
00001e  2102              MOVS     r1,#2
000020  f7fffffe          BL       Get_Adc_Average
000024  9000              STR      r0,[sp,#0]
;;;211    		printf("GUI_TOUCH_X=%d  ",a);
000026  f8bd1000          LDRH     r1,[sp,#0]
00002a  a003              ADR      r0,|L2.56|
00002c  f7fffffe          BL       __2printf
;;;212    	  return a;
000030  f8bd0000          LDRH     r0,[sp,#0]
;;;213    }
000034  bd1c              POP      {r2-r4,pc}
;;;214     u16 GUI_TOUCH_Y(void)
                          ENDP

000036  0000              DCW      0x0000
                  |L2.56|
000038  4755495f          DCB      "GUI_TOUCH_X=%d  ",0
00003c  544f5543
000040  485f583d
000044  25642020
000048  00      
000049  00                DCB      0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||i.GUI_TOUCH_X_ActivateX||, CODE, READONLY, ALIGN=1

                  GUI_TOUCH_X_ActivateX PROC
;;;9      #if USE_RTP
;;;10     void GUI_TOUCH_X_ActivateX(void) {}
000000  4770              BX       lr
;;;11     void GUI_TOUCH_X_ActivateY(void) {}
                          ENDP


                          AREA ||i.GUI_TOUCH_X_ActivateY||, CODE, READONLY, ALIGN=1

                  GUI_TOUCH_X_ActivateY PROC
;;;10     void GUI_TOUCH_X_ActivateX(void) {}
;;;11     void GUI_TOUCH_X_ActivateY(void) {}
000000  4770              BX       lr
;;;12     volatile int ADC_Value_X,ADC_Value_Y,ADC_Value_t;
                          ENDP


                          AREA ||i.GUI_TOUCH_X_MeasureX||, CODE, READONLY, ALIGN=2

                  GUI_TOUCH_X_MeasureX PROC
;;;127    
;;;128    int  GUI_TOUCH_X_MeasureX(void)
000000  4801              LDR      r0,|L5.8|
;;;129    {
;;;130    	return ADC_Value_X;
000002  6800              LDR      r0,[r0,#0]  ; ADC_Value_X
;;;131    }
000004  4770              BX       lr
;;;132    int  GUI_TOUCH_X_MeasureY(void)
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      ADC_Value_X

                          AREA ||i.GUI_TOUCH_X_MeasureY||, CODE, READONLY, ALIGN=2

                  GUI_TOUCH_X_MeasureY PROC
;;;131    }
;;;132    int  GUI_TOUCH_X_MeasureY(void)
000000  4801              LDR      r0,|L6.8|
;;;133    {
;;;134    	return ADC_Value_Y;
000002  6800              LDR      r0,[r0,#0]  ; ADC_Value_Y
;;;135    }
000004  4770              BX       lr
;;;136    #endif
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      ADC_Value_Y

                          AREA ||i.GUI_TOUCH_Y||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  GUI_TOUCH_Y PROC
;;;213    }
;;;214     u16 GUI_TOUCH_Y(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;215    {
;;;216    volatile u16 i,b;
;;;217    		SetGpio(1);//Y+输出高,Y-输出低,X+测量,X-悬空//03,01,ok
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       SetGpio
;;;218    		i=10000;while(--i);//延时32f429约50us,delay_ms(1);
000008  f2427010          MOV      r0,#0x2710
00000c  9001              STR      r0,[sp,#4]
00000e  bf00              NOP      
                  |L7.16|
000010  f8bd0004          LDRH     r0,[sp,#4]
000014  1e40              SUBS     r0,r0,#1
000016  b280              UXTH     r0,r0
000018  9001              STR      r0,[sp,#4]
00001a  2800              CMP      r0,#0
00001c  d1f8              BNE      |L7.16|
;;;219    		b = Get_Adc_Average(1,2);b = ADC_Value_X;//
00001e  2102              MOVS     r1,#2
000020  2001              MOVS     r0,#1
000022  f7fffffe          BL       Get_Adc_Average
000026  9000              STR      r0,[sp,#0]
000028  4805              LDR      r0,|L7.64|
00002a  6800              LDR      r0,[r0,#0]  ; ADC_Value_X
00002c  b280              UXTH     r0,r0
00002e  9000              STR      r0,[sp,#0]
;;;220    		printf("GUI_TOUCH_Y=%d  ",b);
000030  f8bd1000          LDRH     r1,[sp,#0]
000034  a003              ADR      r0,|L7.68|
000036  f7fffffe          BL       __2printf
;;;221    	  return b;
00003a  f8bd0000          LDRH     r0,[sp,#0]
;;;222    }
00003e  bd1c              POP      {r2-r4,pc}
;;;223    
                          ENDP

                  |L7.64|
                          DCD      ADC_Value_X
                  |L7.68|
000044  4755495f          DCB      "GUI_TOUCH_Y=%d  ",0
000048  544f5543
00004c  485f593d
000050  25642020
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0

                          AREA ||i.Get_Adc||, CODE, READONLY, ALIGN=2

                  Get_Adc PROC
;;;162    
;;;163    u16 Get_Adc(u8 ch)   
000000  4601              MOV      r1,r0
;;;164    {
;;;165    	u16 temp_AD=0;
000002  2000              MOVS     r0,#0
;;;166    
;;;167    	{
;;;168        if(ch==1)
000004  2901              CMP      r1,#1
000006  d10b              BNE      |L8.32|
;;;169    			{
;;;170    				  data_ok_flag=2;          //0数据ok，，1取y数据,//2取x数据
000008  2202              MOVS     r2,#2
00000a  4b0b              LDR      r3,|L8.56|
00000c  801a              STRH     r2,[r3,#0]
;;;171    				//printf(" wait X!\r\n");
;;;172    				//TOUCHPAD_er(); 
;;;173    					while(data_ok_flag)  //等待有效数据
00000e  bf00              NOP      
                  |L8.16|
000010  4a09              LDR      r2,|L8.56|
000012  8812              LDRH     r2,[r2,#0]  ; data_ok_flag
000014  2a00              CMP      r2,#0
000016  d1fb              BNE      |L8.16|
;;;174    					{}
;;;175    		      temp_AD=ADC_Value_X;
000018  4a08              LDR      r2,|L8.60|
00001a  6812              LDR      r2,[r2,#0]  ; ADC_Value_X
00001c  b290              UXTH     r0,r2
00001e  e00a              B        |L8.54|
                  |L8.32|
;;;176    				
;;;177    		  }
;;;178    	  else
;;;179    		  {			
;;;180    	     		data_ok_flag=1;
000020  2201              MOVS     r2,#1
000022  4b05              LDR      r3,|L8.56|
000024  801a              STRH     r2,[r3,#0]
;;;181    							//	printf(" wait Y!\r\n");
;;;182    				//TOUCHPAD_er(); 
;;;183    					while(data_ok_flag)  //等待有效数据
000026  bf00              NOP      
                  |L8.40|
000028  4a03              LDR      r2,|L8.56|
00002a  8812              LDRH     r2,[r2,#0]  ; data_ok_flag
00002c  2a00              CMP      r2,#0
00002e  d1fb              BNE      |L8.40|
;;;184    					{}
;;;185    		      temp_AD=ADC_Value_Y;
000030  4a03              LDR      r2,|L8.64|
000032  6812              LDR      r2,[r2,#0]  ; ADC_Value_Y
000034  b290              UXTH     r0,r2
                  |L8.54|
;;;186    					
;;;187    			}
;;;188    	}
;;;189    	return temp_AD;
;;;190    	}
000036  4770              BX       lr
;;;191    
                          ENDP

                  |L8.56|
                          DCD      data_ok_flag
                  |L8.60|
                          DCD      ADC_Value_X
                  |L8.64|
                          DCD      ADC_Value_Y

                          AREA ||i.Get_Adc_Average||, CODE, READONLY, ALIGN=1

                  Get_Adc_Average PROC
;;;192    
;;;193    u16 Get_Adc_Average(u8 ch,u8 times)
000000  b5f0              PUSH     {r4-r7,lr}
;;;194    {
000002  4607              MOV      r7,r0
000004  460c              MOV      r4,r1
;;;195    	u32 temp_val=0;
000006  2500              MOVS     r5,#0
;;;196    	u8 t;
;;;197    	for(t=0;t<times;t++)
000008  2600              MOVS     r6,#0
00000a  e005              B        |L9.24|
                  |L9.12|
;;;198    	{
;;;199    		temp_val+=Get_Adc(ch);
00000c  4638              MOV      r0,r7
00000e  f7fffffe          BL       Get_Adc
000012  4405              ADD      r5,r5,r0
000014  1c70              ADDS     r0,r6,#1              ;197
000016  b2c6              UXTB     r6,r0                 ;197
                  |L9.24|
000018  42a6              CMP      r6,r4                 ;197
00001a  dbf7              BLT      |L9.12|
;;;200    		//delay_ms(5);
;;;201    	}
;;;202    	//temp_val=Get_Adc(ch);
;;;203    	return temp_val/times;
00001c  fbb5f0f4          UDIV     r0,r5,r4
000020  b280              UXTH     r0,r0
;;;204    }
000022  bdf0              POP      {r4-r7,pc}
;;;205     u16 GUI_TOUCH_X(void)
                          ENDP


                          AREA ||i.SetGpio||, CODE, READONLY, ALIGN=2

                  SetGpio PROC
;;;224    
;;;225    void SetGpio(uint8_t Value)
000000  b51c              PUSH     {r2-r4,lr}
;;;226    {
000002  4604              MOV      r4,r0
;;;227    	GPIO_InitTypeDef GPIO_InitStructure;//定义GPIO初始化结构体变量
;;;228    
;;;229    	//RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);////
;;;230    
;;;231      switch(Value)
000004  b134              CBZ      r4,|L10.20|
000006  2c01              CMP      r4,#1
000008  d037              BEQ      |L10.122|
00000a  2c02              CMP      r4,#2
00000c  d067              BEQ      |L10.222|
00000e  2c03              CMP      r4,#3
000010  d132              BNE      |L10.120|
000012  e097              B        |L10.324|
                  |L10.20|
;;;232    	{
;;;233    		
;;;234    		
;;;235        case 0 :  
;;;236    						GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
000014  2001              MOVS     r0,#1
000016  9000              STR      r0,[sp,#0]
;;;237    						GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	 //推挽输出
000018  2010              MOVS     r0,#0x10
00001a  f88d0005          STRB     r0,[sp,#5]
;;;238    						GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	 //输出的最大频率为50HZ
00001e  2003              MOVS     r0,#3
000020  f88d0004          STRB     r0,[sp,#4]
;;;239    						GPIO_Init(GPIOB, &GPIO_InitStructure);   //初始化GPIO端口
000024  4669              MOV      r1,sp
000026  4862              LDR      r0,|L10.432|
000028  f7fffffe          BL       GPIO_Init
;;;240    						GPIO_SetBits(GPIOB,GPIO_Pin_0); //X+=XR
00002c  2101              MOVS     r1,#1
00002e  4860              LDR      r0,|L10.432|
000030  f7fffffe          BL       GPIO_SetBits
;;;241    		        
;;;242    		        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000034  2004              MOVS     r0,#4
000036  9000              STR      r0,[sp,#0]
;;;243    						GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	 //推挽输出
000038  2010              MOVS     r0,#0x10
00003a  f88d0005          STRB     r0,[sp,#5]
;;;244    						GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	 //输出的最大频率为50HZ
00003e  2003              MOVS     r0,#3
000040  f88d0004          STRB     r0,[sp,#4]
;;;245    						GPIO_Init(GPIOB, &GPIO_InitStructure);   //初始化GPIO端口
000044  4669              MOV      r1,sp
000046  485a              LDR      r0,|L10.432|
000048  f7fffffe          BL       GPIO_Init
;;;246    						GPIO_ResetBits(GPIOB,GPIO_Pin_2); //X-=XL
00004c  2104              MOVS     r1,#4
00004e  4858              LDR      r0,|L10.432|
000050  f7fffffe          BL       GPIO_ResetBits
;;;247    		
;;;248    		        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3; //Y-=YD
000054  2008              MOVS     r0,#8
000056  9000              STR      r0,[sp,#0]
;;;249    	          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;		//浮空输入引脚
000058  2004              MOVS     r0,#4
00005a  f88d0005          STRB     r0,[sp,#5]
;;;250    		        GPIO_Init(GPIOB, &GPIO_InitStructure);   //初始化GPIO端口
00005e  4669              MOV      r1,sp
000060  4853              LDR      r0,|L10.432|
000062  f7fffffe          BL       GPIO_Init
;;;251    		
;;;252    		        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;//Y+=YU
000066  2002              MOVS     r0,#2
000068  9000              STR      r0,[sp,#0]
;;;253    	          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;		//模拟输入引脚
00006a  2000              MOVS     r0,#0
00006c  f88d0005          STRB     r0,[sp,#5]
;;;254    	          GPIO_Init(GPIOB, &GPIO_InitStructure);   //初始化GPIO端口
000070  4669              MOV      r1,sp
000072  484f              LDR      r0,|L10.432|
000074  f7fffffe          BL       GPIO_Init
                  |L10.120|
;;;255    		break;
000078  e097              B        |L10.426|
                  |L10.122|
;;;256    		
;;;257    		case 1 :  
;;;258    				GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
00007a  2002              MOVS     r0,#2
00007c  9000              STR      r0,[sp,#0]
;;;259    				GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	 //推挽输出
00007e  2010              MOVS     r0,#0x10
000080  f88d0005          STRB     r0,[sp,#5]
;;;260    				GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	 //输出的最大频率为50HZ
000084  2003              MOVS     r0,#3
000086  f88d0004          STRB     r0,[sp,#4]
;;;261    				GPIO_Init(GPIOB, &GPIO_InitStructure);   //初始化GPIO端口
00008a  4669              MOV      r1,sp
00008c  4848              LDR      r0,|L10.432|
00008e  f7fffffe          BL       GPIO_Init
;;;262    				GPIO_SetBits(GPIOB,GPIO_Pin_1); //Y+
000092  2102              MOVS     r1,#2
000094  4846              LDR      r0,|L10.432|
000096  f7fffffe          BL       GPIO_SetBits
;;;263    				
;;;264    				GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
00009a  2008              MOVS     r0,#8
00009c  9000              STR      r0,[sp,#0]
;;;265    				GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	 //推挽输出
00009e  2010              MOVS     r0,#0x10
0000a0  f88d0005          STRB     r0,[sp,#5]
;;;266    				GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	 //输出的最大频率为50HZ
0000a4  2003              MOVS     r0,#3
0000a6  f88d0004          STRB     r0,[sp,#4]
;;;267    				GPIO_Init(GPIOB, &GPIO_InitStructure);   //初始化GPIO端口
0000aa  4669              MOV      r1,sp
0000ac  4840              LDR      r0,|L10.432|
0000ae  f7fffffe          BL       GPIO_Init
;;;268    				GPIO_ResetBits(GPIOB,GPIO_Pin_3);//Y-
0000b2  2108              MOVS     r1,#8
0000b4  483e              LDR      r0,|L10.432|
0000b6  f7fffffe          BL       GPIO_ResetBits
;;;269    
;;;270    				GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;//X-
0000ba  2004              MOVS     r0,#4
0000bc  9000              STR      r0,[sp,#0]
;;;271    				GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;		//浮空输入引脚
0000be  f88d0005          STRB     r0,[sp,#5]
;;;272    				GPIO_Init(GPIOB, &GPIO_InitStructure);   //初始化GPIO端口
0000c2  4669              MOV      r1,sp
0000c4  483a              LDR      r0,|L10.432|
0000c6  f7fffffe          BL       GPIO_Init
;;;273    
;;;274    				GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;//X+
0000ca  2001              MOVS     r0,#1
0000cc  9000              STR      r0,[sp,#0]
;;;275    				GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;		//模拟输入引脚
0000ce  2000              MOVS     r0,#0
0000d0  f88d0005          STRB     r0,[sp,#5]
;;;276    				GPIO_Init(GPIOB, &GPIO_InitStructure);   //初始化GPIO端口
0000d4  4669              MOV      r1,sp
0000d6  4836              LDR      r0,|L10.432|
0000d8  f7fffffe          BL       GPIO_Init
;;;277    		break;
0000dc  e065              B        |L10.426|
                  |L10.222|
;;;278    		
;;;279    		case 2 :  
;;;280    				GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;//Y+
0000de  2002              MOVS     r0,#2
0000e0  9000              STR      r0,[sp,#0]
;;;281    				GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	 //推挽输出
0000e2  2010              MOVS     r0,#0x10
0000e4  f88d0005          STRB     r0,[sp,#5]
;;;282    				GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	 //输出的最大频率为50HZ
0000e8  2003              MOVS     r0,#3
0000ea  f88d0004          STRB     r0,[sp,#4]
;;;283    				GPIO_Init(GPIOB, &GPIO_InitStructure);   //初始化GPIO端口
0000ee  4669              MOV      r1,sp
0000f0  482f              LDR      r0,|L10.432|
0000f2  f7fffffe          BL       GPIO_Init
;;;284    				GPIO_SetBits(GPIOB,GPIO_Pin_1); 
0000f6  2102              MOVS     r1,#2
0000f8  482d              LDR      r0,|L10.432|
0000fa  f7fffffe          BL       GPIO_SetBits
;;;285    				
;;;286    				GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;//X-
0000fe  2004              MOVS     r0,#4
000100  9000              STR      r0,[sp,#0]
;;;287    				GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	 //推挽输出
000102  2010              MOVS     r0,#0x10
000104  f88d0005          STRB     r0,[sp,#5]
;;;288    				GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	 //输出的最大频率为50HZ
000108  2003              MOVS     r0,#3
00010a  f88d0004          STRB     r0,[sp,#4]
;;;289    				GPIO_Init(GPIOB, &GPIO_InitStructure);   //初始化GPIO端口
00010e  4669              MOV      r1,sp
000110  4827              LDR      r0,|L10.432|
000112  f7fffffe          BL       GPIO_Init
;;;290    				GPIO_ResetBits(GPIOB,GPIO_Pin_2); 
000116  2104              MOVS     r1,#4
000118  4825              LDR      r0,|L10.432|
00011a  f7fffffe          BL       GPIO_ResetBits
;;;291    
;;;292    				GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;//Y-
00011e  2008              MOVS     r0,#8
000120  9000              STR      r0,[sp,#0]
;;;293    				GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;		//浮空输入引脚
000122  2004              MOVS     r0,#4
000124  f88d0005          STRB     r0,[sp,#5]
;;;294    				GPIO_Init(GPIOB, &GPIO_InitStructure);   //初始化GPIO端口
000128  4669              MOV      r1,sp
00012a  4821              LDR      r0,|L10.432|
00012c  f7fffffe          BL       GPIO_Init
;;;295    
;;;296    				GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;//X+
000130  2001              MOVS     r0,#1
000132  9000              STR      r0,[sp,#0]
;;;297    				GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;		//模拟输入引脚
000134  2000              MOVS     r0,#0
000136  f88d0005          STRB     r0,[sp,#5]
;;;298    				GPIO_Init(GPIOB, &GPIO_InitStructure);   //初始化GPIO端口
00013a  4669              MOV      r1,sp
00013c  481c              LDR      r0,|L10.432|
00013e  f7fffffe          BL       GPIO_Init
;;;299    		break;
000142  e032              B        |L10.426|
                  |L10.324|
;;;300    				
;;;301    		case 3 :  
;;;302    				GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;//Y+
000144  2002              MOVS     r0,#2
000146  9000              STR      r0,[sp,#0]
;;;303    				GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	 //推挽输出
000148  2010              MOVS     r0,#0x10
00014a  f88d0005          STRB     r0,[sp,#5]
;;;304    				GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	 //输出的最大频率为50HZ
00014e  2003              MOVS     r0,#3
000150  f88d0004          STRB     r0,[sp,#4]
;;;305    				GPIO_Init(GPIOB, &GPIO_InitStructure);   //初始化GPIO端口
000154  4669              MOV      r1,sp
000156  4816              LDR      r0,|L10.432|
000158  f7fffffe          BL       GPIO_Init
;;;306    				GPIO_SetBits(GPIOB,GPIO_Pin_1); 
00015c  2102              MOVS     r1,#2
00015e  4814              LDR      r0,|L10.432|
000160  f7fffffe          BL       GPIO_SetBits
;;;307    				
;;;308    				GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;//X-
000164  2004              MOVS     r0,#4
000166  9000              STR      r0,[sp,#0]
;;;309    				GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	 //推挽输出
000168  2010              MOVS     r0,#0x10
00016a  f88d0005          STRB     r0,[sp,#5]
;;;310    				GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	 //输出的最大频率为50HZ
00016e  2003              MOVS     r0,#3
000170  f88d0004          STRB     r0,[sp,#4]
;;;311    				GPIO_Init(GPIOB, &GPIO_InitStructure);   //初始化GPIO端口
000174  4669              MOV      r1,sp
000176  480e              LDR      r0,|L10.432|
000178  f7fffffe          BL       GPIO_Init
;;;312    				GPIO_ResetBits(GPIOB,GPIO_Pin_2); 
00017c  2104              MOVS     r1,#4
00017e  480c              LDR      r0,|L10.432|
000180  f7fffffe          BL       GPIO_ResetBits
;;;313    
;;;314    				GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;//X+
000184  2001              MOVS     r0,#1
000186  9000              STR      r0,[sp,#0]
;;;315    				GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;		//浮空输入引脚
000188  2004              MOVS     r0,#4
00018a  f88d0005          STRB     r0,[sp,#5]
;;;316    				GPIO_Init(GPIOB, &GPIO_InitStructure);   //初始化GPIO端口
00018e  4669              MOV      r1,sp
000190  4807              LDR      r0,|L10.432|
000192  f7fffffe          BL       GPIO_Init
;;;317    
;;;318    				GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;//Y-
000196  2008              MOVS     r0,#8
000198  9000              STR      r0,[sp,#0]
;;;319    				GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;		//模拟输入引脚
00019a  2000              MOVS     r0,#0
00019c  f88d0005          STRB     r0,[sp,#5]
;;;320    				GPIO_Init(GPIOB, &GPIO_InitStructure);   //初始化GPIO端口
0001a0  4669              MOV      r1,sp
0001a2  4803              LDR      r0,|L10.432|
0001a4  f7fffffe          BL       GPIO_Init
;;;321    		break;		
0001a8  bf00              NOP      
                  |L10.426|
0001aa  bf00              NOP                            ;255
;;;322      }
;;;323    }
0001ac  bd1c              POP      {r2-r4,pc}
;;;324    
                          ENDP

0001ae  0000              DCW      0x0000
                  |L10.432|
                          DCD      0x40020400

                          AREA ||i.TOUCHPAD_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_u
                          REQUIRE _printf_int_dec
                  TOUCHPAD_IRQHandler PROC
;;;15     volatile u16	data_ok_flag=0;
;;;16     void TOUCHPAD_IRQHandler()
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;17     {
;;;18     	
;;;19     	if(TOUCHPAD->TPCR & (0x1<<16))
000004  4880              LDR      r0,|L11.520|
000006  6800              LDR      r0,[r0,#0]
000008  f4003080          AND      r0,r0,#0x10000
00000c  2800              CMP      r0,#0
00000e  d078              BEQ      |L11.258|
;;;20     	{
;;;21     						//printf(" TOUCHPAD_IRQHandler!\r\n");
;;;22     		TOUCHPAD->TPCR &= (~0x2);// 禁用A/D触摸屏中断
000010  487d              LDR      r0,|L11.520|
000012  6800              LDR      r0,[r0,#0]
000014  f0200002          BIC      r0,r0,#2
000018  497b              LDR      r1,|L11.520|
00001a  6008              STR      r0,[r1,#0]
;;;23     		TOUCHPAD->TPCR |= 0x1<<16;// 比较标志位,写1清零
00001c  4608              MOV      r0,r1
00001e  6800              LDR      r0,[r0,#0]
000020  f4403080          ORR      r0,r0,#0x10000
000024  6008              STR      r0,[r1,#0]
;;;24     	/************************************************/	
;;;25         if(data_ok_flag==1)    //0数据ok，，1取y数据,//2取x数据
000026  4879              LDR      r0,|L11.524|
000028  8800              LDRH     r0,[r0,#0]  ; data_ok_flag
00002a  2801              CMP      r0,#1
00002c  d154              BNE      |L11.216|
;;;26     		{      //printf(" TOUCHPAD_get-y!\r\n");
;;;27     					Temp_Value_Y[flag_ADC] = TOUCHPAD->TPXDR;
00002e  4876              LDR      r0,|L11.520|
000030  3808              SUBS     r0,r0,#8
000032  6800              LDR      r0,[r0,#0]
000034  4976              LDR      r1,|L11.528|
000036  4a77              LDR      r2,|L11.532|
000038  8812              LDRH     r2,[r2,#0]  ; flag_ADC
00003a  f8210012          STRH     r0,[r1,r2,LSL #1]
;;;28     		 if(flag_ADC==9) 
00003e  4875              LDR      r0,|L11.532|
000040  8800              LDRH     r0,[r0,#0]  ; flag_ADC
000042  2809              CMP      r0,#9
000044  d143              BNE      |L11.206|
;;;29     		 {
;;;30     			u16 k,cou,temp;
;;;31     			flag_ADC = 0;
000046  2300              MOVS     r3,#0
000048  4c72              LDR      r4,|L11.532|
00004a  8023              STRH     r3,[r4,#0]
;;;32     			//将数据升序排列
;;;33     			 for(k=0;k<8;k++)
00004c  2100              MOVS     r1,#0
00004e  e01f              B        |L11.144|
                  |L11.80|
;;;34     			 {	  
;;;35     				for(cou=0;cou<8-k;cou++)
000050  2000              MOVS     r0,#0
000052  e017              B        |L11.132|
                  |L11.84|
;;;36     				{
;;;37     					if(Temp_Value_Y[cou]>Temp_Value_Y[cou+1])
000054  4b6e              LDR      r3,|L11.528|
000056  f8334010          LDRH     r4,[r3,r0,LSL #1]
00005a  461d              MOV      r5,r3
00005c  1c43              ADDS     r3,r0,#1
00005e  f8353013          LDRH     r3,[r5,r3,LSL #1]
000062  429c              CMP      r4,r3
000064  dd0c              BLE      |L11.128|
;;;38     					{
;;;39     						temp=Temp_Value_Y[cou+1];
000066  462c              MOV      r4,r5
000068  1c43              ADDS     r3,r0,#1
00006a  f8342013          LDRH     r2,[r4,r3,LSL #1]
;;;40     						Temp_Value_Y[cou+1]=Temp_Value_Y[cou];
00006e  4623              MOV      r3,r4
000070  f8334010          LDRH     r4,[r3,r0,LSL #1]
000074  1c43              ADDS     r3,r0,#1
000076  f8254013          STRH     r4,[r5,r3,LSL #1]
;;;41     						Temp_Value_Y[cou]=temp;
00007a  462b              MOV      r3,r5
00007c  f8232010          STRH     r2,[r3,r0,LSL #1]
                  |L11.128|
000080  1c43              ADDS     r3,r0,#1              ;35
000082  b298              UXTH     r0,r3                 ;35
                  |L11.132|
000084  f1c10308          RSB      r3,r1,#8              ;35
000088  4283              CMP      r3,r0                 ;35
00008a  dce3              BGT      |L11.84|
00008c  1c4b              ADDS     r3,r1,#1              ;33
00008e  b299              UXTH     r1,r3                 ;33
                  |L11.144|
000090  2908              CMP      r1,#8                 ;33
000092  dbdd              BLT      |L11.80|
;;;42     					}  
;;;43     				}
;;;44     			 }
;;;45     			if(Temp_Value_Y[6]-Temp_Value_Y[3]>300) goto restart_ADCY; //200//if(Temp_Value_Y[7]-Temp_Value_Y[2]>300) goto restart_ADCY; //200
000094  4b5e              LDR      r3,|L11.528|
000096  899b              LDRH     r3,[r3,#0xc]  ; Temp_Value_Y
000098  4c5d              LDR      r4,|L11.528|
00009a  88e4              LDRH     r4,[r4,#6]  ; Temp_Value_Y
00009c  1b1b              SUBS     r3,r3,r4
00009e  f5b37f96          CMP      r3,#0x12c
0000a2  dd00              BLE      |L11.166|
0000a4  e06d              B        |L11.386|
                  |L11.166|
;;;46     			ADC_Value_Y = (Temp_Value_Y[3] + Temp_Value_Y[4] + Temp_Value_Y[5] +Temp_Value_Y[6])>>2;
0000a6  4b5a              LDR      r3,|L11.528|
0000a8  88db              LDRH     r3,[r3,#6]  ; Temp_Value_Y
0000aa  4c59              LDR      r4,|L11.528|
0000ac  8924              LDRH     r4,[r4,#8]  ; Temp_Value_Y
0000ae  4423              ADD      r3,r3,r4
0000b0  4c57              LDR      r4,|L11.528|
0000b2  8964              LDRH     r4,[r4,#0xa]  ; Temp_Value_Y
0000b4  4423              ADD      r3,r3,r4
0000b6  4c56              LDR      r4,|L11.528|
0000b8  89a4              LDRH     r4,[r4,#0xc]  ; Temp_Value_Y
0000ba  4423              ADD      r3,r3,r4
0000bc  109b              ASRS     r3,r3,#2
0000be  4c56              LDR      r4,|L11.536|
0000c0  6023              STR      r3,[r4,#0]  ; ADC_Value_Y
;;;47     			//printf("\r\n ADC_Value_Y= %x  ",ADC_Value_Y);//打印滤波后ADC采样值
;;;48     			data_ok_flag=0;	    //0数据ok，，1取y数据,//2取x数据
0000c2  2300              MOVS     r3,#0
0000c4  4c51              LDR      r4,|L11.524|
0000c6  8023              STRH     r3,[r4,#0]
;;;49     			flag_ADC = 0;  
0000c8  4c52              LDR      r4,|L11.532|
0000ca  8023              STRH     r3,[r4,#0]
;;;50     			 //舍去一半数据
;;;51     			 //for(k=0;k<5;k++)
;;;52     			 //{
;;;53     			//Temp_Value_Y[k]=Temp_Value_Y[5+k];
;;;54     			// }
;;;55     		 }	
0000cc  e004              B        |L11.216|
                  |L11.206|
;;;56     		 else flag_ADC++;
0000ce  4851              LDR      r0,|L11.532|
0000d0  8800              LDRH     r0,[r0,#0]  ; flag_ADC
0000d2  1c40              ADDS     r0,r0,#1
0000d4  494f              LDR      r1,|L11.532|
0000d6  8008              STRH     r0,[r1,#0]
                  |L11.216|
;;;57     	  }
;;;58     
;;;59     	//////////////////////
;;;60     	 if(data_ok_flag==2)    //0数据ok，，1取y数据,//2取x数据
0000d8  484c              LDR      r0,|L11.524|
0000da  8800              LDRH     r0,[r0,#0]  ; data_ok_flag
0000dc  2802              CMP      r0,#2
0000de  d110              BNE      |L11.258|
;;;61     		{
;;;62     			 
;;;63     					Temp_Value_X[flag_ADC] = TOUCHPAD->TPYDR;
0000e0  4849              LDR      r0,|L11.520|
0000e2  1f00              SUBS     r0,r0,#4
0000e4  6800              LDR      r0,[r0,#0]
0000e6  494d              LDR      r1,|L11.540|
0000e8  4a4a              LDR      r2,|L11.532|
0000ea  8812              LDRH     r2,[r2,#0]  ; flag_ADC
0000ec  f8210012          STRH     r0,[r1,r2,LSL #1]
;;;64     		 if(flag_ADC==9) 
0000f0  4848              LDR      r0,|L11.532|
0000f2  8800              LDRH     r0,[r0,#0]  ; flag_ADC
0000f4  2809              CMP      r0,#9
0000f6  d179              BNE      |L11.492|
;;;65     		 {
;;;66     			u16 k,cou,temp,i;
;;;67     			flag_ADC = 0;
0000f8  2000              MOVS     r0,#0
0000fa  4946              LDR      r1,|L11.532|
0000fc  8008              STRH     r0,[r1,#0]
;;;68     			//将数据升序排列
;;;69     			 for(k=0;k<8;k++)
0000fe  2600              MOVS     r6,#0
000100  e020              B        |L11.324|
                  |L11.258|
000102  e078              B        |L11.502|
                  |L11.260|
;;;70     			 {	  
;;;71     				for(cou=0;cou<8-k;cou++)
000104  2400              MOVS     r4,#0
000106  e017              B        |L11.312|
                  |L11.264|
;;;72     				{
;;;73     					if(Temp_Value_X[cou]>Temp_Value_X[cou+1])
000108  4844              LDR      r0,|L11.540|
00010a  f8301014          LDRH     r1,[r0,r4,LSL #1]
00010e  4602              MOV      r2,r0
000110  1c60              ADDS     r0,r4,#1
000112  f8320010          LDRH     r0,[r2,r0,LSL #1]
000116  4281              CMP      r1,r0
000118  dd0c              BLE      |L11.308|
;;;74     					{
;;;75     						temp=Temp_Value_X[cou+1];
00011a  4611              MOV      r1,r2
00011c  1c60              ADDS     r0,r4,#1
00011e  f8317010          LDRH     r7,[r1,r0,LSL #1]
;;;76     						Temp_Value_X[cou+1]=Temp_Value_X[cou];
000122  4608              MOV      r0,r1
000124  f8301014          LDRH     r1,[r0,r4,LSL #1]
000128  1c60              ADDS     r0,r4,#1
00012a  f8221010          STRH     r1,[r2,r0,LSL #1]
;;;77     						Temp_Value_X[cou]=temp;
00012e  4610              MOV      r0,r2
000130  f8207014          STRH     r7,[r0,r4,LSL #1]
                  |L11.308|
000134  1c60              ADDS     r0,r4,#1              ;71
000136  b284              UXTH     r4,r0                 ;71
                  |L11.312|
000138  f1c60008          RSB      r0,r6,#8              ;71
00013c  42a0              CMP      r0,r4                 ;71
00013e  dce3              BGT      |L11.264|
000140  1c70              ADDS     r0,r6,#1              ;69
000142  b286              UXTH     r6,r0                 ;69
                  |L11.324|
000144  2e08              CMP      r6,#8                 ;69
000146  dbdd              BLT      |L11.260|
;;;78     					}  
;;;79     				}
;;;80     			 }
;;;81     			if(Temp_Value_X[6]-Temp_Value_X[3]>300) goto restart_ADCX; //200//if(Temp_Value_X[7]-Temp_Value_X[2]>200) goto restart_ADCX; //200
000148  4834              LDR      r0,|L11.540|
00014a  8980              LDRH     r0,[r0,#0xc]  ; Temp_Value_X
00014c  4933              LDR      r1,|L11.540|
00014e  88c9              LDRH     r1,[r1,#6]  ; Temp_Value_X
000150  1a40              SUBS     r0,r0,r1
000152  f5b07f96          CMP      r0,#0x12c
000156  dd00              BLE      |L11.346|
000158  e02d              B        |L11.438|
                  |L11.346|
;;;82     			ADC_Value_X = (Temp_Value_X[3] + Temp_Value_X[4] + Temp_Value_X[5] +Temp_Value_X[6])>>2;
00015a  4830              LDR      r0,|L11.540|
00015c  88c0              LDRH     r0,[r0,#6]  ; Temp_Value_X
00015e  492f              LDR      r1,|L11.540|
000160  8909              LDRH     r1,[r1,#8]  ; Temp_Value_X
000162  4408              ADD      r0,r0,r1
000164  492d              LDR      r1,|L11.540|
000166  8949              LDRH     r1,[r1,#0xa]  ; Temp_Value_X
000168  4408              ADD      r0,r0,r1
00016a  492c              LDR      r1,|L11.540|
00016c  8989              LDRH     r1,[r1,#0xc]  ; Temp_Value_X
00016e  4408              ADD      r0,r0,r1
000170  1080              ASRS     r0,r0,#2
000172  492b              LDR      r1,|L11.544|
000174  6008              STR      r0,[r1,#0]  ; ADC_Value_X
;;;83     			//printf("\r\n ADC_Value_X= %x  ",ADC_Value_X);//打印滤波后ADC采样值		
;;;84     			data_ok_flag=0;//0取x数据，1取y数据,//2x数据ok，3y数据ok，
000176  2000              MOVS     r0,#0
000178  4924              LDR      r1,|L11.524|
00017a  8008              STRH     r0,[r1,#0]
;;;85     		  flag_ADC = 0;  
00017c  4925              LDR      r1,|L11.532|
00017e  8008              STRH     r0,[r1,#0]
;;;86     			 //舍去一半数据
;;;87     			//for(k=0;k<5;k++)   
;;;88     		//	 {
;;;89     			//Temp_Value_X[k]=Temp_Value_X[5+k];
;;;90     			// }
;;;91     
;;;92     			 while(0)  //goto_restart_ADCY//正常状态不会执行
000180  e017              B        |L11.434|
                  |L11.386|
;;;93     					{			
;;;94     						restart_ADCY:
;;;95     			      flag_ADC = 0;
000182  2000              MOVS     r0,#0
000184  4923              LDR      r1,|L11.532|
000186  8008              STRH     r0,[r1,#0]
;;;96     	   	      printf("\r\n goto_restart_ADCY \r\n");
000188  a026              ADR      r0,|L11.548|
00018a  f7fffffe          BL       __2printf
;;;97     							printf(" Temp_Value_Y[0]:");
00018e  a02b              ADR      r0,|L11.572|
000190  f7fffffe          BL       __2printf
;;;98     	              for (i=0;i<10;i++)
000194  2500              MOVS     r5,#0
000196  e007              B        |L11.424|
                  |L11.408|
;;;99                     	{
;;;100    	                	printf(" %u ", Temp_Value_Y[i]);
000198  481d              LDR      r0,|L11.528|
00019a  f8301015          LDRH     r1,[r0,r5,LSL #1]
00019e  a02c              ADR      r0,|L11.592|
0001a0  f7fffffe          BL       __2printf
0001a4  1c68              ADDS     r0,r5,#1              ;98
0001a6  b285              UXTH     r5,r0                 ;98
                  |L11.424|
0001a8  2d0a              CMP      r5,#0xa               ;98
0001aa  dbf5              BLT      |L11.408|
;;;101    	                }
;;;102    	           printf("\r\n");
0001ac  a02a              ADR      r0,|L11.600|
0001ae  f7fffffe          BL       __2printf
                  |L11.434|
0001b2  bf00              NOP                            ;92
;;;103    					}
;;;104    			 while(0)  //goto_restart_ADCX//正常状态不会执行
0001b4  e017              B        |L11.486|
                  |L11.438|
;;;105    					{			
;;;106    						restart_ADCX:
;;;107    			      flag_ADC = 0;
0001b6  2000              MOVS     r0,#0
0001b8  4916              LDR      r1,|L11.532|
0001ba  8008              STRH     r0,[r1,#0]
;;;108    	   	      printf("\r\n goto_restart_ADCX \r\n");
0001bc  a027              ADR      r0,|L11.604|
0001be  f7fffffe          BL       __2printf
;;;109    							printf(" Temp_Value_X[0]:");
0001c2  a02c              ADR      r0,|L11.628|
0001c4  f7fffffe          BL       __2printf
;;;110    	              for (i=0;i<10;i++)
0001c8  2500              MOVS     r5,#0
0001ca  e007              B        |L11.476|
                  |L11.460|
;;;111                    	{
;;;112    	                	printf(" %u ", Temp_Value_Y[i]);
0001cc  4810              LDR      r0,|L11.528|
0001ce  f8301015          LDRH     r1,[r0,r5,LSL #1]
0001d2  a01f              ADR      r0,|L11.592|
0001d4  f7fffffe          BL       __2printf
0001d8  1c68              ADDS     r0,r5,#1              ;110
0001da  b285              UXTH     r5,r0                 ;110
                  |L11.476|
0001dc  2d0a              CMP      r5,#0xa               ;110
0001de  dbf5              BLT      |L11.460|
;;;113    	                }
;;;114    	           printf("\r\n");
0001e0  a01d              ADR      r0,|L11.600|
0001e2  f7fffffe          BL       __2printf
                  |L11.486|
0001e6  bf00              NOP                            ;104
;;;115    					}					
;;;116    
;;;117    			}	
0001e8  e005              B        |L11.502|
0001ea  e7ff              B        |L11.492|
                  |L11.492|
;;;118    		 else 
;;;119    			 flag_ADC++;
0001ec  4809              LDR      r0,|L11.532|
0001ee  8800              LDRH     r0,[r0,#0]  ; flag_ADC
0001f0  1c40              ADDS     r0,r0,#1
0001f2  4908              LDR      r1,|L11.532|
0001f4  8008              STRH     r0,[r1,#0]
                  |L11.502|
;;;120    		 //printf(" ADC++!\r\n");
;;;121    		}
;;;122    
;;;123    	}
;;;124    
;;;125    			TOUCHPAD->TPCR |= 0x03;//重新使能A/D触摸屏中断,使能A/D触摸3
0001f6  4804              LDR      r0,|L11.520|
0001f8  6800              LDR      r0,[r0,#0]
0001fa  f0400003          ORR      r0,r0,#3
0001fe  4902              LDR      r1,|L11.520|
000200  6008              STR      r0,[r1,#0]
;;;126    }	
000202  e8bd81f0          POP      {r4-r8,pc}
;;;127    
                          ENDP

000206  0000              DCW      0x0000
                  |L11.520|
                          DCD      0x40016450
                  |L11.524|
                          DCD      data_ok_flag
                  |L11.528|
                          DCD      Temp_Value_Y
                  |L11.532|
                          DCD      flag_ADC
                  |L11.536|
                          DCD      ADC_Value_Y
                  |L11.540|
                          DCD      Temp_Value_X
                  |L11.544|
                          DCD      ADC_Value_X
                  |L11.548|
000224  0d0a2067          DCB      "\r\n goto_restart_ADCY \r\n",0
000228  6f746f5f
00022c  72657374
000230  6172745f
000234  41444359
000238  200d0a00
                  |L11.572|
00023c  2054656d          DCB      " Temp_Value_Y[0]:",0
000240  705f5661
000244  6c75655f
000248  595b305d
00024c  3a00    
00024e  00                DCB      0
00024f  00                DCB      0
                  |L11.592|
000250  20257520          DCB      " %u ",0
000254  00      
000255  00                DCB      0
000256  00                DCB      0
000257  00                DCB      0
                  |L11.600|
000258  0d0a00            DCB      "\r\n",0
00025b  00                DCB      0
                  |L11.604|
00025c  0d0a2067          DCB      "\r\n goto_restart_ADCX \r\n",0
000260  6f746f5f
000264  72657374
000268  6172745f
00026c  41444358
000270  200d0a00
                  |L11.628|
000274  2054656d          DCB      " Temp_Value_X[0]:",0
000278  705f5661
00027c  6c75655f
000280  585b305d
000284  3a00    
000286  00                DCB      0
000287  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  Temp_Value_X
                          %        20
                  Temp_Value_Y
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  ADC_Value_X
                          DCD      0x00000000
                  ADC_Value_Y
                          DCD      0x00000000
                  ADC_Value_t
                          DCD      0x00000000
                  flag_ADC
00000c  0000              DCW      0x0000
                  data_ok_flag
00000e  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "bsp\\touchpad\\touchpad.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_touchpad_c_927991f6____REV16|
#line 388 "..\\CMSIS_and_startup\\CMSIS\\cmsis_armcc.h"
|__asm___10_touchpad_c_927991f6____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_touchpad_c_927991f6____REVSH|
#line 402
|__asm___10_touchpad_c_927991f6____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_touchpad_c_927991f6____RRX|
#line 587
|__asm___10_touchpad_c_927991f6____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
