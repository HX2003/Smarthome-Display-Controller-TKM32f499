; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\hal_tim.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\hal_tim.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CMSIS_and_startup -I..\CMSIS_and_startup\CMSIS -I.\bsp -I..\Hal_lib\inc -I.\bsp\LCD -I.\bsp\LED -I.\bsp\SPI -I.\bsp\sys -I.\bsp\UART -I.\bsp\Timer -I.\bsp\exit -I.\bsp\touchpad -I.\RTE\_TK499_LTDC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.5.1\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=527 -DARMCM4_FP --omf_browse=.\obj\hal_tim.crf ..\Hal_lib\src\HAL_tim.c]
                          THUMB

                          AREA ||i.TI1_Config||, CODE, READONLY, ALIGN=1

                  TI1_Config PROC
;;;3159   */
;;;3160   static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3161                          uint16_t TIM_ICFilter)
;;;3162   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;3163     uint16_t tmpccmr1 = 0, tmpccer = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
;;;3164     /* Disable the Channel 1: Reset the CC1E Bit */
;;;3165     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
00000a  6a06              LDR      r6,[r0,#0x20]
00000c  f64f77fe          MOV      r7,#0xfffe
000010  403e              ANDS     r6,r6,r7
000012  6206              STR      r6,[r0,#0x20]
;;;3166     tmpccmr1 = TIMx->CCMR1;
000014  6986              LDR      r6,[r0,#0x18]
000016  b2b1              UXTH     r1,r6
;;;3167     tmpccer = TIMx->CCER;
000018  6a06              LDR      r6,[r0,#0x20]
00001a  b2b2              UXTH     r2,r6
;;;3168     /* Select the Input and set the filter */
;;;3169     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
00001c  f64f760c          MOV      r6,#0xff0c
000020  4031              ANDS     r1,r1,r6
;;;3170     tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
000022  1c7e              ADDS     r6,r7,#1
000024  ea061603          AND      r6,r6,r3,LSL #4
000028  432e              ORRS     r6,r6,r5
00002a  4331              ORRS     r1,r1,r6
;;;3171     
;;;3172     /* Select the Polarity and set the CC1E Bit */
;;;3173     tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
00002c  f64f76f5          MOV      r6,#0xfff5
000030  4032              ANDS     r2,r2,r6
;;;3174     tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
000032  f0440601          ORR      r6,r4,#1
000036  4332              ORRS     r2,r2,r6
;;;3175     /* Write to TIMx CCMR1 and CCER registers */
;;;3176     TIMx->CCMR1 = tmpccmr1;
000038  6181              STR      r1,[r0,#0x18]
;;;3177     TIMx->CCER = tmpccer;
00003a  6202              STR      r2,[r0,#0x20]
;;;3178   }
00003c  bdf0              POP      {r4-r7,pc}
;;;3179   
                          ENDP


                          AREA ||i.TI2_Config||, CODE, READONLY, ALIGN=1

                  TI2_Config PROC
;;;3196   */
;;;3197   static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3198                          uint16_t TIM_ICFilter)
;;;3199   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;3200     uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;3201     /* Disable the Channel 2: Reset the CC2E Bit */
;;;3202     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
00000c  6a07              LDR      r7,[r0,#0x20]
00000e  f64f7cef          MOV      r12,#0xffef
000012  ea07070c          AND      r7,r7,r12
000016  6207              STR      r7,[r0,#0x20]
;;;3203     tmpccmr1 = TIMx->CCMR1;
000018  6987              LDR      r7,[r0,#0x18]
00001a  b2b9              UXTH     r1,r7
;;;3204     tmpccer = TIMx->CCER;
00001c  6a07              LDR      r7,[r0,#0x20]
00001e  b2ba              UXTH     r2,r7
;;;3205     tmp = (uint16_t)(TIM_ICPolarity << 4);
000020  f64f77ff          MOV      r7,#0xffff
000024  ea071604          AND      r6,r7,r4,LSL #4
;;;3206     /* Select the Input and set the filter */
;;;3207     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
000028  f64047ff          MOV      r7,#0xcff
00002c  4039              ANDS     r1,r1,r7
;;;3208     tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
00002e  f64f77ff          MOV      r7,#0xffff
000032  ea073703          AND      r7,r7,r3,LSL #12
000036  4339              ORRS     r1,r1,r7
;;;3209     tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8); 
000038  f64f77ff          MOV      r7,#0xffff
00003c  ea072705          AND      r7,r7,r5,LSL #8
000040  4339              ORRS     r1,r1,r7
;;;3210     /* Select the Polarity and set the CC2E Bit */
;;;3211     tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
000042  f64f775f          MOV      r7,#0xff5f
000046  403a              ANDS     r2,r2,r7
;;;3212     tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);  
000048  f0460710          ORR      r7,r6,#0x10
00004c  433a              ORRS     r2,r2,r7
;;;3213     /* Write to TIMx CCMR1 and CCER registers */
;;;3214     TIMx->CCMR1 = tmpccmr1 ;
00004e  6181              STR      r1,[r0,#0x18]
;;;3215     TIMx->CCER = tmpccer;
000050  6202              STR      r2,[r0,#0x20]
;;;3216   }
000052  bdf0              POP      {r4-r7,pc}
;;;3217   
                          ENDP


                          AREA ||i.TI3_Config||, CODE, READONLY, ALIGN=1

                  TI3_Config PROC
;;;3234   */
;;;3235   static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3236                          uint16_t TIM_ICFilter)
;;;3237   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;3238     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;3239     /* Disable the Channel 3: Reset the CC3E Bit */
;;;3240     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
00000c  6a07              LDR      r7,[r0,#0x20]
00000e  f64f6cff          MOV      r12,#0xfeff
000012  ea07070c          AND      r7,r7,r12
000016  6207              STR      r7,[r0,#0x20]
;;;3241     tmpccmr2 = TIMx->CCMR2;
000018  69c7              LDR      r7,[r0,#0x1c]
00001a  b2b9              UXTH     r1,r7
;;;3242     tmpccer = TIMx->CCER;
00001c  6a07              LDR      r7,[r0,#0x20]
00001e  b2ba              UXTH     r2,r7
;;;3243     tmp = (uint16_t)(TIM_ICPolarity << 8);
000020  f64f77ff          MOV      r7,#0xffff
000024  ea072604          AND      r6,r7,r4,LSL #8
;;;3244     /* Select the Input and set the filter */
;;;3245     tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));
000028  f64f770c          MOV      r7,#0xff0c
00002c  4039              ANDS     r1,r1,r7
;;;3246     tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
00002e  f64f77ff          MOV      r7,#0xffff
000032  ea071703          AND      r7,r7,r3,LSL #4
000036  432f              ORRS     r7,r7,r5
000038  4339              ORRS     r1,r1,r7
;;;3247     /* Select the Polarity and set the CC3E Bit */
;;;3248     tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC3NP));
00003a  f24f57ff          MOV      r7,#0xf5ff
00003e  403a              ANDS     r2,r2,r7
;;;3249     tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);  
000040  f4467780          ORR      r7,r6,#0x100
000044  433a              ORRS     r2,r2,r7
;;;3250     /* Write to TIMx CCMR2 and CCER registers */
;;;3251     TIMx->CCMR2 = tmpccmr2;
000046  61c1              STR      r1,[r0,#0x1c]
;;;3252     TIMx->CCER = tmpccer;
000048  6202              STR      r2,[r0,#0x20]
;;;3253   }
00004a  bdf0              POP      {r4-r7,pc}
;;;3254   
                          ENDP


                          AREA ||i.TI4_Config||, CODE, READONLY, ALIGN=1

                  TI4_Config PROC
;;;3271   */
;;;3272   static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3273                          uint16_t TIM_ICFilter)
;;;3274   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;3275     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;3276     
;;;3277     /* Disable the Channel 4: Reset the CC4E Bit */
;;;3278     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);
00000c  6a07              LDR      r7,[r0,#0x20]
00000e  f64e7cff          MOV      r12,#0xefff
000012  ea07070c          AND      r7,r7,r12
000016  6207              STR      r7,[r0,#0x20]
;;;3279     tmpccmr2 = TIMx->CCMR2;
000018  69c7              LDR      r7,[r0,#0x1c]
00001a  b2b9              UXTH     r1,r7
;;;3280     tmpccer = TIMx->CCER;
00001c  6a07              LDR      r7,[r0,#0x20]
00001e  b2ba              UXTH     r2,r7
;;;3281     tmp = (uint16_t)(TIM_ICPolarity << 12);
000020  f64f77ff          MOV      r7,#0xffff
000024  ea073604          AND      r6,r7,r4,LSL #12
;;;3282     /* Select the Input and set the filter */
;;;3283     tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
000028  f64047ff          MOV      r7,#0xcff
00002c  4039              ANDS     r1,r1,r7
;;;3284     tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
00002e  f64f77ff          MOV      r7,#0xffff
000032  ea072705          AND      r7,r7,r5,LSL #8
000036  4339              ORRS     r1,r1,r7
;;;3285     tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);  
000038  f64f77ff          MOV      r7,#0xffff
00003c  ea073703          AND      r7,r7,r3,LSL #12
000040  4339              ORRS     r1,r1,r7
;;;3286     /* Select the Polarity and set the CC4E Bit */
;;;3287     tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC4P | TIM_CCER_CC4NP));
000042  f64577ff          MOV      r7,#0x5fff
000046  403a              ANDS     r2,r2,r7
;;;3288     tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
000048  f4465780          ORR      r7,r6,#0x1000
00004c  433a              ORRS     r2,r2,r7
;;;3289     /* Write to TIMx CCMR2 and CCER registers */
;;;3290     TIMx->CCMR2 = tmpccmr2;
00004e  61c1              STR      r1,[r0,#0x1c]
;;;3291     TIMx->CCER = tmpccer;
000050  6202              STR      r2,[r0,#0x20]
;;;3292   }
000052  bdf0              POP      {r4-r7,pc}
;;;3293   
                          ENDP


                          AREA ||i.TIM_ARRPreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_ARRPreloadConfig PROC
;;;480    */
;;;481    void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L5.12|
;;;482    {
;;;483      /* Check the parameters */
;;;484      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;485      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;486      
;;;487      if (NewState != DISABLE)
;;;488      {
;;;489        /* Set the ARR Preload Bit */
;;;490        TIMx->CR1 |= TIM_CR1_ARPE;
000002  6802              LDR      r2,[r0,#0]
000004  f0420280          ORR      r2,r2,#0x80
000008  6002              STR      r2,[r0,#0]
00000a  e004              B        |L5.22|
                  |L5.12|
;;;491      }
;;;492      else
;;;493      {
;;;494        /* Reset the ARR Preload Bit */
;;;495        TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_ARPE);
00000c  6802              LDR      r2,[r0,#0]
00000e  f64f737f          MOV      r3,#0xff7f
000012  401a              ANDS     r2,r2,r3
000014  6002              STR      r2,[r0,#0]
                  |L5.22|
;;;496      }
;;;497    }
000016  4770              BX       lr
;;;498    
                          ENDP


                          AREA ||i.TIM_BDTRConfig||, CODE, READONLY, ALIGN=1

                  TIM_BDTRConfig PROC
;;;615    */
;;;616    void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
000000  880a              LDRH     r2,[r1,#0]
;;;617    {
;;;618      /* Check the parameters */
;;;619      assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;620      assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;621      assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;622      assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;623      assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;624      assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;625      assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;626      /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
;;;627      the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;628      TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
000002  884b              LDRH     r3,[r1,#2]
000004  431a              ORRS     r2,r2,r3
000006  888b              LDRH     r3,[r1,#4]
000008  431a              ORRS     r2,r2,r3
00000a  88cb              LDRH     r3,[r1,#6]
00000c  431a              ORRS     r2,r2,r3
00000e  890b              LDRH     r3,[r1,#8]
000010  431a              ORRS     r2,r2,r3
000012  894b              LDRH     r3,[r1,#0xa]
000014  431a              ORRS     r2,r2,r3
000016  898b              LDRH     r3,[r1,#0xc]
000018  431a              ORRS     r2,r2,r3
00001a  6442              STR      r2,[r0,#0x44]
;;;629        TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;630          TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;631            TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;632    }
00001c  4770              BX       lr
;;;633    
                          ENDP


                          AREA ||i.TIM_BDTRStructInit||, CODE, READONLY, ALIGN=1

                  TIM_BDTRStructInit PROC
;;;639    */
;;;640    void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000000  2100              MOVS     r1,#0
;;;641    {
;;;642      /* Set the default configuration */
;;;643      TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;644      TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;645      TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
000006  8081              STRH     r1,[r0,#4]
;;;646      TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
000008  80c1              STRH     r1,[r0,#6]
;;;647      TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
00000a  8101              STRH     r1,[r0,#8]
;;;648      TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
00000c  8141              STRH     r1,[r0,#0xa]
;;;649      TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
00000e  8181              STRH     r1,[r0,#0xc]
;;;650    }
000010  4770              BX       lr
;;;651    
                          ENDP


                          AREA ||i.TIM_CCPreloadControl||, CODE, READONLY, ALIGN=1

                  TIM_CCPreloadControl PROC
;;;1302   */
;;;1303   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L8.12|
;;;1304   { 
;;;1305     /* Check the parameters */
;;;1306     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1307     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1308     if (NewState != DISABLE)
;;;1309     {
;;;1310       /* Set the CCPC Bit */
;;;1311       TIMx->CR2 |= TIM_CR2_CCPC;
000002  6842              LDR      r2,[r0,#4]
000004  f0420201          ORR      r2,r2,#1
000008  6042              STR      r2,[r0,#4]
00000a  e004              B        |L8.22|
                  |L8.12|
;;;1312     }
;;;1313     else
;;;1314     {
;;;1315       /* Reset the CCPC Bit */
;;;1316       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCPC);
00000c  6842              LDR      r2,[r0,#4]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  6042              STR      r2,[r0,#4]
                  |L8.22|
;;;1317     }
;;;1318   }
000016  4770              BX       lr
;;;1319   
                          ENDP


                          AREA ||i.TIM_CCxCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxCmd PROC
;;;1858   */
;;;1859   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
000000  b530              PUSH     {r4,r5,lr}
;;;1860   {
;;;1861     uint16_t tmp = 0;
000002  2300              MOVS     r3,#0
;;;1862     
;;;1863     /* Check the parameters */
;;;1864     assert_param(IS_TIM_LIST4_PERIPH(TIMx)); 
;;;1865     assert_param(IS_TIM_CCX(TIM_CCx));
;;;1866     
;;;1867     tmp = CCER_CCE_SET << TIM_Channel;
000004  2401              MOVS     r4,#1
000006  408c              LSLS     r4,r4,r1
000008  b2a3              UXTH     r3,r4
;;;1868     
;;;1869     /* Reset the CCxE Bit */
;;;1870     TIMx->CCER &= (uint16_t)~ tmp;
00000a  6a04              LDR      r4,[r0,#0x20]
00000c  43dd              MVNS     r5,r3
00000e  b2ad              UXTH     r5,r5
000010  402c              ANDS     r4,r4,r5
000012  6204              STR      r4,[r0,#0x20]
;;;1871     
;;;1872     /* Set or reset the CCxE Bit */ 
;;;1873     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
000014  6a04              LDR      r4,[r0,#0x20]
000016  fa02f501          LSL      r5,r2,r1
00001a  b2ad              UXTH     r5,r5
00001c  432c              ORRS     r4,r4,r5
00001e  6204              STR      r4,[r0,#0x20]
;;;1874   }
000020  bd30              POP      {r4,r5,pc}
;;;1875   
                          ENDP


                          AREA ||i.TIM_CCxNCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNCmd PROC
;;;1887   */
;;;1888   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
000000  b530              PUSH     {r4,r5,lr}
;;;1889   {
;;;1890     uint16_t tmp = 0;
000002  2300              MOVS     r3,#0
;;;1891     
;;;1892     /* Check the parameters */
;;;1893     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1894     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;1895     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;1896     
;;;1897     tmp = CCER_CCNE_SET << TIM_Channel;
000004  2404              MOVS     r4,#4
000006  408c              LSLS     r4,r4,r1
000008  b2a3              UXTH     r3,r4
;;;1898     
;;;1899     /* Reset the CCxNE Bit */
;;;1900     TIMx->CCER &= (uint16_t) ~tmp;
00000a  6a04              LDR      r4,[r0,#0x20]
00000c  43dd              MVNS     r5,r3
00000e  b2ad              UXTH     r5,r5
000010  402c              ANDS     r4,r4,r5
000012  6204              STR      r4,[r0,#0x20]
;;;1901     
;;;1902     /* Set or reset the CCxNE Bit */ 
;;;1903     TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
000014  6a04              LDR      r4,[r0,#0x20]
000016  fa02f501          LSL      r5,r2,r1
00001a  b2ad              UXTH     r5,r5
00001c  432c              ORRS     r4,r4,r5
00001e  6204              STR      r4,[r0,#0x20]
;;;1904   }
000020  bd30              POP      {r4,r5,pc}
;;;1905   
                          ENDP


                          AREA ||i.TIM_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIM_ClearFlag PROC
;;;2444   */
;;;2445   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  43ca              MVNS     r2,r1
;;;2446   {  
;;;2447     /* Check the parameters */
;;;2448     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2449     assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
;;;2450     
;;;2451     /* Clear the flags */
;;;2452     TIMx->SR = (uint16_t)~TIM_FLAG;
000002  b292              UXTH     r2,r2
000004  6102              STR      r2,[r0,#0x10]
;;;2453   }
000006  4770              BX       lr
;;;2454   
                          ENDP


                          AREA ||i.TIM_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  TIM_ClearITPendingBit PROC
;;;2527   */
;;;2528   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  43ca              MVNS     r2,r1
;;;2529   {
;;;2530     /* Check the parameters */
;;;2531     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2532     assert_param(IS_TIM_IT(TIM_IT));
;;;2533     
;;;2534     /* Clear the IT pending Bit */
;;;2535     TIMx->SR = (uint16_t)~TIM_IT;
000002  b292              UXTH     r2,r2
000004  6102              STR      r2,[r0,#0x10]
;;;2536   }
000006  4770              BX       lr
;;;2537   
                          ENDP


                          AREA ||i.TIM_ClearOC1Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC1Ref PROC
;;;1548   */
;;;1549   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1550   {
;;;1551     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1552     
;;;1553     /* Check the parameters */
;;;1554     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1555     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1556     
;;;1557     tmpccmr1 = TIMx->CCMR1;
000004  6983              LDR      r3,[r0,#0x18]
000006  b299              UXTH     r1,r3
;;;1558     /* Reset the OC1CE Bit */
;;;1559     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1CE);
000008  f64f737f          MOV      r3,#0xff7f
00000c  4019              ANDS     r1,r1,r3
;;;1560     /* Enable or Disable the Output Compare Clear Bit */
;;;1561     tmpccmr1 |= TIM_OCClear;
00000e  4311              ORRS     r1,r1,r2
;;;1562     /* Write to TIMx CCMR1 register */
;;;1563     TIMx->CCMR1 = tmpccmr1;
000010  6181              STR      r1,[r0,#0x18]
;;;1564   }
000012  4770              BX       lr
;;;1565   
                          ENDP


                          AREA ||i.TIM_ClearOC2Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC2Ref PROC
;;;1575   */
;;;1576   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1577   {
;;;1578     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1579     
;;;1580     /* Check the parameters */
;;;1581     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1582     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1583     
;;;1584     tmpccmr1 = TIMx->CCMR1;
000004  6983              LDR      r3,[r0,#0x18]
000006  b299              UXTH     r1,r3
;;;1585     /* Reset the OC2CE Bit */
;;;1586     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);
000008  f3c1010e          UBFX     r1,r1,#0,#15
;;;1587     /* Enable or Disable the Output Compare Clear Bit */
;;;1588     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1589     /* Write to TIMx CCMR1 register */
;;;1590     TIMx->CCMR1 = tmpccmr1;
000016  6181              STR      r1,[r0,#0x18]
;;;1591   }
000018  4770              BX       lr
;;;1592   
                          ENDP


                          AREA ||i.TIM_ClearOC3Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC3Ref PROC
;;;1602   */
;;;1603   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1604   {
;;;1605     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1606     
;;;1607     /* Check the parameters */
;;;1608     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1609     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1610     
;;;1611     tmpccmr2 = TIMx->CCMR2;
000004  69c3              LDR      r3,[r0,#0x1c]
000006  b299              UXTH     r1,r3
;;;1612     /* Reset the OC3CE Bit */
;;;1613     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3CE);
000008  f64f737f          MOV      r3,#0xff7f
00000c  4019              ANDS     r1,r1,r3
;;;1614     /* Enable or Disable the Output Compare Clear Bit */
;;;1615     tmpccmr2 |= TIM_OCClear;
00000e  4311              ORRS     r1,r1,r2
;;;1616     /* Write to TIMx CCMR2 register */
;;;1617     TIMx->CCMR2 = tmpccmr2;
000010  61c1              STR      r1,[r0,#0x1c]
;;;1618   }
000012  4770              BX       lr
;;;1619   
                          ENDP


                          AREA ||i.TIM_ClearOC4Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC4Ref PROC
;;;1629   */
;;;1630   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1631   {
;;;1632     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1633     
;;;1634     /* Check the parameters */
;;;1635     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1636     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1637     
;;;1638     tmpccmr2 = TIMx->CCMR2;
000004  69c3              LDR      r3,[r0,#0x1c]
000006  b299              UXTH     r1,r3
;;;1639     /* Reset the OC4CE Bit */
;;;1640     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);
000008  f3c1010e          UBFX     r1,r1,#0,#15
;;;1641     /* Enable or Disable the Output Compare Clear Bit */
;;;1642     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1643     /* Write to TIMx CCMR2 register */
;;;1644     TIMx->CCMR2 = tmpccmr2;
000016  61c1              STR      r1,[r0,#0x1c]
;;;1645   }
000018  4770              BX       lr
;;;1646   
                          ENDP


                          AREA ||i.TIM_Cmd||, CODE, READONLY, ALIGN=1

                  TIM_Cmd PROC
;;;557    */
;;;558    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L17.12|
;;;559    {
;;;560      /* Check the parameters */
;;;561      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;562      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;563      
;;;564      if (NewState != DISABLE)
;;;565      {
;;;566        /* Enable the TIM Counter */
;;;567        TIMx->CR1 |= TIM_CR1_CEN;
000002  6802              LDR      r2,[r0,#0]
000004  f0420201          ORR      r2,r2,#1
000008  6002              STR      r2,[r0,#0]
00000a  e004              B        |L17.22|
                  |L17.12|
;;;568      }
;;;569      else
;;;570      {
;;;571        /* Disable the TIM Counter */
;;;572        TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
00000c  6802              LDR      r2,[r0,#0]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  6002              STR      r2,[r0,#0]
                  |L17.22|
;;;573      }
;;;574    }
000016  4770              BX       lr
;;;575    
                          ENDP


                          AREA ||i.TIM_CounterModeConfig||, CODE, READONLY, ALIGN=1

                  TIM_CounterModeConfig PROC
;;;317    */
;;;318    void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
000000  460a              MOV      r2,r1
;;;319    {
;;;320      uint16_t tmpcr1 = 0;
000002  2100              MOVS     r1,#0
;;;321      
;;;322      /* Check the parameters */
;;;323      assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;324      assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;325      
;;;326      tmpcr1 = TIMx->CR1;
000004  6803              LDR      r3,[r0,#0]
000006  b299              UXTH     r1,r3
;;;327      /* Reset the CMS and DIR Bits */
;;;328      tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
000008  f64f738f          MOV      r3,#0xff8f
00000c  4019              ANDS     r1,r1,r3
;;;329      /* Set the Counter Mode */
;;;330      tmpcr1 |= TIM_CounterMode;
00000e  4311              ORRS     r1,r1,r2
;;;331      /* Write to TIMx CR1 register */
;;;332      TIMx->CR1 = tmpcr1;
000010  6001              STR      r1,[r0,#0]
;;;333    }
000012  4770              BX       lr
;;;334    
                          ENDP


                          AREA ||i.TIM_CtrlPWMOutputs||, CODE, READONLY, ALIGN=1

                  TIM_CtrlPWMOutputs PROC
;;;658    */
;;;659    void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L19.12|
;;;660    {
;;;661      /* Check the parameters */
;;;662      assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;663      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;664      if (NewState != DISABLE)
;;;665      {
;;;666        /* Enable the TIM Main Output */
;;;667        TIMx->BDTR |= TIM_BDTR_MOE;
000002  6c42              LDR      r2,[r0,#0x44]
000004  f4424200          ORR      r2,r2,#0x8000
000008  6442              STR      r2,[r0,#0x44]
00000a  e003              B        |L19.20|
                  |L19.12|
;;;668      }
;;;669      else
;;;670      {
;;;671        /* Disable the TIM Main Output */
;;;672        TIMx->BDTR &= (uint16_t)(~((uint16_t)TIM_BDTR_MOE));
00000c  6c42              LDR      r2,[r0,#0x44]
00000e  f3c2020e          UBFX     r2,r2,#0,#15
000012  6442              STR      r2,[r0,#0x44]
                  |L19.20|
;;;673      }  
;;;674    }
000014  4770              BX       lr
;;;675    
                          ENDP


                          AREA ||i.TIM_DMACmd||, CODE, READONLY, ALIGN=1

                  TIM_DMACmd PROC
;;;2594   */
;;;2595   void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;2596   { 
;;;2597     /* Check the parameters */
;;;2598     assert_param(IS_TIM_LIST10_PERIPH(TIMx));
;;;2599     assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;2600     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2601     
;;;2602     if (NewState != DISABLE)
000002  b11a              CBZ      r2,|L20.12|
;;;2603     {
;;;2604       /* Enable the DMA sources */
;;;2605       TIMx->DIER |= TIM_DMASource; 
000004  68c3              LDR      r3,[r0,#0xc]
000006  430b              ORRS     r3,r3,r1
000008  60c3              STR      r3,[r0,#0xc]
00000a  e004              B        |L20.22|
                  |L20.12|
;;;2606     }
;;;2607     else
;;;2608     {
;;;2609       /* Disable the DMA sources */
;;;2610       TIMx->DIER &= (uint16_t)~TIM_DMASource;
00000c  68c3              LDR      r3,[r0,#0xc]
00000e  43cc              MVNS     r4,r1
000010  b2a4              UXTH     r4,r4
000012  4023              ANDS     r3,r3,r4
000014  60c3              STR      r3,[r0,#0xc]
                  |L20.22|
;;;2611     }
;;;2612   }
000016  bd10              POP      {r4,pc}
;;;2613   
                          ENDP


                          AREA ||i.TIM_DMAConfig||, CODE, READONLY, ALIGN=1

                  TIM_DMAConfig PROC
;;;2565   */
;;;2566   void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
000000  ea410302          ORR      r3,r1,r2
;;;2567   {
;;;2568     /* Check the parameters */
;;;2569     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2570     assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
;;;2571     assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;2572     /* Set the DMA Base and the DMA Burst Length */
;;;2573     TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000004  6483              STR      r3,[r0,#0x48]
;;;2574   }
000006  4770              BX       lr
;;;2575   
                          ENDP


                          AREA ||i.TIM_DeInit||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;181    */
;;;182    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  b510              PUSH     {r4,lr}
;;;183    {
000002  4604              MOV      r4,r0
;;;184      /* Check the parameters */
;;;185      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;186      
;;;187      if (TIMx == TIM1)
000004  4817              LDR      r0,|L22.100|
000006  4284              CMP      r4,r0
000008  d108              BNE      |L22.28|
;;;188      {
;;;189        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;190        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
000012  2100              MOVS     r1,#0
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       RCC_APB2PeriphResetCmd
00001a  e022              B        |L22.98|
                  |L22.28|
;;;191      }     
;;;192    
;;;193      else if (TIMx == TIM3)
00001c  f1b44f80          CMP      r4,#0x40000000
000020  d108              BNE      |L22.52|
;;;194      {
;;;195        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
000022  2101              MOVS     r1,#1
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;196        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
00002a  2100              MOVS     r1,#0
00002c  2001              MOVS     r0,#1
00002e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000032  e016              B        |L22.98|
                  |L22.52|
;;;197      }
;;;198      
;;;199      else if (TIMx == TIM6)
000034  480c              LDR      r0,|L22.104|
000036  4284              CMP      r4,r0
000038  d108              BNE      |L22.76|
;;;200      {
;;;201        RCC_APB2PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
00003a  2101              MOVS     r1,#1
00003c  2008              MOVS     r0,#8
00003e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;202        RCC_APB2PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
000042  2100              MOVS     r1,#0
000044  2008              MOVS     r0,#8
000046  f7fffffe          BL       RCC_APB2PeriphResetCmd
00004a  e00a              B        |L22.98|
                  |L22.76|
;;;203      } 
;;;204      else
;;;205      {
;;;206        if (TIMx == TIM7)
00004c  4807              LDR      r0,|L22.108|
00004e  4284              CMP      r4,r0
000050  d107              BNE      |L22.98|
;;;207        {
;;;208          RCC_APB2PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
000052  2101              MOVS     r1,#1
000054  2010              MOVS     r0,#0x10
000056  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;209          RCC_APB2PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
00005a  2100              MOVS     r1,#0
00005c  2010              MOVS     r0,#0x10
00005e  f7fffffe          BL       RCC_APB2PeriphResetCmd
                  |L22.98|
;;;210        }  
;;;211      }
;;;212      
;;;213    }
000062  bd10              POP      {r4,pc}
;;;214    
                          ENDP

                  |L22.100|
                          DCD      0x40010000
                  |L22.104|
                          DCD      0x40000c00
                  |L22.108|
                          DCD      0x40001000

                          AREA ||i.TIM_ETRClockMode1Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode1Config PROC
;;;2750   */
;;;2751   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2752                                uint16_t ExtTRGFilter)
;;;2753   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;2754     uint16_t tmpsmcr = 0;
00000c  2400              MOVS     r4,#0
;;;2755     
;;;2756     /* Check the parameters */
;;;2757     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2758     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2759     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2760     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2761     
;;;2762     /* Configure the ETR Clock source */
;;;2763     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
00000e  4643              MOV      r3,r8
000010  463a              MOV      r2,r7
000012  4631              MOV      r1,r6
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       TIM_ETRConfig
;;;2764     
;;;2765     /* Get the TIMx SMCR register value */
;;;2766     tmpsmcr = TIMx->SMCR;
00001a  68a8              LDR      r0,[r5,#8]
00001c  b284              UXTH     r4,r0
;;;2767     /* Reset the SMS Bits */
;;;2768     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
00001e  f64f70f8          MOV      r0,#0xfff8
000022  4004              ANDS     r4,r4,r0
;;;2769     /* Select the External clock mode1 */
;;;2770     tmpsmcr |= TIM_SlaveMode_External1;
000024  f0440407          ORR      r4,r4,#7
;;;2771     /* Select the Trigger selection : ETRF */
;;;2772     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
000028  f64f708f          MOV      r0,#0xff8f
00002c  4004              ANDS     r4,r4,r0
;;;2773     tmpsmcr |= TIM_TS_ETRF;
00002e  f0440470          ORR      r4,r4,#0x70
;;;2774     /* Write to TIMx SMCR */
;;;2775     TIMx->SMCR = tmpsmcr;
000032  60ac              STR      r4,[r5,#8]
;;;2776   }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;2777   
                          ENDP


                          AREA ||i.TIM_ETRClockMode2Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode2Config PROC
;;;2795   */
;;;2796   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
000000  b5f0              PUSH     {r4-r7,lr}
;;;2797                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;2798   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;2799     /* Check the parameters */
;;;2800     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2801     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2802     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2803     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2804     
;;;2805     /* Configure the ETR Clock source */
;;;2806     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
00000a  463b              MOV      r3,r7
00000c  4632              MOV      r2,r6
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       TIM_ETRConfig
;;;2807     /* Enable the External clock mode2 */
;;;2808     TIMx->SMCR |= TIM_SMCR_ECE;
000016  68a0              LDR      r0,[r4,#8]
000018  f4404080          ORR      r0,r0,#0x4000
00001c  60a0              STR      r0,[r4,#8]
;;;2809   }
00001e  bdf0              POP      {r4-r7,pc}
;;;2810   
                          ENDP


                          AREA ||i.TIM_ETRConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETRConfig PROC
;;;2982   */
;;;2983   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000000  b530              PUSH     {r4,r5,lr}
;;;2984                      uint16_t ExtTRGFilter)
;;;2985   {
000002  460c              MOV      r4,r1
;;;2986     uint16_t tmpsmcr = 0;
000004  2100              MOVS     r1,#0
;;;2987     
;;;2988     /* Check the parameters */
;;;2989     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2990     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2991     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2992     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2993     
;;;2994     tmpsmcr = TIMx->SMCR;
000006  6885              LDR      r5,[r0,#8]
000008  b2a9              UXTH     r1,r5
;;;2995     /* Reset the ETR Bits */
;;;2996     tmpsmcr &= SMCR_ETR_MASK;
00000a  b2c9              UXTB     r1,r1
;;;2997     /* Set the Prescaler, the Filter value and the Polarity */
;;;2998     tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
00000c  f64f75ff          MOV      r5,#0xffff
000010  ea052503          AND      r5,r5,r3,LSL #8
000014  4315              ORRS     r5,r5,r2
000016  4325              ORRS     r5,r5,r4
000018  4329              ORRS     r1,r1,r5
;;;2999     /* Write to TIMx SMCR */
;;;3000     TIMx->SMCR = tmpsmcr;
00001a  6081              STR      r1,[r0,#8]
;;;3001   }
00001c  bd30              POP      {r4,r5,pc}
;;;3002   
                          ENDP


                          AREA ||i.TIM_EncoderInterfaceConfig||, CODE, READONLY, ALIGN=1

                  TIM_EncoderInterfaceConfig PROC
;;;3038   */
;;;3039   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3040                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;3041   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
000006  461e              MOV      r6,r3
;;;3042     uint16_t tmpsmcr = 0;
000008  2100              MOVS     r1,#0
;;;3043     uint16_t tmpccmr1 = 0;
00000a  2200              MOVS     r2,#0
;;;3044     uint16_t tmpccer = 0;
00000c  2300              MOVS     r3,#0
;;;3045     
;;;3046     /* Check the parameters */
;;;3047     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;3048     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;3049     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;3050     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;3051     
;;;3052     /* Get the TIMx SMCR register value */
;;;3053     tmpsmcr = TIMx->SMCR;
00000e  6887              LDR      r7,[r0,#8]
000010  b2b9              UXTH     r1,r7
;;;3054     /* Get the TIMx CCMR1 register value */
;;;3055     tmpccmr1 = TIMx->CCMR1;
000012  6987              LDR      r7,[r0,#0x18]
000014  b2ba              UXTH     r2,r7
;;;3056     /* Get the TIMx CCER register value */
;;;3057     tmpccer = TIMx->CCER;
000016  6a07              LDR      r7,[r0,#0x20]
000018  b2bb              UXTH     r3,r7
;;;3058     /* Set the encoder Mode */
;;;3059     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
00001a  f64f77f8          MOV      r7,#0xfff8
00001e  4039              ANDS     r1,r1,r7
;;;3060     tmpsmcr |= TIM_EncoderMode;
000020  4321              ORRS     r1,r1,r4
;;;3061     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;3062     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
000022  f64f47fc          MOV      r7,#0xfcfc
000026  403a              ANDS     r2,r2,r7
;;;3063     tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
000028  f2401701          MOV      r7,#0x101
00002c  433a              ORRS     r2,r2,r7
;;;3064     /* Set the TI1 and the TI2 Polarities */
;;;3065     tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP)) & (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
00002e  f64f7755          MOV      r7,#0xff55
000032  403b              ANDS     r3,r3,r7
;;;3066     tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
000034  f64f77ff          MOV      r7,#0xffff
000038  ea071706          AND      r7,r7,r6,LSL #4
00003c  432f              ORRS     r7,r7,r5
00003e  433b              ORRS     r3,r3,r7
;;;3067     /* Write to TIMx SMCR */
;;;3068     TIMx->SMCR = tmpsmcr;
000040  6081              STR      r1,[r0,#8]
;;;3069     /* Write to TIMx CCMR1 */
;;;3070     TIMx->CCMR1 = tmpccmr1;
000042  6182              STR      r2,[r0,#0x18]
;;;3071     /* Write to TIMx CCER */
;;;3072     TIMx->CCER = tmpccer;
000044  6203              STR      r3,[r0,#0x20]
;;;3073   }
000046  bdf0              POP      {r4-r7,pc}
;;;3074   
                          ENDP


                          AREA ||i.TIM_ForcedOC1Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC1Config PROC
;;;1199   */
;;;1200   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1201   {
;;;1202     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1203     /* Check the parameters */
;;;1204     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1205     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1206     tmpccmr1 = TIMx->CCMR1;
000004  6983              LDR      r3,[r0,#0x18]
000006  b299              UXTH     r1,r3
;;;1207     /* Reset the OC1M Bits */
;;;1208     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1M);
000008  f64f738f          MOV      r3,#0xff8f
00000c  4019              ANDS     r1,r1,r3
;;;1209     /* Configure The Forced output Mode */
;;;1210     tmpccmr1 |= TIM_ForcedAction;
00000e  4311              ORRS     r1,r1,r2
;;;1211     /* Write to TIMx CCMR1 register */
;;;1212     TIMx->CCMR1 = tmpccmr1;
000010  6181              STR      r1,[r0,#0x18]
;;;1213   }
000012  4770              BX       lr
;;;1214   
                          ENDP


                          AREA ||i.TIM_ForcedOC2Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC2Config PROC
;;;1224   */
;;;1225   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1226   {
;;;1227     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1228     
;;;1229     /* Check the parameters */
;;;1230     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1231     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1232     
;;;1233     tmpccmr1 = TIMx->CCMR1;
000004  6983              LDR      r3,[r0,#0x18]
000006  b299              UXTH     r1,r3
;;;1234     /* Reset the OC2M Bits */
;;;1235     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);
000008  f64873ff          MOV      r3,#0x8fff
00000c  4019              ANDS     r1,r1,r3
;;;1236     /* Configure The Forced output Mode */
;;;1237     tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
00000e  f64f73ff          MOV      r3,#0xffff
000012  ea032302          AND      r3,r3,r2,LSL #8
000016  4319              ORRS     r1,r1,r3
;;;1238     /* Write to TIMx CCMR1 register */
;;;1239     TIMx->CCMR1 = tmpccmr1;
000018  6181              STR      r1,[r0,#0x18]
;;;1240   }
00001a  4770              BX       lr
;;;1241   
                          ENDP


                          AREA ||i.TIM_ForcedOC3Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC3Config PROC
;;;1251   */
;;;1252   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1253   {
;;;1254     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1255     
;;;1256     /* Check the parameters */
;;;1257     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1258     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1259     
;;;1260     tmpccmr2 = TIMx->CCMR2;
000004  69c3              LDR      r3,[r0,#0x1c]
000006  b299              UXTH     r1,r3
;;;1261     /* Reset the OC1M Bits */
;;;1262     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3M);
000008  f64f738f          MOV      r3,#0xff8f
00000c  4019              ANDS     r1,r1,r3
;;;1263     /* Configure The Forced output Mode */
;;;1264     tmpccmr2 |= TIM_ForcedAction;
00000e  4311              ORRS     r1,r1,r2
;;;1265     /* Write to TIMx CCMR2 register */
;;;1266     TIMx->CCMR2 = tmpccmr2;
000010  61c1              STR      r1,[r0,#0x1c]
;;;1267   }
000012  4770              BX       lr
;;;1268   
                          ENDP


                          AREA ||i.TIM_ForcedOC4Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC4Config PROC
;;;1278   */
;;;1279   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1280   {
;;;1281     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1282     /* Check the parameters */
;;;1283     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1284     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1285     
;;;1286     tmpccmr2 = TIMx->CCMR2;
000004  69c3              LDR      r3,[r0,#0x1c]
000006  b299              UXTH     r1,r3
;;;1287     /* Reset the OC2M Bits */
;;;1288     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4M);
000008  f64873ff          MOV      r3,#0x8fff
00000c  4019              ANDS     r1,r1,r3
;;;1289     /* Configure The Forced output Mode */
;;;1290     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
00000e  f64f73ff          MOV      r3,#0xffff
000012  ea032302          AND      r3,r3,r2,LSL #8
000016  4319              ORRS     r1,r1,r3
;;;1291     /* Write to TIMx CCMR2 register */
;;;1292     TIMx->CCMR2 = tmpccmr2;
000018  61c1              STR      r1,[r0,#0x1c]
;;;1293   }
00001a  4770              BX       lr
;;;1294   
                          ENDP


                          AREA ||i.TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  TIM_GenerateEvent PROC
;;;2357   */
;;;2358   void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
000000  6141              STR      r1,[r0,#0x14]
;;;2359   { 
;;;2360     /* Check the parameters */
;;;2361     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2362     assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource)); 
;;;2363     /* Set the event sources */
;;;2364     TIMx->EGR = TIM_EventSource;
;;;2365   }
000002  4770              BX       lr
;;;2366   
                          ENDP


                          AREA ||i.TIM_GetCapture1||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture1 PROC
;;;2123   */
;;;2124   uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2125   {
;;;2126     /* Check the parameters */
;;;2127     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2128     
;;;2129     /* Get the Capture 1 Register value */
;;;2130     return TIMx->CCR1;
000002  6b48              LDR      r0,[r1,#0x34]
;;;2131   }
000004  4770              BX       lr
;;;2132   
                          ENDP


                          AREA ||i.TIM_GetCapture2||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture2 PROC
;;;2137   */
;;;2138   uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2139   {
;;;2140     /* Check the parameters */
;;;2141     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2142     
;;;2143     /* Get the Capture 2 Register value */
;;;2144     return TIMx->CCR2;
000002  6b88              LDR      r0,[r1,#0x38]
;;;2145   }
000004  4770              BX       lr
;;;2146   
                          ENDP


                          AREA ||i.TIM_GetCapture3||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture3 PROC
;;;2152   */
;;;2153   uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2154   {
;;;2155     /* Check the parameters */
;;;2156     assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;2157     
;;;2158     /* Get the Capture 3 Register value */
;;;2159     return TIMx->CCR3;
000002  6bc8              LDR      r0,[r1,#0x3c]
;;;2160   }
000004  4770              BX       lr
;;;2161   
                          ENDP


                          AREA ||i.TIM_GetCapture4||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture4 PROC
;;;2167   */
;;;2168   uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2169   {
;;;2170     /* Check the parameters */
;;;2171     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2172     
;;;2173     /* Get the Capture 4 Register value */
;;;2174     return TIMx->CCR4;
000002  6c08              LDR      r0,[r1,#0x40]
;;;2175   }
000004  4770              BX       lr
;;;2176   
                          ENDP


                          AREA ||i.TIM_GetCounter||, CODE, READONLY, ALIGN=1

                  TIM_GetCounter PROC
;;;380    */
;;;381    uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;382    {
;;;383      /* Check the parameters */
;;;384      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;385      
;;;386      /* Get the Counter Register value */
;;;387      return TIMx->CNT;
000002  6a48              LDR      r0,[r1,#0x24]
;;;388    }
000004  4770              BX       lr
;;;389    
                          ENDP


                          AREA ||i.TIM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetFlagStatus PROC
;;;2395   */
;;;2396   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  4602              MOV      r2,r0
;;;2397   { 
;;;2398     ITStatus bitstatus = RESET; 
000002  2000              MOVS     r0,#0
;;;2399     
;;;2400     /* Check the parameters */
;;;2401     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2402     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2403     
;;;2404     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000004  6913              LDR      r3,[r2,#0x10]
000006  400b              ANDS     r3,r3,r1
000008  b10b              CBZ      r3,|L37.14|
;;;2405     {
;;;2406       bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L37.16|
                  |L37.14|
;;;2407     }
;;;2408     else
;;;2409     {
;;;2410       bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L37.16|
;;;2411     }
;;;2412     return bitstatus;
;;;2413   }
000010  4770              BX       lr
;;;2414   
                          ENDP


                          AREA ||i.TIM_GetITStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetITStatus PROC
;;;2479   */
;;;2480   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;2481   {
000002  4602              MOV      r2,r0
;;;2482     ITStatus bitstatus = RESET;  
000004  2000              MOVS     r0,#0
;;;2483     uint16_t itstatus = 0x0, itenable = 0x0;
000006  2300              MOVS     r3,#0
000008  2400              MOVS     r4,#0
;;;2484     
;;;2485     /* Check the parameters */
;;;2486     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2487     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2488     
;;;2489     itstatus = TIMx->SR & TIM_IT;
00000a  6915              LDR      r5,[r2,#0x10]
00000c  ea050301          AND      r3,r5,r1
;;;2490     
;;;2491     itenable = TIMx->DIER & TIM_IT;
000010  68d5              LDR      r5,[r2,#0xc]
000012  ea050401          AND      r4,r5,r1
;;;2492     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
000016  b113              CBZ      r3,|L38.30|
000018  b10c              CBZ      r4,|L38.30|
;;;2493     {
;;;2494       bitstatus = SET;
00001a  2001              MOVS     r0,#1
00001c  e000              B        |L38.32|
                  |L38.30|
;;;2495     }
;;;2496     else
;;;2497     {
;;;2498       bitstatus = RESET;
00001e  2000              MOVS     r0,#0
                  |L38.32|
;;;2499     }
;;;2500     return bitstatus;
;;;2501   }
000020  bd30              POP      {r4,r5,pc}
;;;2502   
                          ENDP


                          AREA ||i.TIM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  TIM_GetPrescaler PROC
;;;398    */
;;;399    uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;400    {
;;;401      /* Check the parameters */
;;;402      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;403      
;;;404      /* Get the Prescaler Register value */
;;;405      return TIMx->PSC;
000002  6a88              LDR      r0,[r1,#0x28]
000004  b280              UXTH     r0,r0
;;;406    }
000006  4770              BX       lr
;;;407    
                          ENDP


                          AREA ||i.TIM_ICInit||, CODE, READONLY, ALIGN=1

                  TIM_ICInit PROC
;;;1989   */
;;;1990   void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;1991   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1992     /* Check the parameters */
;;;1993     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1994     assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));  
;;;1995     assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;1996     assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;1997     assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;1998     assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;1999     
;;;2000     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000006  8820              LDRH     r0,[r4,#0]
000008  b950              CBNZ     r0,|L40.32|
;;;2001     {
;;;2002       assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2003       /* TI1 Configuration */
;;;2004       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
00000a  8923              LDRH     r3,[r4,#8]
00000c  88a2              LDRH     r2,[r4,#4]
00000e  8861              LDRH     r1,[r4,#2]
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       TI1_Config
;;;2005                  TIM_ICInitStruct->TIM_ICSelection,
;;;2006                  TIM_ICInitStruct->TIM_ICFilter);
;;;2007       /* Set the Input Capture Prescaler value */
;;;2008       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000016  88e1              LDRH     r1,[r4,#6]
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       TIM_SetIC1Prescaler
00001e  e025              B        |L40.108|
                  |L40.32|
;;;2009     }
;;;2010     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000020  8820              LDRH     r0,[r4,#0]
000022  2804              CMP      r0,#4
000024  d10a              BNE      |L40.60|
;;;2011     {
;;;2012       assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2013       /* TI2 Configuration */
;;;2014       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000026  8923              LDRH     r3,[r4,#8]
000028  88a2              LDRH     r2,[r4,#4]
00002a  8861              LDRH     r1,[r4,#2]
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       TI2_Config
;;;2015                  TIM_ICInitStruct->TIM_ICSelection,
;;;2016                  TIM_ICInitStruct->TIM_ICFilter);
;;;2017       /* Set the Input Capture Prescaler value */
;;;2018       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000032  88e1              LDRH     r1,[r4,#6]
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       TIM_SetIC2Prescaler
00003a  e017              B        |L40.108|
                  |L40.60|
;;;2019     }
;;;2020     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
00003c  8820              LDRH     r0,[r4,#0]
00003e  2808              CMP      r0,#8
000040  d10a              BNE      |L40.88|
;;;2021     {
;;;2022       assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2023       /* TI3 Configuration */
;;;2024       TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
000042  8923              LDRH     r3,[r4,#8]
000044  88a2              LDRH     r2,[r4,#4]
000046  8861              LDRH     r1,[r4,#2]
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       TI3_Config
;;;2025                  TIM_ICInitStruct->TIM_ICSelection,
;;;2026                  TIM_ICInitStruct->TIM_ICFilter);
;;;2027       /* Set the Input Capture Prescaler value */
;;;2028       TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00004e  88e1              LDRH     r1,[r4,#6]
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       TIM_SetIC3Prescaler
000056  e009              B        |L40.108|
                  |L40.88|
;;;2029     }
;;;2030     else
;;;2031     {
;;;2032       assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2033       /* TI4 Configuration */
;;;2034       TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000058  8923              LDRH     r3,[r4,#8]
00005a  88a2              LDRH     r2,[r4,#4]
00005c  8861              LDRH     r1,[r4,#2]
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       TI4_Config
;;;2035                  TIM_ICInitStruct->TIM_ICSelection,
;;;2036                  TIM_ICInitStruct->TIM_ICFilter);
;;;2037       /* Set the Input Capture Prescaler value */
;;;2038       TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000064  88e1              LDRH     r1,[r4,#6]
000066  4628              MOV      r0,r5
000068  f7fffffe          BL       TIM_SetIC4Prescaler
                  |L40.108|
;;;2039     }
;;;2040   }
00006c  bd70              POP      {r4-r6,pc}
;;;2041   
                          ENDP


                          AREA ||i.TIM_ICStructInit||, CODE, READONLY, ALIGN=1

                  TIM_ICStructInit PROC
;;;2047   */
;;;2048   void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  2100              MOVS     r1,#0
;;;2049   {
;;;2050     /* Set the default configuration */
;;;2051     TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000002  8001              STRH     r1,[r0,#0]
;;;2052     TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
000004  8041              STRH     r1,[r0,#2]
;;;2053     TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
000006  2101              MOVS     r1,#1
000008  8081              STRH     r1,[r0,#4]
;;;2054     TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
00000a  2100              MOVS     r1,#0
00000c  80c1              STRH     r1,[r0,#6]
;;;2055     TIM_ICInitStruct->TIM_ICFilter = 0x00;
00000e  8101              STRH     r1,[r0,#8]
;;;2056   }
000010  4770              BX       lr
;;;2057   
                          ENDP


                          AREA ||i.TIM_ITConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITConfig PROC
;;;2315   */
;;;2316   void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;2317   {  
;;;2318     /* Check the parameters */
;;;2319     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2320     assert_param(IS_TIM_IT(TIM_IT));
;;;2321     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2322     
;;;2323     if (NewState != DISABLE)
000002  b11a              CBZ      r2,|L42.12|
;;;2324     {
;;;2325       /* Enable the Interrupt sources */
;;;2326       TIMx->DIER |= TIM_IT;
000004  68c3              LDR      r3,[r0,#0xc]
000006  430b              ORRS     r3,r3,r1
000008  60c3              STR      r3,[r0,#0xc]
00000a  e004              B        |L42.22|
                  |L42.12|
;;;2327     }
;;;2328     else
;;;2329     {
;;;2330       /* Disable the Interrupt sources */
;;;2331       TIMx->DIER &= (uint16_t)~TIM_IT;
00000c  68c3              LDR      r3,[r0,#0xc]
00000e  43cc              MVNS     r4,r1
000010  b2a4              UXTH     r4,r4
000012  4023              ANDS     r3,r3,r4
000014  60c3              STR      r3,[r0,#0xc]
                  |L42.22|
;;;2332     }
;;;2333   }
000016  bd10              POP      {r4,pc}
;;;2334   
                          ENDP


                          AREA ||i.TIM_ITRxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRxExternalClockConfig PROC
;;;2681   */
;;;2682   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  b530              PUSH     {r4,r5,lr}
;;;2683   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2684     /* Check the parameters */
;;;2685     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2686     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2687     /* Select the Internal Trigger */
;;;2688     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       TIM_SelectInputTrigger
;;;2689     /* Select the External clock mode1 */
;;;2690     TIMx->SMCR |= TIM_SlaveMode_External1;
00000e  68a0              LDR      r0,[r4,#8]
000010  f0400007          ORR      r0,r0,#7
000014  60a0              STR      r0,[r4,#8]
;;;2691   }
000016  bd30              POP      {r4,r5,pc}
;;;2692   
                          ENDP


                          AREA ||i.TIM_InternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_InternalClockConfig PROC
;;;2661   */
;;;2662   void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
000000  6881              LDR      r1,[r0,#8]
;;;2663   {
;;;2664     /* Check the parameters */
;;;2665     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2666     /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;2667     TIMx->SMCR &=  (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
000002  f64f72f8          MOV      r2,#0xfff8
000006  4011              ANDS     r1,r1,r2
000008  6081              STR      r1,[r0,#8]
;;;2668   }
00000a  4770              BX       lr
;;;2669   
                          ENDP


                          AREA ||i.TIM_OC1FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1FastConfig PROC
;;;1436   */
;;;1437   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1438   {
;;;1439     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1440     
;;;1441     /* Check the parameters */
;;;1442     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1443     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1444     
;;;1445     /* Get the TIMx CCMR1 register value */
;;;1446     tmpccmr1 = TIMx->CCMR1;
000004  6983              LDR      r3,[r0,#0x18]
000006  b299              UXTH     r1,r3
;;;1447     /* Reset the OC1FE Bit */
;;;1448     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1FE);
000008  f64f73fb          MOV      r3,#0xfffb
00000c  4019              ANDS     r1,r1,r3
;;;1449     /* Enable or Disable the Output Compare Fast Bit */
;;;1450     tmpccmr1 |= TIM_OCFast;
00000e  4311              ORRS     r1,r1,r2
;;;1451     /* Write to TIMx CCMR1 */
;;;1452     TIMx->CCMR1 = tmpccmr1;
000010  6181              STR      r1,[r0,#0x18]
;;;1453   }
000012  4770              BX       lr
;;;1454   
                          ENDP


                          AREA ||i.TIM_OC1Init||, CODE, READONLY, ALIGN=2

                  TIM_OC1Init PROC
;;;731    */
;;;732    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;733    {
;;;734      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;735      
;;;736      /* Check the parameters */
;;;737      assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;738      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;739      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;740      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;741      /* Disable the Channel 1: Reset the CC1E Bit */
;;;742      TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
000008  6a05              LDR      r5,[r0,#0x20]
00000a  f64f76fe          MOV      r6,#0xfffe
00000e  4035              ANDS     r5,r5,r6
000010  6205              STR      r5,[r0,#0x20]
;;;743      /* Get the TIMx CCER register value */
;;;744      tmpccer = TIMx->CCER;
000012  6a05              LDR      r5,[r0,#0x20]
000014  b2aa              UXTH     r2,r5
;;;745      /* Get the TIMx CR2 register value */
;;;746      tmpcr2 =  TIMx->CR2;
000016  6845              LDR      r5,[r0,#4]
000018  b2ab              UXTH     r3,r5
;;;747      
;;;748      /* Get the TIMx CCMR1 register value */
;;;749      tmpccmrx = TIMx->CCMR1;
00001a  6985              LDR      r5,[r0,#0x18]
00001c  b2ac              UXTH     r4,r5
;;;750      
;;;751      /* Reset the Output Compare Mode Bits */
;;;752      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
00001e  f64f758f          MOV      r5,#0xff8f
000022  402c              ANDS     r4,r4,r5
;;;753      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));
000024  1eb5              SUBS     r5,r6,#2
000026  402c              ANDS     r4,r4,r5
;;;754      
;;;755      /* Select the Output Compare Mode */
;;;756      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000028  880d              LDRH     r5,[r1,#0]
00002a  432c              ORRS     r4,r4,r5
;;;757      
;;;758      /* Reset the Output Polarity level */
;;;759      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
00002c  1e75              SUBS     r5,r6,#1
00002e  402a              ANDS     r2,r2,r5
;;;760      /* Set the Output Compare Polarity */
;;;761      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
000030  898d              LDRH     r5,[r1,#0xc]
000032  432a              ORRS     r2,r2,r5
;;;762      
;;;763      /* Set the Output State */
;;;764      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
000034  884d              LDRH     r5,[r1,#2]
000036  432a              ORRS     r2,r2,r5
;;;765      
;;;766      if((TIMx == TIM1) || (TIMx == TIM6) || (TIMx == TIM7))
000038  4d11              LDR      r5,|L46.128|
00003a  42a8              CMP      r0,r5
00003c  d005              BEQ      |L46.74|
00003e  4d11              LDR      r5,|L46.132|
000040  42a8              CMP      r0,r5
000042  d002              BEQ      |L46.74|
000044  4d10              LDR      r5,|L46.136|
000046  42a8              CMP      r0,r5
000048  d113              BNE      |L46.114|
                  |L46.74|
;;;767      {
;;;768        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;769        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;770        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;771        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;772        
;;;773        /* Reset the Output N Polarity level */
;;;774        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));
00004a  f64f75f7          MOV      r5,#0xfff7
00004e  402a              ANDS     r2,r2,r5
;;;775        /* Set the Output N Polarity */
;;;776        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
000050  89cd              LDRH     r5,[r1,#0xe]
000052  432a              ORRS     r2,r2,r5
;;;777        
;;;778        /* Reset the Output N State */
;;;779        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NE));    
000054  f64f75fb          MOV      r5,#0xfffb
000058  402a              ANDS     r2,r2,r5
;;;780        /* Set the Output N State */
;;;781        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
00005a  888d              LDRH     r5,[r1,#4]
00005c  432a              ORRS     r2,r2,r5
;;;782        
;;;783        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;784        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1));
00005e  f64f65ff          MOV      r5,#0xfeff
000062  402b              ANDS     r3,r3,r5
;;;785        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1N));
000064  f64f55ff          MOV      r5,#0xfdff
000068  402b              ANDS     r3,r3,r5
;;;786        
;;;787        /* Set the Output Idle state */
;;;788        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
00006a  8a0d              LDRH     r5,[r1,#0x10]
00006c  432b              ORRS     r3,r3,r5
;;;789        /* Set the Output N Idle state */
;;;790        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
00006e  8a4d              LDRH     r5,[r1,#0x12]
000070  432b              ORRS     r3,r3,r5
                  |L46.114|
;;;791      }
;;;792      /* Write to TIMx CR2 */
;;;793      TIMx->CR2 = tmpcr2;
000072  6043              STR      r3,[r0,#4]
;;;794      
;;;795      /* Write to TIMx CCMR1 */
;;;796      TIMx->CCMR1 = tmpccmrx;
000074  6184              STR      r4,[r0,#0x18]
;;;797      
;;;798      /* Set the Capture Compare Register value */
;;;799      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse; 
000076  688d              LDR      r5,[r1,#8]
000078  6345              STR      r5,[r0,#0x34]
;;;800      
;;;801      /* Write to TIMx CCER */
;;;802      TIMx->CCER = tmpccer;
00007a  6202              STR      r2,[r0,#0x20]
;;;803    }
00007c  bd70              POP      {r4-r6,pc}
;;;804    
                          ENDP

00007e  0000              DCW      0x0000
                  |L46.128|
                          DCD      0x40010000
                  |L46.132|
                          DCD      0x40000c00
                  |L46.136|
                          DCD      0x40001000

                          AREA ||i.TIM_OC1NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1NPolarityConfig PROC
;;;1681   */
;;;1682   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;1683   {
;;;1684     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1685     /* Check the parameters */
;;;1686     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1687     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1688     
;;;1689     tmpccer = TIMx->CCER;
000004  6a03              LDR      r3,[r0,#0x20]
000006  b299              UXTH     r1,r3
;;;1690     /* Set or Reset the CC1NP Bit */
;;;1691     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1NP);
000008  f64f73f7          MOV      r3,#0xfff7
00000c  4019              ANDS     r1,r1,r3
;;;1692     tmpccer |= TIM_OCNPolarity;
00000e  4311              ORRS     r1,r1,r2
;;;1693     /* Write to TIMx CCER register */
;;;1694     TIMx->CCER = tmpccer;
000010  6201              STR      r1,[r0,#0x20]
;;;1695   }
000012  4770              BX       lr
;;;1696   
                          ENDP


                          AREA ||i.TIM_OC1PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PolarityConfig PROC
;;;1656   */
;;;1657   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1658   {
;;;1659     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1660     
;;;1661     /* Check the parameters */
;;;1662     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1663     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1664     
;;;1665     tmpccer = TIMx->CCER;
000004  6a03              LDR      r3,[r0,#0x20]
000006  b299              UXTH     r1,r3
;;;1666     /* Set or Reset the CC1P Bit */
;;;1667     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1P);
000008  f64f73fd          MOV      r3,#0xfffd
00000c  4019              ANDS     r1,r1,r3
;;;1668     tmpccer |= TIM_OCPolarity;
00000e  4311              ORRS     r1,r1,r2
;;;1669     /* Write to TIMx CCER register */
;;;1670     TIMx->CCER = tmpccer;
000010  6201              STR      r1,[r0,#0x20]
;;;1671   }
000012  4770              BX       lr
;;;1672   
                          ENDP


                          AREA ||i.TIM_OC1PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PreloadConfig PROC
;;;1330   */
;;;1331   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1332   {
;;;1333     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1334     /* Check the parameters */
;;;1335     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1336     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1337     
;;;1338     tmpccmr1 = TIMx->CCMR1;
000004  6983              LDR      r3,[r0,#0x18]
000006  b299              UXTH     r1,r3
;;;1339     /* Reset the OC1PE Bit */
;;;1340     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
000008  f64f73f7          MOV      r3,#0xfff7
00000c  4019              ANDS     r1,r1,r3
;;;1341     /* Enable or Disable the Output Compare Preload feature */
;;;1342     tmpccmr1 |= TIM_OCPreload;
00000e  4311              ORRS     r1,r1,r2
;;;1343     /* Write to TIMx CCMR1 register */
;;;1344     TIMx->CCMR1 = tmpccmr1;
000010  6181              STR      r1,[r0,#0x18]
;;;1345   }
000012  4770              BX       lr
;;;1346   
                          ENDP


                          AREA ||i.TIM_OC2FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2FastConfig PROC
;;;1464   */
;;;1465   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1466   {
;;;1467     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1468     
;;;1469     /* Check the parameters */
;;;1470     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1471     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1472     
;;;1473     /* Get the TIMx CCMR1 register value */
;;;1474     tmpccmr1 = TIMx->CCMR1;
000004  6983              LDR      r3,[r0,#0x18]
000006  b299              UXTH     r1,r3
;;;1475     /* Reset the OC2FE Bit */
;;;1476     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);
000008  f64f33ff          MOV      r3,#0xfbff
00000c  4019              ANDS     r1,r1,r3
;;;1477     /* Enable or Disable the Output Compare Fast Bit */
;;;1478     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
00000e  f64f73ff          MOV      r3,#0xffff
000012  ea032302          AND      r3,r3,r2,LSL #8
000016  4319              ORRS     r1,r1,r3
;;;1479     /* Write to TIMx CCMR1 */
;;;1480     TIMx->CCMR1 = tmpccmr1;
000018  6181              STR      r1,[r0,#0x18]
;;;1481   }
00001a  4770              BX       lr
;;;1482   
                          ENDP


                          AREA ||i.TIM_OC2Init||, CODE, READONLY, ALIGN=2

                  TIM_OC2Init PROC
;;;814    */
;;;815    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;816    {
;;;817      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;818      
;;;819      /* Check the parameters */
;;;820      assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
;;;821      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;822      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;823      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;824      /* Disable the Channel 2: Reset the CC2E Bit */
;;;825      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
000008  6a05              LDR      r5,[r0,#0x20]
00000a  f64f76ef          MOV      r6,#0xffef
00000e  4035              ANDS     r5,r5,r6
000010  6205              STR      r5,[r0,#0x20]
;;;826      
;;;827      /* Get the TIMx CCER register value */  
;;;828      tmpccer = TIMx->CCER;
000012  6a05              LDR      r5,[r0,#0x20]
000014  b2aa              UXTH     r2,r5
;;;829      /* Get the TIMx CR2 register value */
;;;830      tmpcr2 =  TIMx->CR2;
000016  6845              LDR      r5,[r0,#4]
000018  b2ab              UXTH     r3,r5
;;;831      
;;;832      /* Get the TIMx CCMR1 register value */
;;;833      tmpccmrx = TIMx->CCMR1;
00001a  6985              LDR      r5,[r0,#0x18]
00001c  b2ac              UXTH     r4,r5
;;;834      
;;;835      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;836      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
00001e  f64875ff          MOV      r5,#0x8fff
000022  402c              ANDS     r4,r4,r5
;;;837      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
000024  f64f45ff          MOV      r5,#0xfcff
000028  402c              ANDS     r4,r4,r5
;;;838      
;;;839      /* Select the Output Compare Mode */
;;;840      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
00002a  880d              LDRH     r5,[r1,#0]
00002c  f64f76ff          MOV      r6,#0xffff
000030  ea062505          AND      r5,r6,r5,LSL #8
000034  432c              ORRS     r4,r4,r5
;;;841      
;;;842      /* Reset the Output Polarity level */
;;;843      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
000036  f64f75df          MOV      r5,#0xffdf
00003a  402a              ANDS     r2,r2,r5
;;;844      /* Set the Output Compare Polarity */
;;;845      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
00003c  898d              LDRH     r5,[r1,#0xc]
00003e  ea061505          AND      r5,r6,r5,LSL #4
000042  432a              ORRS     r2,r2,r5
;;;846      
;;;847      /* Set the Output State */
;;;848      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
000044  884d              LDRH     r5,[r1,#2]
000046  ea061505          AND      r5,r6,r5,LSL #4
00004a  432a              ORRS     r2,r2,r5
;;;849      
;;;850      if((TIMx == TIM1))
00004c  4d13              LDR      r5,|L51.156|
00004e  42a8              CMP      r0,r5
000050  d11e              BNE      |L51.144|
;;;851      {
;;;852        /* Check the parameters */
;;;853        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;854        
;;;855        /* Reset the Ouput Compare State */
;;;856        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2));
000052  f64f35ff          MOV      r5,#0xfbff
000056  402b              ANDS     r3,r3,r5
;;;857        
;;;858        /* Set the Output Idle state */
;;;859        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
000058  8a0d              LDRH     r5,[r1,#0x10]
00005a  ea060585          AND      r5,r6,r5,LSL #2
00005e  432b              ORRS     r3,r3,r5
;;;860        
;;;861        if (TIMx == TIM1)
000060  4605              MOV      r5,r0
000062  42a8              CMP      r0,r5
000064  d114              BNE      |L51.144|
;;;862        {    
;;;863          /* Check the parameters */
;;;864          assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;865          assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;866          assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;867          
;;;868          /* Reset the Output N Polarity level */
;;;869          tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NP));
000066  f64f757f          MOV      r5,#0xff7f
00006a  402a              ANDS     r2,r2,r5
;;;870          /* Set the Output N Polarity */
;;;871          tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
00006c  89cd              LDRH     r5,[r1,#0xe]
00006e  ea061505          AND      r5,r6,r5,LSL #4
000072  432a              ORRS     r2,r2,r5
;;;872          
;;;873          /* Reset the Output N State */
;;;874          tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NE));    
000074  f64f75bf          MOV      r5,#0xffbf
000078  402a              ANDS     r2,r2,r5
;;;875          /* Set the Output N State */
;;;876          tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
00007a  888d              LDRH     r5,[r1,#4]
00007c  ea061505          AND      r5,r6,r5,LSL #4
000080  432a              ORRS     r2,r2,r5
;;;877          
;;;878          /* Reset the Output Compare N IDLE State */
;;;879          tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2N));
000082  f24f75ff          MOV      r5,#0xf7ff
000086  402b              ANDS     r3,r3,r5
;;;880          
;;;881          /* Set the Output N Idle state */
;;;882          tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
000088  8a4d              LDRH     r5,[r1,#0x12]
00008a  ea060585          AND      r5,r6,r5,LSL #2
00008e  432b              ORRS     r3,r3,r5
                  |L51.144|
;;;883        }
;;;884      }
;;;885      /* Write to TIMx CR2 */
;;;886      TIMx->CR2 = tmpcr2;
000090  6043              STR      r3,[r0,#4]
;;;887      
;;;888      /* Write to TIMx CCMR1 */
;;;889      TIMx->CCMR1 = tmpccmrx;
000092  6184              STR      r4,[r0,#0x18]
;;;890      
;;;891      /* Set the Capture Compare Register value */
;;;892      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
000094  688d              LDR      r5,[r1,#8]
000096  6385              STR      r5,[r0,#0x38]
;;;893      
;;;894      /* Write to TIMx CCER */
;;;895      TIMx->CCER = tmpccer;
000098  6202              STR      r2,[r0,#0x20]
;;;896    }
00009a  bd70              POP      {r4-r6,pc}
;;;897    
                          ENDP

                  |L51.156|
                          DCD      0x40010000

                          AREA ||i.TIM_OC2NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2NPolarityConfig PROC
;;;1731   */
;;;1732   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;1733   {
;;;1734     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1735     /* Check the parameters */
;;;1736     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1737     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1738     
;;;1739     tmpccer = TIMx->CCER;
000004  6a03              LDR      r3,[r0,#0x20]
000006  b299              UXTH     r1,r3
;;;1740     /* Set or Reset the CC2NP Bit */
;;;1741     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2NP);
000008  f64f737f          MOV      r3,#0xff7f
00000c  4019              ANDS     r1,r1,r3
;;;1742     tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
00000e  f64f73ff          MOV      r3,#0xffff
000012  ea031302          AND      r3,r3,r2,LSL #4
000016  4319              ORRS     r1,r1,r3
;;;1743     /* Write to TIMx CCER register */
;;;1744     TIMx->CCER = tmpccer;
000018  6201              STR      r1,[r0,#0x20]
;;;1745   }
00001a  4770              BX       lr
;;;1746   
                          ENDP


                          AREA ||i.TIM_OC2PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PolarityConfig PROC
;;;1706   */
;;;1707   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1708   {
;;;1709     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1710     
;;;1711     /* Check the parameters */
;;;1712     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1713     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1714     
;;;1715     tmpccer = TIMx->CCER;
000004  6a03              LDR      r3,[r0,#0x20]
000006  b299              UXTH     r1,r3
;;;1716     /* Set or Reset the CC2P Bit */
;;;1717     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);
000008  f64f73df          MOV      r3,#0xffdf
00000c  4019              ANDS     r1,r1,r3
;;;1718     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
00000e  f64f73ff          MOV      r3,#0xffff
000012  ea031302          AND      r3,r3,r2,LSL #4
000016  4319              ORRS     r1,r1,r3
;;;1719     /* Write to TIMx CCER register */
;;;1720     TIMx->CCER = tmpccer;
000018  6201              STR      r1,[r0,#0x20]
;;;1721   }
00001a  4770              BX       lr
;;;1722   
                          ENDP


                          AREA ||i.TIM_OC2PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PreloadConfig PROC
;;;1356   */
;;;1357   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1358   {
;;;1359     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1360     /* Check the parameters */
;;;1361     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1362     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1363     
;;;1364     tmpccmr1 = TIMx->CCMR1;
000004  6983              LDR      r3,[r0,#0x18]
000006  b299              UXTH     r1,r3
;;;1365     /* Reset the OC2PE Bit */
;;;1366     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2PE);
000008  f24f73ff          MOV      r3,#0xf7ff
00000c  4019              ANDS     r1,r1,r3
;;;1367     /* Enable or Disable the Output Compare Preload feature */
;;;1368     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
00000e  f64f73ff          MOV      r3,#0xffff
000012  ea032302          AND      r3,r3,r2,LSL #8
000016  4319              ORRS     r1,r1,r3
;;;1369     /* Write to TIMx CCMR1 register */
;;;1370     TIMx->CCMR1 = tmpccmr1;
000018  6181              STR      r1,[r0,#0x18]
;;;1371   }
00001a  4770              BX       lr
;;;1372   
                          ENDP


                          AREA ||i.TIM_OC3FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3FastConfig PROC
;;;1492   */
;;;1493   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1494   {
;;;1495     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1496     
;;;1497     /* Check the parameters */
;;;1498     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1499     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1500     
;;;1501     /* Get the TIMx CCMR2 register value */
;;;1502     tmpccmr2 = TIMx->CCMR2;
000004  69c3              LDR      r3,[r0,#0x1c]
000006  b299              UXTH     r1,r3
;;;1503     /* Reset the OC3FE Bit */
;;;1504     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3FE);
000008  f64f73fb          MOV      r3,#0xfffb
00000c  4019              ANDS     r1,r1,r3
;;;1505     /* Enable or Disable the Output Compare Fast Bit */
;;;1506     tmpccmr2 |= TIM_OCFast;
00000e  4311              ORRS     r1,r1,r2
;;;1507     /* Write to TIMx CCMR2 */
;;;1508     TIMx->CCMR2 = tmpccmr2;
000010  61c1              STR      r1,[r0,#0x1c]
;;;1509   }
000012  4770              BX       lr
;;;1510   
                          ENDP


                          AREA ||i.TIM_OC3Init||, CODE, READONLY, ALIGN=2

                  TIM_OC3Init PROC
;;;907    */
;;;908    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;909    {
;;;910      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;911      
;;;912      /* Check the parameters */
;;;913      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;914      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;915      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;916      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;917      /* Disable the Channel 2: Reset the CC2E Bit */
;;;918      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
000008  6a05              LDR      r5,[r0,#0x20]
00000a  f64f66ff          MOV      r6,#0xfeff
00000e  4035              ANDS     r5,r5,r6
000010  6205              STR      r5,[r0,#0x20]
;;;919      
;;;920      /* Get the TIMx CCER register value */
;;;921      tmpccer = TIMx->CCER;
000012  6a05              LDR      r5,[r0,#0x20]
000014  b2aa              UXTH     r2,r5
;;;922      /* Get the TIMx CR2 register value */
;;;923      tmpcr2 =  TIMx->CR2;
000016  6845              LDR      r5,[r0,#4]
000018  b2ab              UXTH     r3,r5
;;;924      
;;;925      /* Get the TIMx CCMR2 register value */
;;;926      tmpccmrx = TIMx->CCMR2;
00001a  69c5              LDR      r5,[r0,#0x1c]
00001c  b2ac              UXTH     r4,r5
;;;927      
;;;928      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;929      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
00001e  f64f758f          MOV      r5,#0xff8f
000022  402c              ANDS     r4,r4,r5
;;;930      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));  
000024  f64f75fc          MOV      r5,#0xfffc
000028  402c              ANDS     r4,r4,r5
;;;931      /* Select the Output Compare Mode */
;;;932      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
00002a  880d              LDRH     r5,[r1,#0]
00002c  432c              ORRS     r4,r4,r5
;;;933      
;;;934      /* Reset the Output Polarity level */
;;;935      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
00002e  f64f55ff          MOV      r5,#0xfdff
000032  402a              ANDS     r2,r2,r5
;;;936      /* Set the Output Compare Polarity */
;;;937      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
000034  898d              LDRH     r5,[r1,#0xc]
000036  f64f76ff          MOV      r6,#0xffff
00003a  ea062505          AND      r5,r6,r5,LSL #8
00003e  432a              ORRS     r2,r2,r5
;;;938      
;;;939      /* Set the Output State */
;;;940      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
000040  884d              LDRH     r5,[r1,#2]
000042  ea062505          AND      r5,r6,r5,LSL #8
000046  432a              ORRS     r2,r2,r5
;;;941      
;;;942      if(TIMx == TIM1)
000048  4d12              LDR      r5,|L56.148|
00004a  42a8              CMP      r0,r5
00004c  d11b              BNE      |L56.134|
;;;943      {
;;;944        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;945        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;946        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;947        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;948        
;;;949        /* Reset the Output N Polarity level */
;;;950        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NP));
00004e  f24f75ff          MOV      r5,#0xf7ff
000052  402a              ANDS     r2,r2,r5
;;;951        /* Set the Output N Polarity */
;;;952        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
000054  89cd              LDRH     r5,[r1,#0xe]
000056  ea062505          AND      r5,r6,r5,LSL #8
00005a  432a              ORRS     r2,r2,r5
;;;953        /* Reset the Output N State */
;;;954        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NE));
00005c  f64f35ff          MOV      r5,#0xfbff
000060  402a              ANDS     r2,r2,r5
;;;955        
;;;956        /* Set the Output N State */
;;;957        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
000062  888d              LDRH     r5,[r1,#4]
000064  ea062505          AND      r5,r6,r5,LSL #8
000068  432a              ORRS     r2,r2,r5
;;;958        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;959        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3));
00006a  f64e75ff          MOV      r5,#0xefff
00006e  402b              ANDS     r3,r3,r5
;;;960        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3N));
000070  f64d75ff          MOV      r5,#0xdfff
000074  402b              ANDS     r3,r3,r5
;;;961        /* Set the Output Idle state */
;;;962        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
000076  8a0d              LDRH     r5,[r1,#0x10]
000078  ea061505          AND      r5,r6,r5,LSL #4
00007c  432b              ORRS     r3,r3,r5
;;;963        /* Set the Output N Idle state */
;;;964        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
00007e  8a4d              LDRH     r5,[r1,#0x12]
000080  ea061505          AND      r5,r6,r5,LSL #4
000084  432b              ORRS     r3,r3,r5
                  |L56.134|
;;;965      }
;;;966      /* Write to TIMx CR2 */
;;;967      TIMx->CR2 = tmpcr2;
000086  6043              STR      r3,[r0,#4]
;;;968      
;;;969      /* Write to TIMx CCMR2 */
;;;970      TIMx->CCMR2 = tmpccmrx;
000088  61c4              STR      r4,[r0,#0x1c]
;;;971      
;;;972      /* Set the Capture Compare Register value */
;;;973      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
00008a  688d              LDR      r5,[r1,#8]
00008c  63c5              STR      r5,[r0,#0x3c]
;;;974      
;;;975      /* Write to TIMx CCER */
;;;976      TIMx->CCER = tmpccer;
00008e  6202              STR      r2,[r0,#0x20]
;;;977    }
000090  bd70              POP      {r4-r6,pc}
;;;978    
                          ENDP

000092  0000              DCW      0x0000
                  |L56.148|
                          DCD      0x40010000

                          AREA ||i.TIM_OC3NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3NPolarityConfig PROC
;;;1781   */
;;;1782   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;1783   {
;;;1784     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1785     
;;;1786     /* Check the parameters */
;;;1787     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1788     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1789     
;;;1790     tmpccer = TIMx->CCER;
000004  6a03              LDR      r3,[r0,#0x20]
000006  b299              UXTH     r1,r3
;;;1791     /* Set or Reset the CC3NP Bit */
;;;1792     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3NP);
000008  f24f73ff          MOV      r3,#0xf7ff
00000c  4019              ANDS     r1,r1,r3
;;;1793     tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
00000e  f64f73ff          MOV      r3,#0xffff
000012  ea032302          AND      r3,r3,r2,LSL #8
000016  4319              ORRS     r1,r1,r3
;;;1794     /* Write to TIMx CCER register */
;;;1795     TIMx->CCER = tmpccer;
000018  6201              STR      r1,[r0,#0x20]
;;;1796   }
00001a  4770              BX       lr
;;;1797   
                          ENDP


                          AREA ||i.TIM_OC3PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PolarityConfig PROC
;;;1756   */
;;;1757   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1758   {
;;;1759     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1760     
;;;1761     /* Check the parameters */
;;;1762     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1763     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1764     
;;;1765     tmpccer = TIMx->CCER;
000004  6a03              LDR      r3,[r0,#0x20]
000006  b299              UXTH     r1,r3
;;;1766     /* Set or Reset the CC3P Bit */
;;;1767     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3P);
000008  f64f53ff          MOV      r3,#0xfdff
00000c  4019              ANDS     r1,r1,r3
;;;1768     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
00000e  f64f73ff          MOV      r3,#0xffff
000012  ea032302          AND      r3,r3,r2,LSL #8
000016  4319              ORRS     r1,r1,r3
;;;1769     /* Write to TIMx CCER register */
;;;1770     TIMx->CCER = tmpccer;
000018  6201              STR      r1,[r0,#0x20]
;;;1771   }
00001a  4770              BX       lr
;;;1772   
                          ENDP


                          AREA ||i.TIM_OC3PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PreloadConfig PROC
;;;1382   */
;;;1383   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1384   {
;;;1385     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1386     
;;;1387     /* Check the parameters */
;;;1388     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1389     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1390     
;;;1391     tmpccmr2 = TIMx->CCMR2;
000004  69c3              LDR      r3,[r0,#0x1c]
000006  b299              UXTH     r1,r3
;;;1392     /* Reset the OC3PE Bit */
;;;1393     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3PE);
000008  f64f73f7          MOV      r3,#0xfff7
00000c  4019              ANDS     r1,r1,r3
;;;1394     /* Enable or Disable the Output Compare Preload feature */
;;;1395     tmpccmr2 |= TIM_OCPreload;
00000e  4311              ORRS     r1,r1,r2
;;;1396     /* Write to TIMx CCMR2 register */
;;;1397     TIMx->CCMR2 = tmpccmr2;
000010  61c1              STR      r1,[r0,#0x1c]
;;;1398   }
000012  4770              BX       lr
;;;1399   
                          ENDP


                          AREA ||i.TIM_OC4FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4FastConfig PROC
;;;1520   */
;;;1521   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1522   {
;;;1523     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1524     
;;;1525     /* Check the parameters */
;;;1526     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1527     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1528     
;;;1529     /* Get the TIMx CCMR2 register value */
;;;1530     tmpccmr2 = TIMx->CCMR2;
000004  69c3              LDR      r3,[r0,#0x1c]
000006  b299              UXTH     r1,r3
;;;1531     /* Reset the OC4FE Bit */
;;;1532     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4FE);
000008  f64f33ff          MOV      r3,#0xfbff
00000c  4019              ANDS     r1,r1,r3
;;;1533     /* Enable or Disable the Output Compare Fast Bit */
;;;1534     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
00000e  f64f73ff          MOV      r3,#0xffff
000012  ea032302          AND      r3,r3,r2,LSL #8
000016  4319              ORRS     r1,r1,r3
;;;1535     /* Write to TIMx CCMR2 */
;;;1536     TIMx->CCMR2 = tmpccmr2;
000018  61c1              STR      r1,[r0,#0x1c]
;;;1537   }
00001a  4770              BX       lr
;;;1538   
                          ENDP


                          AREA ||i.TIM_OC4Init||, CODE, READONLY, ALIGN=2

                  TIM_OC4Init PROC
;;;988    */
;;;989    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;990    {
;;;991      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
000006  2400              MOVS     r4,#0
;;;992      
;;;993      /* Check the parameters */
;;;994      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;995      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;996      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;997      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;998      /* Disable the Channel 2: Reset the CC4E Bit */
;;;999      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
000008  6a05              LDR      r5,[r0,#0x20]
00000a  f64e76ff          MOV      r6,#0xefff
00000e  4035              ANDS     r5,r5,r6
000010  6205              STR      r5,[r0,#0x20]
;;;1000     
;;;1001     /* Get the TIMx CCER register value */
;;;1002     tmpccer = TIMx->CCER;
000012  6a05              LDR      r5,[r0,#0x20]
000014  b2ab              UXTH     r3,r5
;;;1003     /* Get the TIMx CR2 register value */
;;;1004     tmpcr2 =  TIMx->CR2;
000016  6845              LDR      r5,[r0,#4]
000018  b2ac              UXTH     r4,r5
;;;1005     
;;;1006     /* Get the TIMx CCMR2 register value */
;;;1007     tmpccmrx = TIMx->CCMR2;
00001a  69c5              LDR      r5,[r0,#0x1c]
00001c  b2aa              UXTH     r2,r5
;;;1008     
;;;1009     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;1010     tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
00001e  f64875ff          MOV      r5,#0x8fff
000022  402a              ANDS     r2,r2,r5
;;;1011     tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
000024  f64f45ff          MOV      r5,#0xfcff
000028  402a              ANDS     r2,r2,r5
;;;1012     
;;;1013     /* Select the Output Compare Mode */
;;;1014     tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
00002a  880d              LDRH     r5,[r1,#0]
00002c  f64f76ff          MOV      r6,#0xffff
000030  ea062505          AND      r5,r6,r5,LSL #8
000034  432a              ORRS     r2,r2,r5
;;;1015     
;;;1016     /* Reset the Output Polarity level */
;;;1017     tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
000036  f64d75ff          MOV      r5,#0xdfff
00003a  402b              ANDS     r3,r3,r5
;;;1018     /* Set the Output Compare Polarity */
;;;1019     tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
00003c  898d              LDRH     r5,[r1,#0xc]
00003e  ea063505          AND      r5,r6,r5,LSL #12
000042  432b              ORRS     r3,r3,r5
;;;1020     
;;;1021     /* Set the Output State */
;;;1022     tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
000044  884d              LDRH     r5,[r1,#2]
000046  ea063505          AND      r5,r6,r5,LSL #12
00004a  432b              ORRS     r3,r3,r5
;;;1023     
;;;1024     if(TIMx == TIM1)
00004c  4d07              LDR      r5,|L61.108|
00004e  42a8              CMP      r0,r5
000050  d106              BNE      |L61.96|
;;;1025     {
;;;1026       assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;1027       /* Reset the Ouput Compare IDLE State */
;;;1028       tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS4));
000052  f64b75ff          MOV      r5,#0xbfff
000056  402c              ANDS     r4,r4,r5
;;;1029       /* Set the Output Idle state */
;;;1030       tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
000058  8a0d              LDRH     r5,[r1,#0x10]
00005a  ea061585          AND      r5,r6,r5,LSL #6
00005e  432c              ORRS     r4,r4,r5
                  |L61.96|
;;;1031     }
;;;1032     /* Write to TIMx CR2 */
;;;1033     TIMx->CR2 = tmpcr2;
000060  6044              STR      r4,[r0,#4]
;;;1034     
;;;1035     /* Write to TIMx CCMR2 */  
;;;1036     TIMx->CCMR2 = tmpccmrx;
000062  61c2              STR      r2,[r0,#0x1c]
;;;1037     
;;;1038     /* Set the Capture Compare Register value */
;;;1039     TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
000064  688d              LDR      r5,[r1,#8]
000066  6405              STR      r5,[r0,#0x40]
;;;1040     
;;;1041     /* Write to TIMx CCER */
;;;1042     TIMx->CCER = tmpccer;
000068  6203              STR      r3,[r0,#0x20]
;;;1043   }
00006a  bd70              POP      {r4-r6,pc}
;;;1044   
                          ENDP

                  |L61.108|
                          DCD      0x40010000

                          AREA ||i.TIM_OC4PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PolarityConfig PROC
;;;1807   */
;;;1808   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1809   {
;;;1810     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1811     
;;;1812     /* Check the parameters */
;;;1813     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1814     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1815     
;;;1816     tmpccer = TIMx->CCER;
000004  6a03              LDR      r3,[r0,#0x20]
000006  b299              UXTH     r1,r3
;;;1817     /* Set or Reset the CC4P Bit */
;;;1818     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);
000008  f64d73ff          MOV      r3,#0xdfff
00000c  4019              ANDS     r1,r1,r3
;;;1819     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
00000e  f64f73ff          MOV      r3,#0xffff
000012  ea033302          AND      r3,r3,r2,LSL #12
000016  4319              ORRS     r1,r1,r3
;;;1820     /* Write to TIMx CCER register */
;;;1821     TIMx->CCER = tmpccer;
000018  6201              STR      r1,[r0,#0x20]
;;;1822   }
00001a  4770              BX       lr
;;;1823   
                          ENDP


                          AREA ||i.TIM_OC4PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PreloadConfig PROC
;;;1409   */
;;;1410   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1411   {
;;;1412     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1413     
;;;1414     /* Check the parameters */
;;;1415     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1416     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1417     
;;;1418     tmpccmr2 = TIMx->CCMR2;
000004  69c3              LDR      r3,[r0,#0x1c]
000006  b299              UXTH     r1,r3
;;;1419     /* Reset the OC4PE Bit */
;;;1420     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4PE);
000008  f24f73ff          MOV      r3,#0xf7ff
00000c  4019              ANDS     r1,r1,r3
;;;1421     /* Enable or Disable the Output Compare Preload feature */
;;;1422     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
00000e  f64f73ff          MOV      r3,#0xffff
000012  ea032302          AND      r3,r3,r2,LSL #8
000016  4319              ORRS     r1,r1,r3
;;;1423     /* Write to TIMx CCMR2 register */
;;;1424     TIMx->CCMR2 = tmpccmr2;
000018  61c1              STR      r1,[r0,#0x1c]
;;;1425   }
00001a  4770              BX       lr
;;;1426   
                          ENDP


                          AREA ||i.TIM_OCStructInit||, CODE, READONLY, ALIGN=1

                  TIM_OCStructInit PROC
;;;1050   */
;;;1051   void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;1052   {
;;;1053     /* Set the default configuration */
;;;1054     TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
000002  8001              STRH     r1,[r0,#0]
;;;1055     TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;1056     TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
000006  8081              STRH     r1,[r0,#4]
;;;1057     TIM_OCInitStruct->TIM_Pulse = 0x0000000;
000008  6081              STR      r1,[r0,#8]
;;;1058     TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
00000a  8181              STRH     r1,[r0,#0xc]
;;;1059     TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
00000c  81c1              STRH     r1,[r0,#0xe]
;;;1060     TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
00000e  8201              STRH     r1,[r0,#0x10]
;;;1061     TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000010  8241              STRH     r1,[r0,#0x12]
;;;1062   }
000012  4770              BX       lr
;;;1063   
                          ENDP


                          AREA ||i.TIM_PWMIConfig||, CODE, READONLY, ALIGN=1

                  TIM_PWMIConfig PROC
;;;2067   */
;;;2068   void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2069   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;2070     uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
000008  2600              MOVS     r6,#0
;;;2071     uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
00000a  2701              MOVS     r7,#1
;;;2072     /* Check the parameters */
;;;2073     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2074     /* Select the Opposite Input Polarity */
;;;2075     if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
00000c  8860              LDRH     r0,[r4,#2]
00000e  b908              CBNZ     r0,|L65.20|
;;;2076     {
;;;2077       icoppositepolarity = TIM_ICPolarity_Falling;
000010  2602              MOVS     r6,#2
000012  e000              B        |L65.22|
                  |L65.20|
;;;2078     }
;;;2079     else
;;;2080     {
;;;2081       icoppositepolarity = TIM_ICPolarity_Rising;
000014  2600              MOVS     r6,#0
                  |L65.22|
;;;2082     }
;;;2083     /* Select the Opposite Input */
;;;2084     if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
000016  88a0              LDRH     r0,[r4,#4]
000018  2801              CMP      r0,#1
00001a  d101              BNE      |L65.32|
;;;2085     {
;;;2086       icoppositeselection = TIM_ICSelection_IndirectTI;
00001c  2702              MOVS     r7,#2
00001e  e000              B        |L65.34|
                  |L65.32|
;;;2087     }
;;;2088     else
;;;2089     {
;;;2090       icoppositeselection = TIM_ICSelection_DirectTI;
000020  2701              MOVS     r7,#1
                  |L65.34|
;;;2091     }
;;;2092     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000022  8820              LDRH     r0,[r4,#0]
000024  b9a0              CBNZ     r0,|L65.80|
;;;2093     {
;;;2094       /* TI1 Configuration */
;;;2095       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000026  8923              LDRH     r3,[r4,#8]
000028  88a2              LDRH     r2,[r4,#4]
00002a  8861              LDRH     r1,[r4,#2]
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       TI1_Config
;;;2096                  TIM_ICInitStruct->TIM_ICFilter);
;;;2097       /* Set the Input Capture Prescaler value */
;;;2098       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000032  88e1              LDRH     r1,[r4,#6]
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       TIM_SetIC1Prescaler
;;;2099       /* TI2 Configuration */
;;;2100       TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
00003a  8923              LDRH     r3,[r4,#8]
00003c  463a              MOV      r2,r7
00003e  4631              MOV      r1,r6
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       TI2_Config
;;;2101       /* Set the Input Capture Prescaler value */
;;;2102       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000046  88e1              LDRH     r1,[r4,#6]
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       TIM_SetIC2Prescaler
00004e  e013              B        |L65.120|
                  |L65.80|
;;;2103     }
;;;2104     else
;;;2105     { 
;;;2106       /* TI2 Configuration */
;;;2107       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000050  8923              LDRH     r3,[r4,#8]
000052  88a2              LDRH     r2,[r4,#4]
000054  8861              LDRH     r1,[r4,#2]
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       TI2_Config
;;;2108                  TIM_ICInitStruct->TIM_ICFilter);
;;;2109       /* Set the Input Capture Prescaler value */
;;;2110       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00005c  88e1              LDRH     r1,[r4,#6]
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       TIM_SetIC2Prescaler
;;;2111       /* TI1 Configuration */
;;;2112       TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000064  8923              LDRH     r3,[r4,#8]
000066  463a              MOV      r2,r7
000068  4631              MOV      r1,r6
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       TI1_Config
;;;2113       /* Set the Input Capture Prescaler value */
;;;2114       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000070  88e1              LDRH     r1,[r4,#6]
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       TIM_SetIC1Prescaler
                  |L65.120|
;;;2115     }
;;;2116   }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;2117   
                          ENDP


                          AREA ||i.TIM_PrescalerConfig||, CODE, READONLY, ALIGN=1

                  TIM_PrescalerConfig PROC
;;;292    */
;;;293    void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
000000  6281              STR      r1,[r0,#0x28]
;;;294    {
;;;295      /* Check the parameters */
;;;296      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;297      assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;298      
;;;299      /* Set the Prescaler value */
;;;300      TIMx->PSC = Prescaler;
;;;301      /* Set or reset the UG Bit */
;;;302      TIMx->EGR = TIM_PSCReloadMode;
000002  6142              STR      r2,[r0,#0x14]
;;;303    }
000004  4770              BX       lr
;;;304    
                          ENDP


                          AREA ||i.TIM_SelectCCDMA||, CODE, READONLY, ALIGN=1

                  TIM_SelectCCDMA PROC
;;;2621   */
;;;2622   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L67.12|
;;;2623   {
;;;2624     /* Check the parameters */
;;;2625     assert_param(IS_TIM_LIST5_PERIPH(TIMx));
;;;2626     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2627     
;;;2628     if (NewState != DISABLE)
;;;2629     {
;;;2630       /* Set the CCDS Bit */
;;;2631       TIMx->CR2 |= TIM_CR2_CCDS;
000002  6842              LDR      r2,[r0,#4]
000004  f0420208          ORR      r2,r2,#8
000008  6042              STR      r2,[r0,#4]
00000a  e004              B        |L67.22|
                  |L67.12|
;;;2632     }
;;;2633     else
;;;2634     {
;;;2635       /* Reset the CCDS Bit */
;;;2636       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCDS);
00000c  6842              LDR      r2,[r0,#4]
00000e  f64f73f7          MOV      r3,#0xfff7
000012  401a              ANDS     r2,r2,r3
000014  6042              STR      r2,[r0,#4]
                  |L67.22|
;;;2637     }
;;;2638   }
000016  4770              BX       lr
;;;2639   
                          ENDP


                          AREA ||i.TIM_SelectCOM||, CODE, READONLY, ALIGN=1

                  TIM_SelectCOM PROC
;;;1912   */
;;;1913   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L68.12|
;;;1914   {
;;;1915     /* Check the parameters */
;;;1916     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1917     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1918     if (NewState != DISABLE)
;;;1919     {
;;;1920       /* Set the COM Bit */
;;;1921       TIMx->CR2 |= TIM_CR2_CCUS;
000002  6842              LDR      r2,[r0,#4]
000004  f0420204          ORR      r2,r2,#4
000008  6042              STR      r2,[r0,#4]
00000a  e004              B        |L68.22|
                  |L68.12|
;;;1922     }
;;;1923     else
;;;1924     {
;;;1925       /* Reset the COM Bit */
;;;1926       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCUS);
00000c  6842              LDR      r2,[r0,#4]
00000e  f64f73fb          MOV      r3,#0xfffb
000012  401a              ANDS     r2,r2,r3
000014  6042              STR      r2,[r0,#4]
                  |L68.22|
;;;1927     }
;;;1928   }
000016  4770              BX       lr
;;;1929   
                          ENDP


                          AREA ||i.TIM_SelectHallSensor||, CODE, READONLY, ALIGN=1

                  TIM_SelectHallSensor PROC
;;;3082   */
;;;3083   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L69.12|
;;;3084   {
;;;3085     /* Check the parameters */
;;;3086     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;3087     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;3088     
;;;3089     if (NewState != DISABLE)
;;;3090     {
;;;3091       /* Set the TI1S Bit */
;;;3092       TIMx->CR2 |= TIM_CR2_TI1S;
000002  6842              LDR      r2,[r0,#4]
000004  f0420280          ORR      r2,r2,#0x80
000008  6042              STR      r2,[r0,#4]
00000a  e004              B        |L69.22|
                  |L69.12|
;;;3093     }
;;;3094     else
;;;3095     {
;;;3096       /* Reset the TI1S Bit */
;;;3097       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_TI1S);
00000c  6842              LDR      r2,[r0,#4]
00000e  f64f737f          MOV      r3,#0xff7f
000012  401a              ANDS     r2,r2,r3
000014  6042              STR      r2,[r0,#4]
                  |L69.22|
;;;3098     }
;;;3099   }
000016  4770              BX       lr
;;;3100   
                          ENDP


                          AREA ||i.TIM_SelectInputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectInputTrigger PROC
;;;2861   */
;;;2862   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  460a              MOV      r2,r1
;;;2863   {
;;;2864     uint16_t tmpsmcr = 0;
000002  2100              MOVS     r1,#0
;;;2865     
;;;2866     /* Check the parameters */
;;;2867     assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
;;;2868     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2869     
;;;2870     /* Get the TIMx SMCR register value */
;;;2871     tmpsmcr = TIMx->SMCR;
000004  6883              LDR      r3,[r0,#8]
000006  b299              UXTH     r1,r3
;;;2872     /* Reset the TS Bits */
;;;2873     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
000008  f64f738f          MOV      r3,#0xff8f
00000c  4019              ANDS     r1,r1,r3
;;;2874     /* Set the Input Trigger source */
;;;2875     tmpsmcr |= TIM_InputTriggerSource;
00000e  4311              ORRS     r1,r1,r2
;;;2876     /* Write to TIMx SMCR */
;;;2877     TIMx->SMCR = tmpsmcr;
000010  6081              STR      r1,[r0,#8]
;;;2878   }
000012  4770              BX       lr
;;;2879   
                          ENDP


                          AREA ||i.TIM_SelectMasterSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectMasterSlaveMode PROC
;;;2951   */
;;;2952   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000000  6882              LDR      r2,[r0,#8]
;;;2953   {
;;;2954     /* Check the parameters */
;;;2955     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2956     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2957     
;;;2958     /* Reset the MSM Bit */
;;;2959     TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_MSM);
000002  f64f737f          MOV      r3,#0xff7f
000006  401a              ANDS     r2,r2,r3
000008  6082              STR      r2,[r0,#8]
;;;2960     
;;;2961     /* Set or Reset the MSM Bit */
;;;2962     TIMx->SMCR |= TIM_MasterSlaveMode;
00000a  6882              LDR      r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  6082              STR      r2,[r0,#8]
;;;2963   }
000010  4770              BX       lr
;;;2964   
                          ENDP


                          AREA ||i.TIM_SelectOCxM||, CODE, READONLY, ALIGN=1

                  TIM_SelectOCxM PROC
;;;1087   */
;;;1088   void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
000000  b570              PUSH     {r4-r6,lr}
;;;1089   {
000002  4603              MOV      r3,r0
;;;1090     uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
;;;1091     uint16_t tmp1 = 0;
000006  2400              MOVS     r4,#0
;;;1092     
;;;1093     /* Check the parameters */
;;;1094     assert_param(IS_TIM_LIST4_PERIPH(TIMx));  
;;;1095     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;1096     
;;;1097     tmp = (uint32_t) TIMx;
000008  4618              MOV      r0,r3
;;;1098     tmp += CCMR_OFFSET;
00000a  3018              ADDS     r0,r0,#0x18
;;;1099     
;;;1100     tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
00000c  2501              MOVS     r5,#1
00000e  408d              LSLS     r5,r5,r1
000010  b2ac              UXTH     r4,r5
;;;1101     
;;;1102     /* Disable the Channel: Reset the CCxE Bit */
;;;1103     TIMx->CCER &= (uint16_t) ~tmp1;
000012  6a1d              LDR      r5,[r3,#0x20]
000014  43e6              MVNS     r6,r4
000016  b2b6              UXTH     r6,r6
000018  4035              ANDS     r5,r5,r6
00001a  621d              STR      r5,[r3,#0x20]
;;;1104     
;;;1105     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
00001c  b109              CBZ      r1,|L72.34|
00001e  2908              CMP      r1,#8
000020  d109              BNE      |L72.54|
                  |L72.34|
;;;1106     {
;;;1107       tmp += (TIM_Channel>>1);
000022  eb000061          ADD      r0,r0,r1,ASR #1
;;;1108       
;;;1109       /* Reset the OCxM bits in the CCMRx register */
;;;1110       *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
000026  6805              LDR      r5,[r0,#0]
000028  f0250570          BIC      r5,r5,#0x70
00002c  6005              STR      r5,[r0,#0]
;;;1111       
;;;1112       /* Configure the OCxM bits in the CCMRx register */
;;;1113       *(__IO uint32_t *) tmp |= TIM_OCMode;
00002e  6805              LDR      r5,[r0,#0]
000030  4315              ORRS     r5,r5,r2
000032  6005              STR      r5,[r0,#0]
000034  e00e              B        |L72.84|
                  |L72.54|
;;;1114     }
;;;1115     else
;;;1116     {
;;;1117       tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
000036  1f0d              SUBS     r5,r1,#4
000038  f3c5054e          UBFX     r5,r5,#1,#15
00003c  4428              ADD      r0,r0,r5
;;;1118       
;;;1119       /* Reset the OCxM bits in the CCMRx register */
;;;1120       *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
00003e  6805              LDR      r5,[r0,#0]
000040  f42545e0          BIC      r5,r5,#0x7000
000044  6005              STR      r5,[r0,#0]
;;;1121       
;;;1122       /* Configure the OCxM bits in the CCMRx register */
;;;1123       *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
000046  6805              LDR      r5,[r0,#0]
000048  f64f76ff          MOV      r6,#0xffff
00004c  ea062602          AND      r6,r6,r2,LSL #8
000050  4335              ORRS     r5,r5,r6
000052  6005              STR      r5,[r0,#0]
                  |L72.84|
;;;1124     }
;;;1125   }
000054  bd70              POP      {r4-r6,pc}
;;;1126   
                          ENDP


                          AREA ||i.TIM_SelectOnePulseMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectOnePulseMode PROC
;;;511    */
;;;512    void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
000000  6802              LDR      r2,[r0,#0]
;;;513    {
;;;514      /* Check the parameters */
;;;515      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;516      assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;517      
;;;518      /* Reset the OPM Bit */
;;;519      TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_OPM);
000002  f64f73f7          MOV      r3,#0xfff7
000006  401a              ANDS     r2,r2,r3
000008  6002              STR      r2,[r0,#0]
;;;520      /* Configure the OPM Mode */
;;;521      TIMx->CR1 |= TIM_OPMode;
00000a  6802              LDR      r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  6002              STR      r2,[r0,#0]
;;;522    }
000010  4770              BX       lr
;;;523    
                          ENDP


                          AREA ||i.TIM_SelectOutputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectOutputTrigger PROC
;;;2903   */
;;;2904   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000000  6842              LDR      r2,[r0,#4]
;;;2905   {
;;;2906     /* Check the parameters */
;;;2907     assert_param(IS_TIM_LIST9_PERIPH(TIMx));
;;;2908     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2909     
;;;2910     /* Reset the MMS Bits */
;;;2911     TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_MMS);
000002  f64f738f          MOV      r3,#0xff8f
000006  401a              ANDS     r2,r2,r3
000008  6042              STR      r2,[r0,#4]
;;;2912     /* Select the TRGO source */
;;;2913     TIMx->CR2 |=  TIM_TRGOSource;
00000a  6842              LDR      r2,[r0,#4]
00000c  430a              ORRS     r2,r2,r1
00000e  6042              STR      r2,[r0,#4]
;;;2914   }
000010  4770              BX       lr
;;;2915   
                          ENDP


                          AREA ||i.TIM_SelectSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectSlaveMode PROC
;;;2928   */
;;;2929   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
000000  6882              LDR      r2,[r0,#8]
;;;2930   {
;;;2931     /* Check the parameters */
;;;2932     assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
;;;2933     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2934     
;;;2935     /* Reset the SMS Bits */
;;;2936     TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_SMS);
000002  f64f73f8          MOV      r3,#0xfff8
000006  401a              ANDS     r2,r2,r3
000008  6082              STR      r2,[r0,#8]
;;;2937     /* Select the Slave Mode */
;;;2938     TIMx->SMCR |= TIM_SlaveMode;
00000a  6882              LDR      r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  6082              STR      r2,[r0,#8]
;;;2939   }
000010  4770              BX       lr
;;;2940   
                          ENDP


                          AREA ||i.TIM_SetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_SetAutoreload PROC
;;;362    */
;;;363    void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
000000  62c1              STR      r1,[r0,#0x2c]
;;;364    {
;;;365      /* Check the parameters */
;;;366      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;367      
;;;368      /* Set the Autoreload Register value */
;;;369      TIMx->ARR = Autoreload;
;;;370    }
000002  4770              BX       lr
;;;371    
                          ENDP


                          AREA ||i.TIM_SetClockDivision||, CODE, READONLY, ALIGN=1

                  TIM_SetClockDivision PROC
;;;534    */
;;;535    void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
000000  6802              LDR      r2,[r0,#0]
;;;536    {
;;;537      /* Check the parameters */
;;;538      assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;539      assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;540      
;;;541      /* Reset the CKD Bits */
;;;542      TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_CKD);
000002  f64f43ff          MOV      r3,#0xfcff
000006  401a              ANDS     r2,r2,r3
000008  6002              STR      r2,[r0,#0]
;;;543      /* Set the CKD value */
;;;544      TIMx->CR1 |= TIM_CKD;
00000a  6802              LDR      r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  6002              STR      r2,[r0,#0]
;;;545    }
000010  4770              BX       lr
;;;546    
                          ENDP


                          AREA ||i.TIM_SetCompare1||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare1 PROC
;;;1133   */
;;;1134   void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
000000  6341              STR      r1,[r0,#0x34]
;;;1135   {
;;;1136     /* Check the parameters */
;;;1137     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1138     
;;;1139     /* Set the Capture Compare1 Register value */
;;;1140     TIMx->CCR1 = Compare1;
;;;1141   }
000002  4770              BX       lr
;;;1142   
                          ENDP


                          AREA ||i.TIM_SetCompare2||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare2 PROC
;;;1149   */
;;;1150   void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
000000  6381              STR      r1,[r0,#0x38]
;;;1151   {
;;;1152     /* Check the parameters */
;;;1153     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1154     
;;;1155     /* Set the Capture Compare2 Register value */
;;;1156     TIMx->CCR2 = Compare2;
;;;1157   }
000002  4770              BX       lr
;;;1158   
                          ENDP


                          AREA ||i.TIM_SetCompare3||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare3 PROC
;;;1164   */
;;;1165   void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
000000  63c1              STR      r1,[r0,#0x3c]
;;;1166   {
;;;1167     /* Check the parameters */
;;;1168     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1169     
;;;1170     /* Set the Capture Compare3 Register value */
;;;1171     TIMx->CCR3 = Compare3;
;;;1172   }
000002  4770              BX       lr
;;;1173   
                          ENDP


                          AREA ||i.TIM_SetCompare4||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare4 PROC
;;;1180   */
;;;1181   void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
000000  6401              STR      r1,[r0,#0x40]
;;;1182   {
;;;1183     /* Check the parameters */
;;;1184     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1185     
;;;1186     /* Set the Capture Compare4 Register value */
;;;1187     TIMx->CCR4 = Compare4;
;;;1188   }
000002  4770              BX       lr
;;;1189   
                          ENDP


                          AREA ||i.TIM_SetCounter||, CODE, READONLY, ALIGN=1

                  TIM_SetCounter PROC
;;;344    */
;;;345    void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
000000  6241              STR      r1,[r0,#0x24]
;;;346    {
;;;347      /* Check the parameters */
;;;348      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;349      
;;;350      /* Set the Counter Register value */
;;;351      TIMx->CNT = Counter;
;;;352    }
000002  4770              BX       lr
;;;353    
                          ENDP


                          AREA ||i.TIM_SetIC1Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC1Prescaler PROC
;;;2188   */
;;;2189   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  6982              LDR      r2,[r0,#0x18]
;;;2190   {
;;;2191     /* Check the parameters */
;;;2192     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2193     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2194     
;;;2195     /* Reset the IC1PSC Bits */
;;;2196     TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
000002  f64f73f3          MOV      r3,#0xfff3
000006  401a              ANDS     r2,r2,r3
000008  6182              STR      r2,[r0,#0x18]
;;;2197     /* Set the IC1PSC value */
;;;2198     TIMx->CCMR1 |= TIM_ICPSC;
00000a  6982              LDR      r2,[r0,#0x18]
00000c  430a              ORRS     r2,r2,r1
00000e  6182              STR      r2,[r0,#0x18]
;;;2199   }
000010  4770              BX       lr
;;;2200   
                          ENDP


                          AREA ||i.TIM_SetIC2Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC2Prescaler PROC
;;;2212   */
;;;2213   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  6982              LDR      r2,[r0,#0x18]
;;;2214   {
;;;2215     /* Check the parameters */
;;;2216     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2217     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2218     
;;;2219     /* Reset the IC2PSC Bits */
;;;2220     TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
000002  f24f33ff          MOV      r3,#0xf3ff
000006  401a              ANDS     r2,r2,r3
000008  6182              STR      r2,[r0,#0x18]
;;;2221     /* Set the IC2PSC value */
;;;2222     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
00000a  6982              LDR      r2,[r0,#0x18]
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032301          AND      r3,r3,r1,LSL #8
000014  431a              ORRS     r2,r2,r3
000016  6182              STR      r2,[r0,#0x18]
;;;2223   }
000018  4770              BX       lr
;;;2224   
                          ENDP


                          AREA ||i.TIM_SetIC3Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC3Prescaler PROC
;;;2236   */
;;;2237   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  69c2              LDR      r2,[r0,#0x1c]
;;;2238   {
;;;2239     /* Check the parameters */
;;;2240     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2241     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2242     
;;;2243     /* Reset the IC3PSC Bits */
;;;2244     TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC3PSC);
000002  f64f73f3          MOV      r3,#0xfff3
000006  401a              ANDS     r2,r2,r3
000008  61c2              STR      r2,[r0,#0x1c]
;;;2245     /* Set the IC3PSC value */
;;;2246     TIMx->CCMR2 |= TIM_ICPSC;
00000a  69c2              LDR      r2,[r0,#0x1c]
00000c  430a              ORRS     r2,r2,r1
00000e  61c2              STR      r2,[r0,#0x1c]
;;;2247   }
000010  4770              BX       lr
;;;2248   
                          ENDP


                          AREA ||i.TIM_SetIC4Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC4Prescaler PROC
;;;2260   */
;;;2261   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  69c2              LDR      r2,[r0,#0x1c]
;;;2262   {  
;;;2263     /* Check the parameters */
;;;2264     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2265     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2266     
;;;2267     /* Reset the IC4PSC Bits */
;;;2268     TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
000002  f24f33ff          MOV      r3,#0xf3ff
000006  401a              ANDS     r2,r2,r3
000008  61c2              STR      r2,[r0,#0x1c]
;;;2269     /* Set the IC4PSC value */
;;;2270     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
00000a  69c2              LDR      r2,[r0,#0x1c]
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032301          AND      r3,r3,r1,LSL #8
000014  431a              ORRS     r2,r2,r3
000016  61c2              STR      r2,[r0,#0x1c]
;;;2271   }
000018  4770              BX       lr
;;;2272   
                          ENDP


                          AREA ||i.TIM_TIxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_TIxExternalClockConfig PROC
;;;2709   */
;;;2710   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2711                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;2712   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;2713     /* Check the parameters */
;;;2714     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2715     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;2716     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;2717     
;;;2718     /* Configure the Timer Input Clock Source */
;;;2719     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
00000c  2d60              CMP      r5,#0x60
00000e  d106              BNE      |L87.30|
;;;2720     {
;;;2721       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
000010  463b              MOV      r3,r7
000012  2201              MOVS     r2,#1
000014  4631              MOV      r1,r6
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       TI2_Config
00001c  e005              B        |L87.42|
                  |L87.30|
;;;2722     }
;;;2723     else
;;;2724     {
;;;2725       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
00001e  463b              MOV      r3,r7
000020  2201              MOVS     r2,#1
000022  4631              MOV      r1,r6
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       TI1_Config
                  |L87.42|
;;;2726     }
;;;2727     /* Select the Trigger source */
;;;2728     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
00002a  4629              MOV      r1,r5
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       TIM_SelectInputTrigger
;;;2729     /* Select the External clock mode1 */
;;;2730     TIMx->SMCR |= TIM_SlaveMode_External1;
000032  68a0              LDR      r0,[r4,#8]
000034  f0400007          ORR      r0,r0,#7
000038  60a0              STR      r0,[r4,#8]
;;;2731   }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;2732   
                          ENDP


                          AREA ||i.TIM_TimeBaseInit||, CODE, READONLY, ALIGN=2

                  TIM_TimeBaseInit PROC
;;;227    */
;;;228    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  2200              MOVS     r2,#0
;;;229    {
;;;230      uint16_t tmpcr1 = 0;
;;;231      
;;;232      /* Check the parameters */
;;;233      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;234      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;235      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;236      
;;;237      tmpcr1 = TIMx->CR1;  
000002  6803              LDR      r3,[r0,#0]
000004  b29a              UXTH     r2,r3
;;;238      
;;;239      if((TIMx == TIM1) || (TIMx == TIM2) || (TIMx == TIM3))
000006  4b10              LDR      r3,|L88.72|
000008  4298              CMP      r0,r3
00000a  d005              BEQ      |L88.24|
00000c  4b0f              LDR      r3,|L88.76|
00000e  4298              CMP      r0,r3
000010  d002              BEQ      |L88.24|
000012  f1b04f80          CMP      r0,#0x40000000
000016  d104              BNE      |L88.34|
                  |L88.24|
;;;240      {
;;;241        /* Select the Counter Mode */
;;;242        tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
000018  f64f738f          MOV      r3,#0xff8f
00001c  401a              ANDS     r2,r2,r3
;;;243        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
00001e  884b              LDRH     r3,[r1,#2]
000020  431a              ORRS     r2,r2,r3
                  |L88.34|
;;;244      }
;;;245      TIMx->CR1 = tmpcr1;
000022  6002              STR      r2,[r0,#0]
;;;246      
;;;247      /* Set the Autoreload value */
;;;248      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
000024  684b              LDR      r3,[r1,#4]
000026  62c3              STR      r3,[r0,#0x2c]
;;;249      
;;;250      /* Set the Prescaler value */
;;;251      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
000028  880b              LDRH     r3,[r1,#0]
00002a  6283              STR      r3,[r0,#0x28]
;;;252      
;;;253      if ((TIMx == TIM1)|| (TIMx == TIM6) || (TIMx == TIM7))  
00002c  4b06              LDR      r3,|L88.72|
00002e  4298              CMP      r0,r3
000030  d005              BEQ      |L88.62|
000032  4b07              LDR      r3,|L88.80|
000034  4298              CMP      r0,r3
000036  d002              BEQ      |L88.62|
000038  4b06              LDR      r3,|L88.84|
00003a  4298              CMP      r0,r3
00003c  d101              BNE      |L88.66|
                  |L88.62|
;;;254      {
;;;255        /* Set the Repetition Counter value */
;;;256        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
00003e  7a8b              LDRB     r3,[r1,#0xa]
000040  6303              STR      r3,[r0,#0x30]
                  |L88.66|
;;;257      }
;;;258      
;;;259      /* Generate an update event to reload the Prescaler and the Repetition counter
;;;260      values immediately */
;;;261      TIMx->EGR = TIM_PSCReloadMode_Immediate;           
000042  2301              MOVS     r3,#1
000044  6143              STR      r3,[r0,#0x14]
;;;262    }
000046  4770              BX       lr
;;;263    
                          ENDP

                  |L88.72|
                          DCD      0x40010000
                  |L88.76|
                          DCD      0x40010400
                  |L88.80|
                          DCD      0x40000c00
                  |L88.84|
                          DCD      0x40001000

                          AREA ||i.TIM_TimeBaseStructInit||, CODE, READONLY, ALIGN=1

                  TIM_TimeBaseStructInit PROC
;;;269    */
;;;270    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  f64f71ff          MOV      r1,#0xffff
;;;271    {
;;;272      /* Set the default configuration */
;;;273      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
000004  6041              STR      r1,[r0,#4]
;;;274      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
000006  2100              MOVS     r1,#0
000008  8001              STRH     r1,[r0,#0]
;;;275      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
00000a  8101              STRH     r1,[r0,#8]
;;;276      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
00000c  8041              STRH     r1,[r0,#2]
;;;277      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
00000e  7281              STRB     r1,[r0,#0xa]
;;;278    }
000010  4770              BX       lr
;;;279    
                          ENDP


                          AREA ||i.TIM_UpdateDisableConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateDisableConfig PROC
;;;418    */
;;;419    void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L90.12|
;;;420    {
;;;421      /* Check the parameters */
;;;422      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;423      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;424      
;;;425      if (NewState != DISABLE)
;;;426      {
;;;427        /* Set the Update Disable Bit */
;;;428        TIMx->CR1 |= TIM_CR1_UDIS;
000002  6802              LDR      r2,[r0,#0]
000004  f0420202          ORR      r2,r2,#2
000008  6002              STR      r2,[r0,#0]
00000a  e004              B        |L90.22|
                  |L90.12|
;;;429      }
;;;430      else
;;;431      {
;;;432        /* Reset the Update Disable Bit */
;;;433        TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_UDIS);
00000c  6802              LDR      r2,[r0,#0]
00000e  f64f73fd          MOV      r3,#0xfffd
000012  401a              ANDS     r2,r2,r3
000014  6002              STR      r2,[r0,#0]
                  |L90.22|
;;;434      }
;;;435    }
000016  4770              BX       lr
;;;436    
                          ENDP


                          AREA ||i.TIM_UpdateRequestConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateRequestConfig PROC
;;;451    */
;;;452    void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
000000  b121              CBZ      r1,|L91.12|
;;;453    {
;;;454      /* Check the parameters */
;;;455      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;456      assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;457      
;;;458      if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;459      {
;;;460        /* Set the URS Bit */
;;;461        TIMx->CR1 |= TIM_CR1_URS;
000002  6802              LDR      r2,[r0,#0]
000004  f0420204          ORR      r2,r2,#4
000008  6002              STR      r2,[r0,#0]
00000a  e004              B        |L91.22|
                  |L91.12|
;;;462      }
;;;463      else
;;;464      {
;;;465        /* Reset the URS Bit */
;;;466        TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_URS);
00000c  6802              LDR      r2,[r0,#0]
00000e  f64f73fb          MOV      r3,#0xfffb
000012  401a              ANDS     r2,r2,r3
000014  6002              STR      r2,[r0,#0]
                  |L91.22|
;;;467      }
;;;468    }
000016  4770              BX       lr
;;;469    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Hal_lib\\src\\HAL_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_HAL_tim_c_c458916b____REV16|
#line 388 "..\\CMSIS_and_startup\\CMSIS\\cmsis_armcc.h"
|__asm___9_HAL_tim_c_c458916b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_HAL_tim_c_c458916b____REVSH|
#line 402
|__asm___9_HAL_tim_c_c458916b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_HAL_tim_c_c458916b____RRX|
#line 587
|__asm___9_HAL_tim_c_c458916b____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
