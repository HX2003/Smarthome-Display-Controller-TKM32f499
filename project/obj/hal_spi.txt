; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\hal_spi.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\hal_spi.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CMSIS_and_startup -I..\CMSIS_and_startup\CMSIS -I.\bsp -I..\Hal_lib\inc -I.\bsp\LCD -I.\bsp\LED -I.\bsp\SPI -I.\bsp\sys -I.\bsp\UART -I.\bsp\Timer -I.\bsp\exit -I.\bsp\touchpad -I.\RTE\_TK499_LTDC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.5.1\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=527 -DARMCM4_FP --omf_browse=.\obj\hal_spi.crf ..\Hal_lib\src\HAL_spi.c]
                          THUMB

                          AREA ||i.SPI_BiDirectionalLineConfig||, CODE, READONLY, ALIGN=1

                  SPI_BiDirectionalLineConfig PROC
;;;444    */
;;;445    void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
000000  2908              CMP      r1,#8
;;;446    {
;;;447      /* Check the parameters */
;;;448      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;449      assert_param(IS_SPI_DIRECTION(SPI_Direction));
;;;450      
;;;451      /* Set the Tx  only mode */
;;;452      if(SPI_Direction==SPI_Direction_Tx)
000002  d103              BNE      |L1.12|
;;;453      {
;;;454        SPIx->GCTL |= SPI_Direction_Tx;
000004  6982              LDR      r2,[r0,#0x18]
000006  f0420208          ORR      r2,r2,#8
00000a  6182              STR      r2,[r0,#0x18]
                  |L1.12|
;;;455      }
;;;456      /* Set the  Rx  only mode */
;;;457      if(SPI_Direction==SPI_Direction_Rx)
00000c  2910              CMP      r1,#0x10
00000e  d103              BNE      |L1.24|
;;;458      {
;;;459        SPIx->GCTL |= SPI_Direction_Rx;
000010  6982              LDR      r2,[r0,#0x18]
000012  f0420210          ORR      r2,r2,#0x10
000016  6182              STR      r2,[r0,#0x18]
                  |L1.24|
;;;460      }
;;;461      /* Disable the  Tx  only mode */
;;;462      if(SPI_Direction==SPI_Disable_Tx)
000018  f64f72f7          MOV      r2,#0xfff7
00001c  4291              CMP      r1,r2
00001e  d103              BNE      |L1.40|
;;;463      {
;;;464        SPIx->GCTL &= SPI_Disable_Tx;
000020  6982              LDR      r2,[r0,#0x18]
000022  460b              MOV      r3,r1
000024  401a              ANDS     r2,r2,r3
000026  6182              STR      r2,[r0,#0x18]
                  |L1.40|
;;;465      }
;;;466      /* Disable the  Rx  only mode */
;;;467      if(SPI_Direction==SPI_Disable_Rx)
000028  f64f72ef          MOV      r2,#0xffef
00002c  4291              CMP      r1,r2
00002e  d103              BNE      |L1.56|
;;;468      {
;;;469        SPIx->GCTL &= SPI_Disable_Rx;
000030  6982              LDR      r2,[r0,#0x18]
000032  460b              MOV      r3,r1
000034  401a              ANDS     r2,r2,r3
000036  6182              STR      r2,[r0,#0x18]
                  |L1.56|
;;;470      }
;;;471    }
000038  4770              BX       lr
;;;472    
                          ENDP


                          AREA ||i.SPI_CSInternalSelected||, CODE, READONLY, ALIGN=1

                  SPI_CSInternalSelected PROC
;;;388    */
;;;389    void SPI_CSInternalSelected(SPI_TypeDef* SPIx, uint16_t SPI_CSInternalSelected,FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;390    {
;;;391      /* Check the parameters */
;;;392      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;393      assert_param(IS_SPI_CS(SPI_CSInternalSelected));
;;;394      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;395      
;;;396      
;;;397      if (NewState != DISABLE)
000002  b11a              CBZ      r2,|L2.12|
;;;398      {
;;;399        /* selected cs pin according SCSR Value */
;;;400        SPIx->SCSR &= SPI_CSInternalSelected;
000004  6a83              LDR      r3,[r0,#0x28]
000006  400b              ANDS     r3,r3,r1
000008  6283              STR      r3,[r0,#0x28]
00000a  e003              B        |L2.20|
                  |L2.12|
;;;401      }
;;;402      else
;;;403      {
;;;404        /* release cs pin according SCSR Value*/
;;;405        SPIx->SCSR |= ~SPI_CSInternalSelected;
00000c  6a83              LDR      r3,[r0,#0x28]
00000e  ea630301          ORN      r3,r3,r1
000012  6283              STR      r3,[r0,#0x28]
                  |L2.20|
;;;406      }
;;;407    }
000014  bd10              POP      {r4,pc}
;;;408    
                          ENDP


                          AREA ||i.SPI_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  SPI_ClearITPendingBit PROC
;;;555    */
;;;556    void SPI_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_IT)
000000  6942              LDR      r2,[r0,#0x14]
;;;557    {
;;;558      
;;;559      /* Check the parameters */
;;;560      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;561      assert_param(IS_SPI_CLEAR_IT(SPI_IT));
;;;562      
;;;563      /* Clear the selected SPI IT INTERRUPT */
;;;564      SPIx->INTCLR |= (uint16_t)SPI_IT;
000002  430a              ORRS     r2,r2,r1
000004  6142              STR      r2,[r0,#0x14]
;;;565    }
000006  4770              BX       lr
;;;566    
                          ENDP


                          AREA ||i.SPI_Cmd||, CODE, READONLY, ALIGN=1

                  SPI_Cmd PROC
;;;216    */
;;;217    void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  b121              CBZ      r1,|L4.12|
;;;218    {
;;;219      /* Check the parameters */
;;;220      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;221      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;222      if (NewState != DISABLE)
;;;223      {
;;;224        /* Enable the selected SPI peripheral */
;;;225        SPIx->GCTL |= GCTL_SPIEN_Set;
000002  6982              LDR      r2,[r0,#0x18]
000004  f0420201          ORR      r2,r2,#1
000008  6182              STR      r2,[r0,#0x18]
00000a  e004              B        |L4.22|
                  |L4.12|
;;;226      }
;;;227      else
;;;228      {
;;;229        /* Disable the selected SPI peripheral */
;;;230        SPIx->GCTL &= GCTL_SPIEN_Reset;
00000c  6982              LDR      r2,[r0,#0x18]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  6182              STR      r2,[r0,#0x18]
                  |L4.22|
;;;231      }
;;;232    }
000016  4770              BX       lr
;;;233    
                          ENDP


                          AREA ||i.SPI_DMACmd||, CODE, READONLY, ALIGN=1

                  SPI_DMACmd PROC
;;;289    */
;;;290    void SPI_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_DMAReq, FunctionalState NewState)
000000  b11a              CBZ      r2,|L5.10|
;;;291    {
;;;292      /* Check the parameters */
;;;293      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;294      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;295      assert_param(IS_SPI_DMAREQ(SPI_DMAReq));
;;;296      if (NewState != DISABLE)
;;;297      {
;;;298        /* Enable the selected SPI DMA requests */
;;;299        SPIx->GCTL |= SPI_DMAReq;
000002  6983              LDR      r3,[r0,#0x18]
000004  430b              ORRS     r3,r3,r1
000006  6183              STR      r3,[r0,#0x18]
000008  e002              B        |L5.16|
                  |L5.10|
;;;300      }
;;;301      else
;;;302      {
;;;303        /* Disable the selected SPI DMA requests */
;;;304        SPIx->GCTL &= (uint32_t)~SPI_DMAReq;
00000a  6983              LDR      r3,[r0,#0x18]
00000c  438b              BICS     r3,r3,r1
00000e  6183              STR      r3,[r0,#0x18]
                  |L5.16|
;;;305      }
;;;306    }
000010  4770              BX       lr
;;;307    
                          ENDP


                          AREA ||i.SPI_DataSizeConfig||, CODE, READONLY, ALIGN=1

                  SPI_DataSizeConfig PROC
;;;418    */
;;;419    void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
000000  6982              LDR      r2,[r0,#0x18]
;;;420    {
;;;421      /* Check the parameters */
;;;422      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;423      assert_param(IS_SPI_DATASIZE(SPI_DataSize));
;;;424      /* Clear data_sel bit */
;;;425      SPIx->GCTL &= SPI_DataSize_Mask;
000002  f64f43ff          MOV      r3,#0xfcff
000006  401a              ANDS     r2,r2,r3
000008  6182              STR      r2,[r0,#0x18]
;;;426      /* Set new data_sel bit value */
;;;427      SPIx->GCTL |= SPI_DataSize;
00000a  6982              LDR      r2,[r0,#0x18]
00000c  430a              ORRS     r2,r2,r1
00000e  6182              STR      r2,[r0,#0x18]
;;;428    }
000010  4770              BX       lr
;;;429    
                          ENDP


                          AREA ||i.SPI_DeInit||, CODE, READONLY, ALIGN=2

                  SPI_DeInit PROC
;;;94     */
;;;95     void SPI_DeInit(SPI_TypeDef* SPIx)
000000  b510              PUSH     {r4,lr}
;;;96     {
000002  4604              MOV      r4,r0
;;;97       /* Check the parameters */
;;;98       assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;99       
;;;100      switch (*(uint32_t*)&SPIx)
000004  4807              LDR      r0,|L7.36|
000006  4420              ADD      r0,r0,r4
000008  b948              CBNZ     r0,|L7.30|
;;;101      {
;;;102      case SPI1_BASE:
;;;103        /* Enable SPI1 reset state */
;;;104        RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0508              LSLS     r0,r1,#20
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;105        /* Release SPI1 from reset state */
;;;106        RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
000012  2100              MOVS     r1,#0
000014  f44f1080          MOV      r0,#0x100000
000018  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;107        break;
00001c  e000              B        |L7.32|
                  |L7.30|
;;;108      default:
;;;109        break;
00001e  bf00              NOP      
                  |L7.32|
000020  bf00              NOP                            ;107
;;;110      }
;;;111    }
000022  bd10              POP      {r4,pc}
;;;112    
                          ENDP

                  |L7.36|
                          DCD      0xbffeb000

                          AREA ||i.SPI_FifoTrigger||, CODE, READONLY, ALIGN=1

                  SPI_FifoTrigger PROC
;;;320    */
;;;321    void SPI_FifoTrigger(SPI_TypeDef* SPIx, uint16_t SPI_FifoTriggerValue, FunctionalState NewState)
000000  b11a              CBZ      r2,|L8.10|
;;;322    {
;;;323      /* Check the parameters */
;;;324      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;325      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;326      assert_param(IS_SPI_FIFOTRIGGER(SPI_FifoTriggerValue));
;;;327      
;;;328      if (NewState != DISABLE)
;;;329      {
;;;330        /* Enable the selected SPI DMA requests */
;;;331        SPIx->GCTL |= SPI_FifoTriggerValue;
000002  6983              LDR      r3,[r0,#0x18]
000004  430b              ORRS     r3,r3,r1
000006  6183              STR      r3,[r0,#0x18]
000008  e002              B        |L8.16|
                  |L8.10|
;;;332      }
;;;333      else
;;;334      {
;;;335        /* Disable the selected SPI DMA requests */
;;;336        SPIx->GCTL &= (uint32_t)~SPI_FifoTriggerValue;
00000a  6983              LDR      r3,[r0,#0x18]
00000c  438b              BICS     r3,r3,r1
00000e  6183              STR      r3,[r0,#0x18]
                  |L8.16|
;;;337      }
;;;338    }
000010  4770              BX       lr
;;;339    
                          ENDP


                          AREA ||i.SPI_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  SPI_GetFlagStatus PROC
;;;482    */
;;;483    FlagStatus SPI_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_FLAG)
000000  4602              MOV      r2,r0
;;;484    {
;;;485      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;486      /* Check the parameters */
;;;487      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;488      assert_param(IS_SPI_GET_FLAG(SPI_FLAG));
;;;489      /* Check the status of the specified SPI flag */
;;;490      if ((SPIx->CSTAT & SPI_FLAG) != (uint16_t)RESET)
000004  6893              LDR      r3,[r2,#8]
000006  400b              ANDS     r3,r3,r1
000008  b10b              CBZ      r3,|L9.14|
;;;491      {
;;;492        /* SPI_FLAG is set */
;;;493        bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L9.16|
                  |L9.14|
;;;494      }
;;;495      else
;;;496      {
;;;497        /* SPI_FLAG is reset */
;;;498        bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L9.16|
;;;499      }
;;;500      /* Return the SPI_FLAG status */
;;;501      return  bitstatus;
;;;502    }
000010  4770              BX       lr
;;;503    
                          ENDP


                          AREA ||i.SPI_GetITStatus||, CODE, READONLY, ALIGN=1

                  SPI_GetITStatus PROC
;;;518    */
;;;519    ITStatus SPI_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_IT)
000000  4602              MOV      r2,r0
;;;520    {
;;;521      ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;522      
;;;523      /* Check the parameters */
;;;524      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;525      assert_param(IS_SPI_GET_IT(SPI_IT));
;;;526      /* Check the status of the specified SPI interrupt */
;;;527      if ((SPIx->INTSTAT & SPI_IT) != (uint16_t)RESET)
000004  68d3              LDR      r3,[r2,#0xc]
000006  400b              ANDS     r3,r3,r1
000008  b10b              CBZ      r3,|L10.14|
;;;528      {
;;;529        /* SPI_IT is set */
;;;530        bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L10.16|
                  |L10.14|
;;;531      }
;;;532      else
;;;533      {
;;;534        /* SPI_IT is reset */
;;;535        bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L10.16|
;;;536      }
;;;537      /* Return the SPI_IT status */
;;;538      return bitstatus;
;;;539    }
000010  4770              BX       lr
;;;540    
                          ENDP


                          AREA ||i.SPI_ITConfig||, CODE, READONLY, ALIGN=1

                  SPI_ITConfig PROC
;;;252    */
;;;253    void SPI_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;254    {
;;;255      /* Check the parameters */
;;;256      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;257      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;258      assert_param(IS_SPI_CONFIG_IT(SPI_IT));
;;;259      
;;;260      if (NewState != DISABLE)
000002  b13a              CBZ      r2,|L11.20|
;;;261      {
;;;262        /* Enable the selected SPI Global interrupt */
;;;263        SPIx->GCTL |= SPI_INT_EN;
000004  6983              LDR      r3,[r0,#0x18]
000006  f0430302          ORR      r3,r3,#2
00000a  6183              STR      r3,[r0,#0x18]
;;;264        /* Enable the selected SPI interrupt */
;;;265        SPIx->INTEN |= SPI_IT;
00000c  6903              LDR      r3,[r0,#0x10]
00000e  430b              ORRS     r3,r3,r1
000010  6103              STR      r3,[r0,#0x10]
000012  e009              B        |L11.40|
                  |L11.20|
;;;266      }
;;;267      else
;;;268      {
;;;269        /* Disable the selected SPI interrupt */
;;;270        SPIx->INTEN &= (uint16_t)~SPI_IT;
000014  6903              LDR      r3,[r0,#0x10]
000016  43cc              MVNS     r4,r1
000018  b2a4              UXTH     r4,r4
00001a  4023              ANDS     r3,r3,r4
00001c  6103              STR      r3,[r0,#0x10]
;;;271        /* Disable the selected SPI Global interrupt */
;;;272        SPIx->GCTL &= (uint16_t)~SPI_INT_EN;
00001e  6983              LDR      r3,[r0,#0x18]
000020  f64f74fd          MOV      r4,#0xfffd
000024  4023              ANDS     r3,r3,r4
000026  6183              STR      r3,[r0,#0x18]
                  |L11.40|
;;;273      }
;;;274      
;;;275    }
000028  bd10              POP      {r4,pc}
;;;276    
                          ENDP


                          AREA ||i.SPI_Init||, CODE, READONLY, ALIGN=1

                  SPI_Init PROC
;;;121    */
;;;122    void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
000000  b510              PUSH     {r4,lr}
;;;123    {
000002  4602              MOV      r2,r0
;;;124      uint32_t tmpreg = 0;
000004  2000              MOVS     r0,#0
;;;125      
;;;126      /* check the parameters */
;;;127      assert_param(IS_SPI_ALL_PERIPH(SPIx));   
;;;128      
;;;129      /* Check the SPI parameters */
;;;130      assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
;;;131      assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
;;;132      assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
;;;133      assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
;;;134      assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
;;;135      assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
;;;136      assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
;;;137      assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
;;;138      assert_param(IS_SPI_DATAWIDRH(SPI_InitStruct->SPI_DataWidth));
;;;139      assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
;;;140      /*---------------------------- SPIx GCTL Configuration ------------------------*/
;;;141      /* Get the SPIx GCTL value */
;;;142      tmpreg = SPIx->GCTL;
000006  6990              LDR      r0,[r2,#0x18]
;;;143      /* Clear csn_sel, dmamode, txtlf, rxtlf,data_sel, rxen, txen, mm, int_en, spien bits */
;;;144      tmpreg &= GCTL_CLEAR_Mask;
000008  f4004070          AND      r0,r0,#0xf000
;;;145      /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
;;;146      master/salve mode, CPOL and CPHA */
;;;147      /* Set dat_sel bits according to SPI_DataSize value */
;;;148      /* Set csn and csn_sel bits according to SPI_NSS value */
;;;149      /* Set mm bit according to SPI_Mode value */
;;;150      tmpreg |= (uint32_t)((uint32_t) SPI_InitStruct->SPI_DataSize   |  SPI_InitStruct->SPI_NSS | 
00000c  884b              LDRH     r3,[r1,#2]
00000e  894c              LDRH     r4,[r1,#0xa]
000010  4323              ORRS     r3,r3,r4
000012  880c              LDRH     r4,[r1,#0]
000014  4323              ORRS     r3,r3,r4
000016  4318              ORRS     r0,r0,r3
;;;151                           SPI_InitStruct->SPI_Mode  );
;;;152      /* Write to SPIx GCTL */
;;;153    //	if(SPI_InitStruct->SPI_DataSize==SPI_DataSize_8b) tmpreg |= 0x1000;
;;;154      SPIx->GCTL = tmpreg;
000018  6190              STR      r0,[r2,#0x18]
;;;155      /*---------------------------- SPIx CCTL Configuration ------------------------*/	
;;;156      tmpreg = SPIx->CCTL;
00001a  69d0              LDR      r0,[r2,#0x1c]
;;;157      /* Clear spilen, lsbfe, CPOL, CPHA bits */
;;;158      tmpreg &= CCTL_CLEAR_Mask;
00001c  f64f73c0          MOV      r3,#0xffc0
000020  4018              ANDS     r0,r0,r3
;;;159      /* Set Spilen bit according to SPI_DataWidth value */
;;;160      /* Set LSBFirst bit according to SPI_FirstBit value */
;;;161      /* Set CPOL bit according to SPI_CPOL value */
;;;162      /* Set CPHA bit according to SPI_CPHA value */
;;;163      tmpreg |= (uint16_t)((uint16_t)  SPI_InitStruct->SPI_DataWidth | SPI_InitStruct->SPI_FirstBit   |  SPI_InitStruct->SPI_CPOL | 
000022  888b              LDRH     r3,[r1,#4]
000024  89cc              LDRH     r4,[r1,#0xe]
000026  4323              ORRS     r3,r3,r4
000028  88cc              LDRH     r4,[r1,#6]
00002a  4323              ORRS     r3,r3,r4
00002c  890c              LDRH     r4,[r1,#8]
00002e  4323              ORRS     r3,r3,r4
000030  4318              ORRS     r0,r0,r3
;;;164                           SPI_InitStruct->SPI_CPHA  );
;;;165      
;;;166      /* Write to SPIx CCTL */
;;;167      SPIx->CCTL = tmpreg;
000032  61d0              STR      r0,[r2,#0x1c]
;;;168      
;;;169      /*---------------------------- SPIx SPBRG Configuration ------------------------*/	
;;;170      tmpreg = SPIx->SPBRG;
000034  6a10              LDR      r0,[r2,#0x20]
;;;171      /* Clear spbrg bits */
;;;172      tmpreg &= (uint16_t)SPBRG_CLEAR_Mask;	
000036  2000              MOVS     r0,#0
;;;173      /* Set BR bits according to SPI_BaudRatePrescaler value */
;;;174      tmpreg |= (uint16_t) SPI_InitStruct->SPI_BaudRatePrescaler;
000038  898b              LDRH     r3,[r1,#0xc]
00003a  4318              ORRS     r0,r0,r3
;;;175      /* Write to SPIx SPBRG */
;;;176      SPIx->SPBRG = tmpreg;
00003c  6210              STR      r0,[r2,#0x20]
;;;177      
;;;178    }
00003e  bd10              POP      {r4,pc}
;;;179    
                          ENDP


                          AREA ||i.SPI_ReceiveData||, CODE, READONLY, ALIGN=1

                  SPI_ReceiveData PROC
;;;361    */
;;;362    uint16_t SPI_ReceiveData(SPI_TypeDef* SPIx)
000000  4601              MOV      r1,r0
;;;363    {
;;;364      /* Check the parameters */
;;;365      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;366      
;;;367      /* Return the data in the RXREG register */
;;;368      return SPIx->RXREG;
000002  6848              LDR      r0,[r1,#4]
000004  b280              UXTH     r0,r0
;;;369    }
000006  4770              BX       lr
;;;370    
                          ENDP


                          AREA ||i.SPI_RxBytes||, CODE, READONLY, ALIGN=1

                  SPI_RxBytes PROC
;;;575    */
;;;576    void SPI_RxBytes(SPI_TypeDef* SPIx, uint16_t Number)
000000  6241              STR      r1,[r0,#0x24]
;;;577    {
;;;578      /* Check the parameters */
;;;579      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;580      /*set the received bytes in next receive process */
;;;581      SPIx->RXDNR = Number;
;;;582    }
000002  4770              BX       lr
;;;583    
                          ENDP


                          AREA ||i.SPI_SendData||, CODE, READONLY, ALIGN=1

                  SPI_SendData PROC
;;;346    */
;;;347    void SPI_SendData(SPI_TypeDef* SPIx, uint16_t Data)
000000  6001              STR      r1,[r0,#0]
;;;348    {
;;;349      /* Check the parameters */
;;;350      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;351      
;;;352      /* Write in the TXREG register the data to be sent */
;;;353      SPIx->TXREG = Data;
;;;354    }
000002  4770              BX       lr
;;;355    
                          ENDP


                          AREA ||i.SPI_SlaveAdjust||, CODE, READONLY, ALIGN=1

                  SPI_SlaveAdjust PROC
;;;593    */
;;;594    void SPI_SlaveAdjust(SPI_TypeDef* SPIx, uint16_t AdjustValue)
000000  69c2              LDR      r2,[r0,#0x1c]
;;;595    {
;;;596      /* Check the parameters */
;;;597      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;598      assert_param(IS_SPI_SlaveAdjust(AdjustValue));
;;;599      /*set the AdjustValue according to txedge bit of CCTL register*/
;;;600      SPIx->CCTL |= AdjustValue;
000002  430a              ORRS     r2,r2,r1
000004  61c2              STR      r2,[r0,#0x1c]
;;;601    }
000006  4770              BX       lr
;;;602    
                          ENDP


                          AREA ||i.SPI_StructInit||, CODE, READONLY, ALIGN=1

                  SPI_StructInit PROC
;;;185    */
;;;186    void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
000000  2100              MOVS     r1,#0
;;;187    {
;;;188      /*--------------- Reset SPI init structure parameters values -----------------*/
;;;189      
;;;190      /* initialize the SPI_Mode member */
;;;191      SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
000002  8001              STRH     r1,[r0,#0]
;;;192      /* initialize the SPI_DataSize member */
;;;193      SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
000004  8041              STRH     r1,[r0,#2]
;;;194      /* Initialize the SPILEN member */
;;;195      SPI_InitStruct->SPI_DataWidth = SPI_DataWidth_8b;
000006  2108              MOVS     r1,#8
000008  8081              STRH     r1,[r0,#4]
;;;196      /* Initialize the SPI_CPOL member */
;;;197      SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
00000a  2100              MOVS     r1,#0
00000c  80c1              STRH     r1,[r0,#6]
;;;198      /* Initialize the SPI_CPHA member */
;;;199      SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
00000e  2101              MOVS     r1,#1
000010  8101              STRH     r1,[r0,#8]
;;;200      /* Initialize the SPI_NSS member */
;;;201      SPI_InitStruct->SPI_NSS = SPI_NSS_Soft;
000012  2100              MOVS     r1,#0
000014  8141              STRH     r1,[r0,#0xa]
;;;202      /* Initialize the SPI_BaudRatePrescaler member */
;;;203      SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
000016  2102              MOVS     r1,#2
000018  8181              STRH     r1,[r0,#0xc]
;;;204      /* Initialize the SPI_FirstBit member */
;;;205      SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
00001a  2100              MOVS     r1,#0
00001c  81c1              STRH     r1,[r0,#0xe]
;;;206      
;;;207    }
00001e  4770              BX       lr
;;;208    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Hal_lib\\src\\HAL_spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_HAL_spi_c_a2ad70c2____REV16|
#line 388 "..\\CMSIS_and_startup\\CMSIS\\cmsis_armcc.h"
|__asm___9_HAL_spi_c_a2ad70c2____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_HAL_spi_c_a2ad70c2____REVSH|
#line 402
|__asm___9_HAL_spi_c_a2ad70c2____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_HAL_spi_c_a2ad70c2____RRX|
#line 587
|__asm___9_HAL_spi_c_a2ad70c2____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
