; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\hal_gpio.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\hal_gpio.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CMSIS_and_startup -I..\CMSIS_and_startup\CMSIS -I.\bsp -I..\Hal_lib\inc -I.\bsp\LCD -I.\bsp\LED -I.\bsp\SPI -I.\bsp\sys -I.\bsp\UART -I.\bsp\Timer -I.\bsp\exit -I.\bsp\touchpad -I.\RTE\_TK499_LTDC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.5.1\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=527 -DARMCM4_FP --omf_browse=.\obj\hal_gpio.crf ..\Hal_lib\src\HAL_gpio.c]
                          THUMB

                          AREA ||i.GPIO_DeInit||, CODE, READONLY, ALIGN=2

                  GPIO_DeInit PROC
;;;99     */
;;;100    void GPIO_DeInit(GPIO_TypeDef* GPIOx)
000000  b510              PUSH     {r4,lr}
;;;101    {
000002  4604              MOV      r4,r0
;;;102      /* Check the parameters */
;;;103      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;104      
;;;105      switch (*(uint32_t*)&GPIOx)
000004  4819              LDR      r0,|L1.108|
000006  4420              ADD      r0,r0,r4
000008  b148              CBZ      r0,|L1.30|
00000a  f5b06f80          CMP      r0,#0x400
00000e  d00f              BEQ      |L1.48|
000010  f5b06f00          CMP      r0,#0x800
000014  d015              BEQ      |L1.66|
000016  f5b06f40          CMP      r0,#0xc00
00001a  d124              BNE      |L1.102|
00001c  e01a              B        |L1.84|
                  |L1.30|
;;;106      {
;;;107      case GPIOA_BASE:
;;;108        RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
00001e  2101              MOVS     r1,#1
000020  4608              MOV      r0,r1
000022  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;109        RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, DISABLE);
000026  2100              MOVS     r1,#0
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;110        break;
00002e  e01b              B        |L1.104|
                  |L1.48|
;;;111      case GPIOB_BASE:
;;;112        RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
000030  2101              MOVS     r1,#1
000032  2002              MOVS     r0,#2
000034  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;113        RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, DISABLE);
000038  2100              MOVS     r1,#0
00003a  2002              MOVS     r0,#2
00003c  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;114        break;
000040  e012              B        |L1.104|
                  |L1.66|
;;;115      case GPIOC_BASE:
;;;116        RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOC, ENABLE);
000042  2101              MOVS     r1,#1
000044  2004              MOVS     r0,#4
000046  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;117        RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOC, DISABLE);
00004a  2100              MOVS     r1,#0
00004c  2004              MOVS     r0,#4
00004e  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;118        break;
000052  e009              B        |L1.104|
                  |L1.84|
;;;119      case GPIOD_BASE:
;;;120        RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOD, ENABLE);
000054  2101              MOVS     r1,#1
000056  2008              MOVS     r0,#8
000058  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;121        RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOD, DISABLE);
00005c  2100              MOVS     r1,#0
00005e  2008              MOVS     r0,#8
000060  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;122        break;
000064  e000              B        |L1.104|
                  |L1.102|
;;;123      default:
;;;124        break;
000066  bf00              NOP      
                  |L1.104|
000068  bf00              NOP                            ;110
;;;125      }
;;;126    }
00006a  bd10              POP      {r4,pc}
;;;127    
                          ENDP

                  |L1.108|
                          DCD      0xbffe0000

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;137    */
;;;138    void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;139    {
000004  4603              MOV      r3,r0
;;;140      uint32_t currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
000006  2500              MOVS     r5,#0
000008  2600              MOVS     r6,#0
00000a  2000              MOVS     r0,#0
00000c  2200              MOVS     r2,#0
;;;141      uint32_t tmpreg = 0x00, pinmask = 0x00;
00000e  2400              MOVS     r4,#0
000010  2700              MOVS     r7,#0
;;;142      /* Check the parameters */
;;;143      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;144      assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
;;;145      assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
;;;146      
;;;147      /*---------------------------- GPIO Mode Configuration -----------------------*/
;;;148      currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
000012  f891c005          LDRB     r12,[r1,#5]
000016  f00c050f          AND      r5,r12,#0xf
;;;149      if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
00001a  f891c005          LDRB     r12,[r1,#5]
00001e  f00c0c10          AND      r12,r12,#0x10
000022  f1bc0f00          CMP      r12,#0
000026  d003              BEQ      |L2.48|
;;;150      { 
;;;151        /* Check the parameters */
;;;152        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
;;;153        /* Output mode */
;;;154        currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
000028  f891c004          LDRB     r12,[r1,#4]
00002c  ea4c0505          ORR      r5,r12,r5
                  |L2.48|
;;;155      }
;;;156      /*---------------------------- GPIO CRL Configuration ------------------------*/
;;;157      /* Configure the eight low port pins */
;;;158      if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
000030  f891c000          LDRB     r12,[r1,#0]
000034  f1bc0f00          CMP      r12,#0
000038  d031              BEQ      |L2.158|
;;;159      {
;;;160        tmpreg = GPIOx->CRL;
00003a  681c              LDR      r4,[r3,#0]
;;;161        for (pinpos = 0x00; pinpos < 0x08; pinpos++)
00003c  2000              MOVS     r0,#0
00003e  e02b              B        |L2.152|
                  |L2.64|
;;;162        {
;;;163          pos = ((uint32_t)0x01) << pinpos;
000040  f04f0c01          MOV      r12,#1
000044  fa0cf200          LSL      r2,r12,r0
;;;164          /* Get the port pins position */
;;;165          currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
000048  f8d1c000          LDR      r12,[r1,#0]
00004c  ea0c0602          AND      r6,r12,r2
;;;166          if (currentpin == pos)
000050  4296              CMP      r6,r2
000052  d120              BNE      |L2.150|
;;;167          {
;;;168            pos = pinpos << 2;
000054  0082              LSLS     r2,r0,#2
;;;169            /* Clear the corresponding low control register bits */
;;;170            pinmask = ((uint32_t)0x0F) << pos;
000056  f04f0c0f          MOV      r12,#0xf
00005a  fa0cf702          LSL      r7,r12,r2
;;;171            tmpreg &= ~pinmask;
00005e  43bc              BICS     r4,r4,r7
;;;172            /* Write the mode configuration in the corresponding bits */
;;;173            tmpreg |= (currentmode << pos);
000060  fa05fc02          LSL      r12,r5,r2
000064  ea4c0404          ORR      r4,r12,r4
;;;174            /* Reset the corresponding ODR bit */
;;;175            if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
000068  f891c005          LDRB     r12,[r1,#5]
00006c  f1bc0f28          CMP      r12,#0x28
000070  d106              BNE      |L2.128|
;;;176            {
;;;177              GPIOx->BRR = (((uint32_t)0x01) << pinpos);
000072  f04f0c01          MOV      r12,#1
000076  fa0cfc00          LSL      r12,r12,r0
00007a  f8c3c014          STR      r12,[r3,#0x14]
00007e  e00a              B        |L2.150|
                  |L2.128|
;;;178            }
;;;179            else
;;;180            {
;;;181              /* Set the corresponding ODR bit */
;;;182              if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
000080  f891c005          LDRB     r12,[r1,#5]
000084  f1bc0f48          CMP      r12,#0x48
000088  d105              BNE      |L2.150|
;;;183              {
;;;184                GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
00008a  f04f0c01          MOV      r12,#1
00008e  fa0cfc00          LSL      r12,r12,r0
000092  f8c3c010          STR      r12,[r3,#0x10]
                  |L2.150|
000096  1c40              ADDS     r0,r0,#1              ;161
                  |L2.152|
000098  2808              CMP      r0,#8                 ;161
00009a  d3d1              BCC      |L2.64|
;;;185              }
;;;186            }
;;;187          }
;;;188        }
;;;189        GPIOx->CRL = tmpreg;
00009c  601c              STR      r4,[r3,#0]
                  |L2.158|
;;;190      }
;;;191      /*---------------------------- GPIO CRH Configuration ------------------------*/
;;;192      /* Configure the eight high port pins */
;;;193      if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
00009e  f8d1c000          LDR      r12,[r1,#0]
0000a2  f1bc0fff          CMP      r12,#0xff
0000a6  d934              BLS      |L2.274|
;;;194      {
;;;195        tmpreg = GPIOx->CRH;
0000a8  685c              LDR      r4,[r3,#4]
;;;196        for (pinpos = 0x00; pinpos < 0x08; pinpos++)
0000aa  2000              MOVS     r0,#0
0000ac  e02e              B        |L2.268|
                  |L2.174|
;;;197        {
;;;198          pos = (((uint32_t)0x01) << (pinpos + 0x08));
0000ae  f1000c08          ADD      r12,r0,#8
0000b2  f04f0801          MOV      r8,#1
0000b6  fa08f20c          LSL      r2,r8,r12
;;;199          /* Get the port pins position */
;;;200          currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
0000ba  f8d1c000          LDR      r12,[r1,#0]
0000be  ea0c0602          AND      r6,r12,r2
;;;201          if (currentpin == pos)
0000c2  4296              CMP      r6,r2
0000c4  d121              BNE      |L2.266|
;;;202          {
;;;203            pos = pinpos << 2;
0000c6  0082              LSLS     r2,r0,#2
;;;204            /* Clear the corresponding high control register bits */
;;;205            pinmask = ((uint32_t)0x0F) << pos;
0000c8  f04f0c0f          MOV      r12,#0xf
0000cc  fa0cf702          LSL      r7,r12,r2
;;;206            tmpreg &= ~pinmask;
0000d0  43bc              BICS     r4,r4,r7
;;;207            /* Write the mode configuration in the corresponding bits */
;;;208            tmpreg |= (currentmode << pos);
0000d2  fa05fc02          LSL      r12,r5,r2
0000d6  ea4c0404          ORR      r4,r12,r4
;;;209            /* Reset the corresponding ODR bit */
;;;210            if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
0000da  f891c005          LDRB     r12,[r1,#5]
0000de  f1bc0f28          CMP      r12,#0x28
0000e2  d105              BNE      |L2.240|
;;;211            {
;;;212              GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
0000e4  f1000c08          ADD      r12,r0,#8
0000e8  fa08f80c          LSL      r8,r8,r12
0000ec  f8c38014          STR      r8,[r3,#0x14]
                  |L2.240|
;;;213            }
;;;214            /* Set the corresponding ODR bit */
;;;215            if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
0000f0  f891c005          LDRB     r12,[r1,#5]
0000f4  f1bc0f48          CMP      r12,#0x48
0000f8  d107              BNE      |L2.266|
;;;216            {
;;;217              GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
0000fa  f1000c08          ADD      r12,r0,#8
0000fe  f04f0801          MOV      r8,#1
000102  fa08f80c          LSL      r8,r8,r12
000106  f8c38010          STR      r8,[r3,#0x10]
                  |L2.266|
00010a  1c40              ADDS     r0,r0,#1              ;196
                  |L2.268|
00010c  2808              CMP      r0,#8                 ;196
00010e  d3ce              BCC      |L2.174|
;;;218            }
;;;219          }
;;;220        }
;;;221        GPIOx->CRH = tmpreg;
000110  605c              STR      r4,[r3,#4]
                  |L2.274|
;;;222      }
;;;223    	/*---------------------------- GPIOE_CRH_EXT Configuration ------------------------*/
;;;224      if(GPIO_InitStruct->GPIO_Pin>>16)  //说明是GPIOE的16~23位	
000112  f8d1c000          LDR      r12,[r1,#0]
000116  ea4f4c1c          LSR      r12,r12,#16
00011a  f1bc0f00          CMP      r12,#0
00011e  d03d              BEQ      |L2.412|
;;;225      {
;;;226    		GPIO_InitStruct->GPIO_Pin = GPIO_InitStruct->GPIO_Pin>>16;
000120  f8d1c000          LDR      r12,[r1,#0]
000124  ea4f4c1c          LSR      r12,r12,#16
000128  f8c1c000          STR      r12,[r1,#0]
;;;227        tmpreg = GPIOE->CRH_EXT;
00012c  f8dfc070          LDR      r12,|L2.416|
000130  f8dc4028          LDR      r4,[r12,#0x28]
;;;228        for (pinpos = 0x00; pinpos < 0x08; pinpos++)
000134  2000              MOVS     r0,#0
000136  e02b              B        |L2.400|
                  |L2.312|
;;;229        {
;;;230          pos = ((uint32_t)0x01) << pinpos;
000138  f04f0c01          MOV      r12,#1
00013c  fa0cf200          LSL      r2,r12,r0
;;;231          /* Get the port pins position */
;;;232          currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
000140  f8d1c000          LDR      r12,[r1,#0]
000144  ea0c0602          AND      r6,r12,r2
;;;233          if (currentpin == pos)
000148  4296              CMP      r6,r2
00014a  d120              BNE      |L2.398|
;;;234          {
;;;235            pos = pinpos << 2;
00014c  0082              LSLS     r2,r0,#2
;;;236            /* Clear the corresponding low control register bits */
;;;237            pinmask = ((uint32_t)0x0F) << pos;
00014e  f04f0c0f          MOV      r12,#0xf
000152  fa0cf702          LSL      r7,r12,r2
;;;238            tmpreg &= ~pinmask;
000156  43bc              BICS     r4,r4,r7
;;;239            /* Write the mode configuration in the corresponding bits */
;;;240            tmpreg |= (currentmode << pos);
000158  fa05fc02          LSL      r12,r5,r2
00015c  ea4c0404          ORR      r4,r12,r4
;;;241            /* Reset the corresponding ODR bit */
;;;242            if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
000160  f891c005          LDRB     r12,[r1,#5]
000164  f1bc0f28          CMP      r12,#0x28
000168  d106              BNE      |L2.376|
;;;243            {
;;;244              GPIOx->BRR = (((uint32_t)0x01) << pinpos);
00016a  f04f0c01          MOV      r12,#1
00016e  fa0cfc00          LSL      r12,r12,r0
000172  f8c3c014          STR      r12,[r3,#0x14]
000176  e00a              B        |L2.398|
                  |L2.376|
;;;245            }
;;;246            else
;;;247            {
;;;248              /* Set the corresponding ODR bit */
;;;249              if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
000178  f891c005          LDRB     r12,[r1,#5]
00017c  f1bc0f48          CMP      r12,#0x48
000180  d105              BNE      |L2.398|
;;;250              {
;;;251                GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
000182  f04f0c01          MOV      r12,#1
000186  fa0cfc00          LSL      r12,r12,r0
00018a  f8c3c010          STR      r12,[r3,#0x10]
                  |L2.398|
00018e  1c40              ADDS     r0,r0,#1              ;228
                  |L2.400|
000190  2808              CMP      r0,#8                 ;228
000192  d3d1              BCC      |L2.312|
;;;252              }
;;;253            }
;;;254          }
;;;255        }
;;;256        GPIOE->CRH_EXT = tmpreg;
000194  f8dfc008          LDR      r12,|L2.416|
000198  f8cc4028          STR      r4,[r12,#0x28]
                  |L2.412|
;;;257      }
;;;258    }
00019c  e8bd81f0          POP      {r4-r8,pc}
;;;259    
                          ENDP

                  |L2.416|
                          DCD      0x40021000

                          AREA ||i.GPIO_PinAFConfig||, CODE, READONLY, ALIGN=2

                  GPIO_PinAFConfig PROC
;;;485    */
;;;486    void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint32_t GPIO_Pin, uint8_t GPIO_AF)
000000  b5f0              PUSH     {r4-r7,lr}
;;;487    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;488      uint32_t temp;
;;;489    	unsigned char i;
;;;490      
;;;491      /* Check the parameters */
;;;492      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;493      assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
;;;494      assert_param(IS_GPIO_AF(GPIO_AF));
;;;495    	
;;;496    	if(GPIO_Pin>>16)  //说明是GPIOE的16~23位
000006  0c25              LSRS     r5,r4,#16
000008  b1d5              CBZ      r5,|L3.64|
;;;497    	{
;;;498    		temp = GPIO_Pin>>16;
00000a  0c21              LSRS     r1,r4,#16
;;;499    		for(i=0;i<8;i++)
00000c  2000              MOVS     r0,#0
00000e  e015              B        |L3.60|
                  |L3.16|
;;;500    		{
;;;501    			if(temp&0x01)
000010  f0010501          AND      r5,r1,#1
000014  b17d              CBZ      r5,|L3.54|
;;;502    			{
;;;503    				GPIOE->AFRH_EXT &= ~((uint32_t)0xF << ((uint32_t)(i<<2)));     //AF配置占半字节，要x4,即<<2
000016  4d24              LDR      r5,|L3.168|
000018  6b2d              LDR      r5,[r5,#0x30]
00001a  0087              LSLS     r7,r0,#2
00001c  260f              MOVS     r6,#0xf
00001e  40be              LSLS     r6,r6,r7
000020  43b5              BICS     r5,r5,r6
000022  4e21              LDR      r6,|L3.168|
000024  6335              STR      r5,[r6,#0x30]
;;;504    				GPIOE->AFRH_EXT |= ((uint32_t)GPIO_AF << ((uint32_t)(i<<2)));
000026  4635              MOV      r5,r6
000028  6b2d              LDR      r5,[r5,#0x30]
00002a  0086              LSLS     r6,r0,#2
00002c  fa02f606          LSL      r6,r2,r6
000030  4335              ORRS     r5,r5,r6
000032  4e1d              LDR      r6,|L3.168|
000034  6335              STR      r5,[r6,#0x30]
                  |L3.54|
;;;505    			}
;;;506    			temp = temp>>1;
000036  0849              LSRS     r1,r1,#1
000038  1c45              ADDS     r5,r0,#1              ;499
00003a  b2e8              UXTB     r0,r5                 ;499
                  |L3.60|
00003c  2808              CMP      r0,#8                 ;499
00003e  dbe7              BLT      |L3.16|
                  |L3.64|
;;;507    		}
;;;508    	}
;;;509    	if(GPIO_Pin&0XFF00)  //说明是GPIOE的8~15位
000040  f404457f          AND      r5,r4,#0xff00
000044  b1b5              CBZ      r5,|L3.116|
;;;510    		{
;;;511    			temp = GPIO_Pin>>8;
000046  0a21              LSRS     r1,r4,#8
;;;512    			for(i=0;i<8;i++)
000048  2000              MOVS     r0,#0
00004a  e011              B        |L3.112|
                  |L3.76|
;;;513    			{
;;;514    				if(temp&0x01)
00004c  f0010501          AND      r5,r1,#1
000050  b15d              CBZ      r5,|L3.106|
;;;515    				{
;;;516    					GPIOx->AFRH &= ~((uint32_t)0xF << ((uint32_t)(i<<2)));     //AF配置占半字节，要x4,即<<2
000052  6a5d              LDR      r5,[r3,#0x24]
000054  0087              LSLS     r7,r0,#2
000056  260f              MOVS     r6,#0xf
000058  40be              LSLS     r6,r6,r7
00005a  43b5              BICS     r5,r5,r6
00005c  625d              STR      r5,[r3,#0x24]
;;;517    					GPIOx->AFRH |= ((uint32_t)GPIO_AF << ((uint32_t)(i<<2)));
00005e  6a5d              LDR      r5,[r3,#0x24]
000060  0086              LSLS     r6,r0,#2
000062  fa02f606          LSL      r6,r2,r6
000066  4335              ORRS     r5,r5,r6
000068  625d              STR      r5,[r3,#0x24]
                  |L3.106|
;;;518    				}
;;;519    				temp = temp>>1;
00006a  0849              LSRS     r1,r1,#1
00006c  1c45              ADDS     r5,r0,#1              ;512
00006e  b2e8              UXTB     r0,r5                 ;512
                  |L3.112|
000070  2808              CMP      r0,#8                 ;512
000072  dbeb              BLT      |L3.76|
                  |L3.116|
;;;520    			}
;;;521    		}
;;;522    	if(GPIO_Pin&0XFF)  //说明是GPIOE的0~7位
000074  b2e5              UXTB     r5,r4
000076  b1ad              CBZ      r5,|L3.164|
;;;523    		{
;;;524    			for(i=0;i<8;i++)
000078  2000              MOVS     r0,#0
00007a  e011              B        |L3.160|
                  |L3.124|
;;;525    			{
;;;526    				if(temp&0x01)
00007c  f0010501          AND      r5,r1,#1
000080  b15d              CBZ      r5,|L3.154|
;;;527    				{
;;;528    					GPIOx->AFRL &= ~((uint32_t)0xF << ((uint32_t)(i<<2)));     //AF配置占半字节，要x4,即<<2
000082  6a1d              LDR      r5,[r3,#0x20]
000084  0087              LSLS     r7,r0,#2
000086  260f              MOVS     r6,#0xf
000088  40be              LSLS     r6,r6,r7
00008a  43b5              BICS     r5,r5,r6
00008c  621d              STR      r5,[r3,#0x20]
;;;529    					GPIOx->AFRL |= ((uint32_t)GPIO_AF << ((uint32_t)(i<<2)));
00008e  6a1d              LDR      r5,[r3,#0x20]
000090  0086              LSLS     r6,r0,#2
000092  fa02f606          LSL      r6,r2,r6
000096  4335              ORRS     r5,r5,r6
000098  621d              STR      r5,[r3,#0x20]
                  |L3.154|
;;;530    				}
;;;531    				temp = temp>>1;
00009a  0849              LSRS     r1,r1,#1
00009c  1c45              ADDS     r5,r0,#1              ;524
00009e  b2e8              UXTB     r0,r5                 ;524
                  |L3.160|
0000a0  2808              CMP      r0,#8                 ;524
0000a2  dbeb              BLT      |L3.124|
                  |L3.164|
;;;532    			}
;;;533    		}
;;;534    }
0000a4  bdf0              POP      {r4-r7,pc}
;;;535    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L3.168|
                          DCD      0x40021000

                          AREA ||i.GPIO_PinLockConfig||, CODE, READONLY, ALIGN=1

                  GPIO_PinLockConfig PROC
;;;436    */
;;;437    void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  f44f3280          MOV      r2,#0x10000
;;;438    {
;;;439      uint32_t tmp = 0x00010000;
;;;440      
;;;441      /* Check the parameters */
;;;442      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;443      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;444      
;;;445      tmp |= GPIO_Pin;
000004  430a              ORRS     r2,r2,r1
;;;446      /* Set LCKK bit */
;;;447      GPIOx->LCKR = tmp;
000006  6182              STR      r2,[r0,#0x18]
;;;448      /* Reset LCKK bit */
;;;449      GPIOx->LCKR =  GPIO_Pin;
000008  6181              STR      r1,[r0,#0x18]
;;;450      /* Set LCKK bit */
;;;451      GPIOx->LCKR = tmp;
00000a  6182              STR      r2,[r0,#0x18]
;;;452      /* Read LCKK bit*/
;;;453      tmp = GPIOx->LCKR;
00000c  6982              LDR      r2,[r0,#0x18]
;;;454      /* Read LCKK bit*/
;;;455      tmp = GPIOx->LCKR;
00000e  6982              LDR      r2,[r0,#0x18]
;;;456    }
000010  4770              BX       lr
;;;457    
                          ENDP


                          AREA ||i.GPIO_ReadInputData||, CODE, READONLY, ALIGN=1

                  GPIO_ReadInputData PROC
;;;304    */
;;;305    uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
000000  4601              MOV      r1,r0
;;;306    {
;;;307      /* Check the parameters */
;;;308      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;309      
;;;310      return ((uint16_t)GPIOx->IDR);
000002  6888              LDR      r0,[r1,#8]
000004  b280              UXTH     r0,r0
;;;311    }
000006  4770              BX       lr
;;;312    
                          ENDP


                          AREA ||i.GPIO_ReadInputDataBit||, CODE, READONLY, ALIGN=1

                  GPIO_ReadInputDataBit PROC
;;;280    */
;;;281    uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  4602              MOV      r2,r0
;;;282    {
;;;283      uint8_t bitstatus = 0x00;
000002  2000              MOVS     r0,#0
;;;284      
;;;285      /* Check the parameters */
;;;286      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;287      assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
;;;288      
;;;289      if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
000004  6893              LDR      r3,[r2,#8]
000006  400b              ANDS     r3,r3,r1
000008  b10b              CBZ      r3,|L6.14|
;;;290      {
;;;291        bitstatus = (uint8_t)Bit_SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L6.16|
                  |L6.14|
;;;292      }
;;;293      else
;;;294      {
;;;295        bitstatus = (uint8_t)Bit_RESET;
00000e  2000              MOVS     r0,#0
                  |L6.16|
;;;296      }
;;;297      return bitstatus;
;;;298    }
000010  4770              BX       lr
;;;299    
                          ENDP


                          AREA ||i.GPIO_ReadOutputData||, CODE, READONLY, ALIGN=1

                  GPIO_ReadOutputData PROC
;;;342    */
;;;343    uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
000000  4601              MOV      r1,r0
;;;344    {
;;;345      /* Check the parameters */
;;;346      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;347      
;;;348      return ((uint16_t)GPIOx->ODR);
000002  68c8              LDR      r0,[r1,#0xc]
000004  b280              UXTH     r0,r0
;;;349    }
000006  4770              BX       lr
;;;350    
                          ENDP


                          AREA ||i.GPIO_ReadOutputDataBit||, CODE, READONLY, ALIGN=1

                  GPIO_ReadOutputDataBit PROC
;;;319    */
;;;320    uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  4602              MOV      r2,r0
;;;321    {
;;;322      uint8_t bitstatus = 0x00;
000002  2000              MOVS     r0,#0
;;;323      /* Check the parameters */
;;;324      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;325      assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
;;;326      
;;;327      if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
000004  68d3              LDR      r3,[r2,#0xc]
000006  400b              ANDS     r3,r3,r1
000008  b10b              CBZ      r3,|L8.14|
;;;328      {
;;;329        bitstatus = (uint8_t)Bit_SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L8.16|
                  |L8.14|
;;;330      }
;;;331      else
;;;332      {
;;;333        bitstatus = (uint8_t)Bit_RESET;
00000e  2000              MOVS     r0,#0
                  |L8.16|
;;;334      }
;;;335      return bitstatus;
;;;336    }
000010  4770              BX       lr
;;;337    
                          ENDP


                          AREA ||i.GPIO_ResetBits||, CODE, READONLY, ALIGN=1

                  GPIO_ResetBits PROC
;;;377    */
;;;378    void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint32_t GPIO_Pin)
000000  6141              STR      r1,[r0,#0x14]
;;;379    {
;;;380      /* Check the parameters */
;;;381      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;382      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;383      GPIOx->BRR = GPIO_Pin;
;;;384    }
000002  4770              BX       lr
;;;385    
                          ENDP


                          AREA ||i.GPIO_SetBits||, CODE, READONLY, ALIGN=2

                  GPIO_SetBits PROC
;;;358    */
;;;359    void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint32_t GPIO_Pin)
000000  f5b14f00          CMP      r1,#0x8000
;;;360    {
;;;361      /* Check the parameters */
;;;362      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;363      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;364      if(GPIO_Pin>GPIO_Pin_15)GPIOE->BSRR_EXT=GPIO_Pin>>16;
000004  d903              BLS      |L10.14|
000006  0c0a              LSRS     r2,r1,#16
000008  4b02              LDR      r3,|L10.20|
00000a  62da              STR      r2,[r3,#0x2c]
00000c  e000              B        |L10.16|
                  |L10.14|
;;;365    	else
;;;366      GPIOx->BSRR = GPIO_Pin;
00000e  6101              STR      r1,[r0,#0x10]
                  |L10.16|
;;;367    	
;;;368    }
000010  4770              BX       lr
;;;369    
                          ENDP

000012  0000              DCW      0x0000
                  |L10.20|
                          DCD      0x40021000

                          AREA ||i.GPIO_StructInit||, CODE, READONLY, ALIGN=1

                  GPIO_StructInit PROC
;;;265    */
;;;266    void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
000000  f06f417f          MVN      r1,#0xff000000
;;;267    {
;;;268      /* Reset GPIO init structure parameters values */
;;;269      GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
000004  6001              STR      r1,[r0,#0]
;;;270      GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
000006  2102              MOVS     r1,#2
000008  7101              STRB     r1,[r0,#4]
;;;271      GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
00000a  2104              MOVS     r1,#4
00000c  7141              STRB     r1,[r0,#5]
;;;272    }
00000e  4770              BX       lr
;;;273    
                          ENDP


                          AREA ||i.GPIO_Write||, CODE, READONLY, ALIGN=1

                  GPIO_Write PROC
;;;420    */
;;;421    void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
000000  60c1              STR      r1,[r0,#0xc]
;;;422    {
;;;423      /* Check the parameters */
;;;424      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;425      
;;;426      GPIOx->ODR = PortVal;
;;;427    }
000002  4770              BX       lr
;;;428    
                          ENDP


                          AREA ||i.GPIO_WriteBit||, CODE, READONLY, ALIGN=1

                  GPIO_WriteBit PROC
;;;396    */
;;;397    void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
000000  b10a              CBZ      r2,|L13.6|
;;;398    {
;;;399      /* Check the parameters */
;;;400      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;401      assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
;;;402      assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
;;;403      
;;;404      if (BitVal != Bit_RESET)
;;;405      {
;;;406        GPIOx->BSRR = GPIO_Pin;
000002  6101              STR      r1,[r0,#0x10]
000004  e000              B        |L13.8|
                  |L13.6|
;;;407      }
;;;408      else
;;;409      {
;;;410        GPIOx->BRR = GPIO_Pin;
000006  6141              STR      r1,[r0,#0x14]
                  |L13.8|
;;;411      }
;;;412    }
000008  4770              BX       lr
;;;413    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Hal_lib\\src\\HAL_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_HAL_gpio_c_f8e8e39a____REV16|
#line 388 "..\\CMSIS_and_startup\\CMSIS\\cmsis_armcc.h"
|__asm___10_HAL_gpio_c_f8e8e39a____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_HAL_gpio_c_f8e8e39a____REVSH|
#line 402
|__asm___10_HAL_gpio_c_f8e8e39a____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_HAL_gpio_c_f8e8e39a____RRX|
#line 587
|__asm___10_HAL_gpio_c_f8e8e39a____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
